{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"链接","date":"2023-03-12T15:18:32.854Z","updated":"2023-03-12T15:18:32.854Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""}],"posts":[{"title":"数学建模笔记","slug":"数学建模笔记/数学建模笔记","date":"2023-04-17T01:13:04.000Z","updated":"2023-04-20T03:21:56.579Z","comments":true,"path":"2023/04/17/数学建模笔记/数学建模笔记/","link":"","permalink":"http://example.com/2023/04/17/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AC%94%E8%AE%B0/","excerpt":"","text":"[toc] matlab语法forfor i&#x3D;1:30 fprintf(‘i:%d’,i);end 矩阵矩阵创建zeros(1,4) %1行4列的全0矩阵（第一个参数表示行数） zeros(3,4) %3行4列的全0矩阵（第二个参数表示列数） zeros(4) %4阶（4*4）全0矩阵（只有一个参数则行数列数相同） ones(1,4) %1行4列的全1矩阵. eye(3) %3阶单位矩阵 eye(2,3) %2行3列的单位矩阵 magic(3) %3阶魔方矩阵 magic(30) %30阶魔方矩阵 数学模型优化线性规划定义定义首先把问题化为Matlab标准型$$min_{x}-f^{T}x, $$s.t. A·x&lt;&#x3D;b Aeq·x&#x3D;beq lb&lt;&#x3D;x&lt;&#x3D;ubf,x,b,beq,lb,ub均为列向量A，Aeq为矩阵然后准备变量最后调用命令函数[x,fval]&#x3D;linprog(f,A,b)[x,fval]&#x3D;linprog(f,A,b,Aeq,beq)[x,fval]&#x3D;linprog(f,A,b,Aeq,beq,lb,ub)[x,fval]&#x3D;linprog(f,A,b,[],[],lb,ub)&#x2F;&#x2F;Aeq,beq不存在 相关问题绝对值的转换求min $$|x_{1}|+|x_{2}|+…+|x_{n}|$$转换：对任意实数$$x_{i},存在u_{i},v_{i}&gt;&#x3D;0$$满足$$x_{i}&#x3D;u_{i}-v_{i},|x_{i}|&#x3D;u_{i}+v_{i}$$即$$u_{i}&#x3D;\\frac{|x_{i}|+x_{i}}{2},v_{i}&#x3D;\\frac{|x_{i}|-x_{i}}{2}$$进而代入转换 多目标的线性规划可以选择固定多个目标条件使多目标变换为一个目标的线性规划《数学建模算法与应用》p8 12345678910111213141516clc,cleara=0;hold on while a &lt;0.5 c=[-0.05,-0.27,-0.19,-0.185,-0.185]; A=[zeros(4,1),diag([0.025,0.015,0.055,0.026])]; b=a*ones(4,1); Aeq=[1,1.01,1.02,1.045,1.065]; beq=1; LB=zeros(5,1); [x,Q]=linprog(c,A,b,Aeq,beq,LB); Q=-Q; plot(a,Q,&#x27;r*&#x27;); a=a+0.001;endxlabel(&#x27;a&#x27;),ylabel(&#x27;Q&#x27;) 整数规划定义数学规划中的变量（全部或部分）限制为整数现在基本只有求解整数线性规划的方法用Lingo更好 0-1型整数规划相互排斥的约束条件&#x3D;&#x3D;引入&#x3D;&#x3D;&#x3D;&#x3D;普通约束条件&#x3D;&#x3D; 指派问题&#x3D;&#x3D;数学模型&#x3D;&#x3D;&#x3D;&#x3D;Matlab代码&#x3D;&#x3D; 12345678910111213141516171819clc,clear c=[3 8 2 10 3; 8 7 2 9 7; 6 4 2 7 5; 8 4 2 3 5; 9 10 6 9 10];n=5;c=c(:);a=zeros(2*n,n^2);intcon=1:n^2;for i=1:na(i,(i-1)*n+1:n*i)=1;v a(n+i,i:n:n^2)=1;endb=ones(2*n,1);lb=zeros(n^2,1);ub=ones(n^2,1);x=intlinprog(c,intcon,[],[],a,b,lb,ub);x=reshape(x,[n,n]) 非线性规划定义如果目标函数或约束条件中包含非线性函数,就称这种规划问题为非线性规划问题。一般说来,解非线性规划要比解线性规划问题困难得多。而且,也不像线性规划有单纯形法这一通用方法,非线性规划目前还没有适于各种问题的一般算法,各个方法都有自己特定的适用范围。 注意线性规划如果存在最优解则只能在其可行域的边界上非线性规划则可能在其可行域的任意一点达到 非线性规划的一般解法（fmincon）模型： matlab函数命令： 1[x,fval]=fmincon(fun,x0,A,b,Aeq,beq,lb,ub,nonlcon,options) 参数解释：x：返回决策向量x的取值fval：返回目标函数的取值fun：用M文件定义的函数f(x)x0：x的初始值A,b,Aeq,beq：线性约束条件lb,ub：上下界nonlcon：用M文件定义的非线性向量函数c(x),ceq(x)非线性约束条件options：优化参数 例子： 无约束问题无约束极值问题的符号解（依靠特征值的正负判断）无约束极值问题的数值解（fminunc和fminsearch）求函数的零点和方程组的解（）","categories":[],"tags":[]},{"title":"爬虫","slug":"爬虫/爬虫","date":"2023-04-11T10:41:14.000Z","updated":"2023-04-11T10:41:14.964Z","comments":true,"path":"2023/04/11/爬虫/爬虫/","link":"","permalink":"http://example.com/2023/04/11/%E7%88%AC%E8%99%AB/%E7%88%AC%E8%99%AB/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"机器学习","slug":"机器学习/机器学习","date":"2023-04-11T10:40:56.000Z","updated":"2023-04-14T15:57:19.744Z","comments":true,"path":"2023/04/11/机器学习/机器学习/","link":"","permalink":"http://example.com/2023/04/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"记录","slug":"记录/记录","date":"2023-03-28T14:41:16.000Z","updated":"2023-04-14T15:57:19.744Z","comments":true,"path":"2023/03/28/记录/记录/","link":"","permalink":"http://example.com/2023/03/28/%E8%AE%B0%E5%BD%95/%E8%AE%B0%E5%BD%95/","excerpt":"","text":"常用记录C++scanf不安全#define _CRT_SECURE_NO_WARNINGS 【C++】| 将程序打包成可执行文件（.exe）| Visual Studiohttps://blog.csdn.net/HaohaoCppDebuger/article/details/123451160 ffmpeg使用教程https://www.jianshu.com/p/2c00a1a59af1 在线思维导图https://www.processon.com/diagrams 在线转换pdfhttps://convertio.co/zh/pptx-pdf/ 在线解密pdfhttps://smallpdf.com/cn/result#r=02670d7e41d25b3d4b4e002b9ad38d42&amp;t=unlock Arduino代码教程https://blog.csdn.net/SumubeiFZ/article/details/118638228 硬件教程https://blog.csdn.net/SFME008/article/details/110479408 模拟器https://www.tinkercad.com/ 密码mysqlmysql -u root -p ho%anXp.(0de 宝塔面板外网面板地址: http://47.98.106.218:8888/e862f26b内网面板地址: http://172.21.188.44:8888/e862f26busername: psj97ktbpassword: 052a5ef7 数据库账号数据库名：47_98_106_218 用户：47_98_106_218 密码：sSnAMdGsECeZ6TMM 短期任务 WEB 数据结构树完成 线性代数 长期任务1234567891011121314151617graph LRA(任务点)--&gt;B1(学校学习)B1--&gt;C1(马原)B1--&gt;C2(六级12.10)B1--&gt;C3(线性代数)B1--&gt;C4(口译周四前)C4--&gt;E(三,四,五+课文)B1--&gt;C5(形式与政策)A--&gt;B2(个性化)B2--&gt;D1(数据结构)D1--&gt;E2(学期结束前学完)B2--&gt;D2(数据库)B2--&gt;D3(C++)B2--&gt;D4(JAVA)B2--&gt;D5(wx,js)B2--&gt;D6(Unity) 阿里云服务器云服务器Anxy9493 实例登录名：root实例密码：@Z94y9397云数据库mzxxyddz94y9397云数据库账号zxxyddZ94y9397云数据库外网地址rm-bp1nmvt3r7t7v1e7zwo.mysql.rds.aliyuncs.com宝塔外网面板地址: https://47.120.14.52:29842/9789895a内网面板地址: https://172.27.217.192:29842/9789895ausername: owk5vwkapassword: 454bb5cb账号17315813369@Z94y9397博客园安xyz94y9397 &#x61;&#x6e;&#115;&#104;&#101;&#110;&#x67;&#x39;&#52;&#x39;&#x33;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;Z94y9397 人工智能pyhton基础 每天一个半小时，一周内结束掉 数据分析基础（爬虫以及三剑客python的库Numpy、Pandas和Matplotlib）1h 机器学习 2h 深度学习 cv","categories":[{"name":"记录","slug":"记录","permalink":"http://example.com/categories/%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"记录","slug":"记录","permalink":"http://example.com/tags/%E8%AE%B0%E5%BD%95/"}]},{"title":"项目开发","slug":"项目开发/项目开发","date":"2023-03-17T03:10:08.000Z","updated":"2023-03-17T03:10:08.245Z","comments":true,"path":"2023/03/17/项目开发/项目开发/","link":"","permalink":"http://example.com/2023/03/17/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"算法专题","slug":"算法/算法专题","date":"2023-03-13T10:31:22.000Z","updated":"2023-04-14T15:57:19.750Z","comments":true,"path":"2023/03/13/算法/算法专题/","link":"","permalink":"http://example.com/2023/03/13/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/","excerpt":"","text":"进度STL专题学习（书本基本知识+vjudge+洛谷+cf）往年真题每天6小时间，15题目，一专题专题算法&gt;小算法&gt;STL&gt;c++&gt;机器学习&gt;项目18天暴力枚举[2]贪心[3]动态[3]*排序[2]搜索[2]*图论[2]数论[3]字符串算法[2]数据结构[2]openai_api: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 动态规划核心：状态与状态转移方程 背包九讲述一、01背包问题题目有 N 件物品和一个容量为 V 的背包。放入第 i 件物品耗费的费用是 Ci1，得到的价值是 Wi。求解将哪些物品装入背包可使价值总和最大。状态与状态转移方程分析状态： F[i, v] 表示前 i 件物品恰放入一个容量为 v 的背包可以获得的最大价值。状态转移方程：F[i, v] &#x3D; max{F[i − 1, v], F[i − 1, v − Ci] + Wi}F[i − 1, v]：当前物品不选，前i-1件物品，放入容量为v的背包的最大价值F[i − 1, v − Ci] + Wi：往前物品选取，前i件物品放入容量为v-Ci的背包的最大价值 代码 1234F[0, 0..V ] ← 0for i ← 1 to N for v ← Ci to V（V to Ci） F[i, v] ← max&#123;F[i − 1, v], F[i − 1, v − Ci] + Wi&#125; 优化空间复杂度F[0..V ] ←0for i ← 1 to Nfor v ← V to CiF[v] ← max{F[v], F[v − Ci] + Wi} 优化后代码 123456def ZeroOnePack(F, C, W)： for v ← V to C F[v] ← max(F[v], F[v − C] + W)F[0..V ] ←0for i ← 1 to N ZeroOnePack(F, Ci, Wi) 1234F[0..V ] ←0for i ← 1 to N for v ← V to Ci F[v] ← max(F[v], F[v − Ci] + Wi) 二、完全背包问题题目有 N 种物品和一个容量为 V 的背包，每种物品都有&#x3D;&#x3D;无限件&#x3D;&#x3D;可用。放入第 i 种物品的费用是 Ci，价值是 Wi。求解：将哪些物品装入背包，可使这些物品的耗费的费用总和不超过背包容量，且价值总和最大。状态与状态转移方程状态：F[i, v] 表示前 i 种物品恰放入一个容量为 v的背包的最大权值。状态转移方程：F[i, v] &#x3D; max{F[i − 1, v − kCi] + kWi| 0 ≤ kCi ≤ v}代码 1234F[0..V ] ←0for i ← 1 to N for v ← Ci to V F[v] ← max(F[v], F[v − Ci] + Wi) 三、多重背包问题题目有 N 种物品和一个容量为 V 的背包。第 i 种物品最多有&#x3D;&#x3D; Mi&#x3D;&#x3D; 件可用，每件耗费的空间是 Ci，价值是 Wi。求解将哪些物品装入背包可使这些物品的耗费的空间总和超过背包容量，且价值总和最大状态转移方程F[i，v] &#x3D; max{F[i − 1, v − k ∗ Ci] + k ∗ Wi| 0 ≤ k ≤ Mi}代码O($log^M$) 12345678910def MultiplePack(F,C,W,M)if C · M ≥ V //相当于无限，完全背包问题 CompletePack(F,C,W)// returnk ← 1while k &lt; M ZeroOnePack(kC,kW) //将M件分为，系数为不大于K($M_i-2^k+1&gt;0$)的1，2，$2^2$...$2^&#123;k-1&#125;$,$M_i-2^k+1$为系数的k+1件物品，进行01背包 M ←M − k k ← 2k //计算下一个k的过程ZeroOnePack(C · M,W · M)//最后一个系数的01背包 可行性问题O(VN) 123456789101112F[0, 1 . . . V ] ← −1F[0, 0] ← 0for i ← 1 to N for j ← 0 to V if F[i − 1][j] ≥ 0 F[i][j] = Mi else F[i][j] = −1 for j ← 0 to V − Ci if F[i][j] &gt; 0 F[i][j + Ci] ← max&#123;F[i][j + Ci], F[i][j] − 1&#125;最终 F[N][0 . . . V ] 便是多重背包可行性问题的答案 四、混合三种背包问题01 背包与完全背包的混合O(VN) 1234567for i ← 1 to N if 第 i 件物品属于 01 背包 for v ← V to Ci F[v] ← max(F[v], F[v − Ci] + Wi) else if 第 i 件物品属于完全背包 for v ← Ci to V F[v] ← max(F[v], F[v − Ci] + Wi) 再加上背包问题 1234567for i ← 1 to N if 第 i 件物品属于 01 背包 ZeroOnePack(F,Ci,Wi) else if 第 i 件物品属于完全背包 CompletePack(F,Ci,Wi) else if 第 i 件物品属于多重背包 MultiplePack(F,Ci,Wi,Ni) 五、二维费用的背包问题题目二维费用的背包问题是指：对于每件物品，具有两种不同的费用，选择这件物品必须同时付出这两种费用。对于每种费用都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。设第 i 件物品所需的两种费用分别为 Ci 和 Di。两种费用可付出的最大值（也即两种背包容量）分别为 V 和 U。物品的价值为 Wi。状态F[i, v, u] &#x3D; max{F[i − 1, v, u], F[i − 1, v − Ci, u − Di] + Wi}如前述优化空间复杂度的方法，可以只使用二维的数组：当每件物品只可以取一次时变量 v 和 u 采用逆序的循环，当物品有如完全背包问题时采用顺序的循环，当物品有如多重背包问题时拆分物品。 六、分组背包问题题目有 N 件物品和一个容量为 V 的背包。第 i 件物品的费用是 Ci，价值是 Wi。这些物品被划分为 K 组，每组中的物品互相冲突，最多选一件。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。状态转移方程F[k, v] &#x3D; max{F[k − 1, v], F[k − 1, v − Ci] + Wi| item i ∈ group k}代码 1234for k ← 1 to K for v ← V to 0 for all item i in group k F[v] ← max&#123;F[v], F[v − Ci] + Wi&#125; 七、有依赖的背包问题问题这种背包问题的物品间存在某种“依赖”的关系。也就是说，物品 i 依赖于物品 j，表示若选物品 i，则必须选物品 j。为了简化起见，我们先设没有某个物品既依赖于别的物品，又被别的物品所依赖；另外，没有某件物品同时依赖多件物品。算法将之转化为分组背包问题：每个选择了主件又选择了若干个附件的策略对应于这个物品组中的一个物品策略优化：对主件k的“附件集合”先进行一次01背包问题代码 1234567891011121314#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std; int T,M,t,m,dp[1001];int main()&#123; cin&gt;&gt;T&gt;&gt;M; for(int i=1;i&lt;=M;i++)&#123; cin&gt;&gt;t&gt;&gt;m; for(int j=T;j&gt;=t;j--)&#123; dp[j]=max(dp[j],dp[j-t]+m); &#125; &#125; cout&lt;&lt;dp[T];&#125; 记忆化搜索DAG上的动态规划求不固定顶点的最长路径d(i)表示从i开始的最长路径状态转移方程：d(i)&#x3D;max{d(j)+1,1}(i,j)属于边集合 123456789int dp(int i) &#123;int&amp; ans = d[i];if(ans &gt; 0) return ans;ans = 1;for(int j = 1; j &lt;= n; j＋＋)if(G[i][j]) ans = max(ans, dp(j)＋1);return ans;&#125; 基础DP最长公共子序列问题(p517跳转程序设计竞赛)状态转移方程dp[i+1][j+1]&#x3D;dp[i][j]+1 ($$s_(i+1)$$&#x3D;&#x3D;$$t_(j+1)$$) &#x3D;max(dp[i][j+1],dp[i+1][j]) (其他) 代码 1234567891011121314151617int n,m;char s[MAX_N],t[MAX_M];int dp[MAX_N+1][MAX_M+1]; //DP数组void slove()&#123; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; if(s[i]==t[j])&#123; dp[i+1][j+1]=dp[i][j]+1; &#125;else&#123; dp[i+1][j+1]=max(dp[i][j+1],dp[i+1][j]); &#125; &#125; &#125; cout&lt;&lt;dp[n][m];&#125; 最长上升子序列状态转移方程d(i)&#x3D;max{0,d(j)|j&lt;i,$$A_(j)&lt;A_i$$}+1 代码 1234567891011int n;cahr s[MAX];int d[MAX+1];void slove()&#123; for(int i=1;i&lt;n;i++)&#123; for(int j=0;j&lt;i;j++) if(s[i]&gt;s[j])&#123; d[i]=max(0,d[j])+1;8 &#125; &#125;&#125; 暴力枚举枚举排列生成1~n的全排列对1~n每个作为开始递归 123456789101112131415161718void print_permutation(int n,int *A,int cur) &#123; if (cur == n) &#123; for (int i = 0; i &lt; n;i++)cout &lt;&lt; A[i]; cout &lt;&lt; endl; &#125; else &#123; for (int i = 1; i &lt;= n; i++) &#123; int ok = 1; for (int j = 0; j &lt; cur; j++) &#123; if (A[j] == i)ok = 0; &#125; if (ok) &#123; A[cur] = i; print_permutation(n, A, cur + 1); &#125; &#125; &#125;&#125; 生成可重集的排列123456789101112131415161718192021void print_permutation(int n,int *P,int *A,int cur) &#123; if (cur == n) &#123; for (int i = 0; i &lt; n;i++)cout &lt;&lt; A[i]; cout &lt;&lt; endl; &#125; else &#123; for (int i = 0; i &lt; n; i++) &#123; if(!i||p[i]!=p[i-1])&#123; int ok = 1; for (int j = 0; j &lt; cur; j++) &#123; if (A[j] == P[i])ok = 0;8 &#125; if (ok) &#123; A[cur] = P[i]; print_permutation(n,P, A, cur + 1); &#125; &#125; &#125; &#125;&#125; 使用STL中的next_permutation12345678910int main() &#123; int n = 3; int p[3] = &#123; 2,1,3 &#125;; sort(p, p + n); do &#123; for (int i = 0; i &lt; n; i++)cout &lt;&lt; p[i]; cout &lt;&lt; endl; &#125;while (next_permutation(p, p + n)); return 0;&#125; 子集生成增量构造法每次开始的位置+1,且每次都输出 1234567001012021122 123456789void print_subset(int n, int* A, int cur) &#123; for (int i = 0; i &lt; cur; i++)cout &lt;&lt; A[i]; cout &lt;&lt; endl; int s = cur ? A[cur - 1] + 1 : 0; for (int i = s; i &lt; n; i++) &#123; A[cur] = i; print_subset(n, A, cur+1); &#125;&#125; 位向量法同全排列一样，到n才输出，选取位置1，否则0 1234567891011void print_subset(int n,int* B,int cur)&#123; if(cur==n)&#123; for(int i=0;i&lt;cur;i++) if(B[i])cout&lt;&lt;i; cout&lt;&lt;endl; &#125; B[cur]=1;//选取 print_subset(n,B,cur+1); B[cur]=0;//不选取 print_subset(n,B,cur+1);&#125; 二进制法三个数的集合001，010，100s从000到111 12345678void print_subset()&#123; for(int i=0;i&lt;n;i++) if(s&amp;(1&lt;&lt;i))cout&lt;&lt;i; cout&lt;&lt;endl;&#125;for(int i=0;i&lt;(1&lt;&lt;n);i++)&#123; // print_subset(n,i)&#125; 回溯法在递归中判断 八皇后问题常规法递归每一行可能放置的列，并且检查是否冲突（回溯），若不冲突，继续递归 123456789101112void search(int cur)&#123; if(cur==n)total++; else for(int i=0;i&lt;n;i++)&#123; int ok=1; C[cur]=i; //把第cur行的皇后放在i列 for(int j=0;j&lt;cur;j++)&#123;//检查和之前皇后的冲突问题 if(C[cur]==C[j]||cur-C[cur]==j-C[j]||cur+C[cur]==j+C[cur]) &#123;ok=0;break;&#125; &#125; if(ok)search(cur+1); &#125;&#125; 优化版（数组）用二维数组来判断列、副对角线、主对角线的冲突情况:vis[0][i]:第i列冲突情况vis[1][x+y]:副对角线冲突情况坐标（x，y）vis[1][y-x+n]:主对角线冲突情况坐标（x，y） 1234567891011`void search(int cur)&#123; if(cur==n)total++; else for(int i=0;i&lt;n;i++)&#123; if(!vis[0][i]&amp;&amp;!vis[1][i+cur]&amp;&amp;!vis[1][cur-i+n])&#123;//判断冲突 C[cur]=i; vis[0][i]=vis[1][i+cur]=vis[1][cur-1+n]=1;//更新冲突情况 search(cur+1); vis[0][i]=vis[1][i+cur]=vis[1][cur-1+n]=0;//当前i不可行，复原冲突情况 &#125; &#125;&#125; 素数环 UVa 524使用回溯，判断是否使用过以及是否和前一个之和为素数 12345678910111213141516171819202122232425262728293031int main()&#123; int A[16]; int isp[32]; int n; cin&gt;&gt;n; for(int i=2;i&lt;=2*n;i++)isp[i]=is_prime(i);//生成素数表 for(int i=2;i&lt;=n;i++)vis[i]=0;//未被选择 dfs(1,n,A,isp,vis); return 0;&#125;void dfs(int cur,int n,int *A,int *isp,int *vis)&#123; if(cur==n&amp;&amp;isp[A[0]+A[n-1]])&#123; //测试边界是否满足 for(int i=0;i&lt;n;i++)cout&lt;&lt;A[i]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; &#125; else for(int i=2;i&lt;=n;i++)&#123; if(!vis[i]&amp;&amp;isp[i+A[cur-1]])&#123;//没有选择过且和前一位之和为素数 A[cur]=i; vis[i]=1; //标记使用过 dfs(cur+1,n,A,isp,vis); vis[i]=0; //清除标记 &#125; &#125;&#125;int is_prime(int i)&#123; if(i&lt;=1)return 0; for(int i=2;i&lt;=sqrt(n);i++)&#123; if(n%i==0)return 0; &#125; return 1;&#125; 困难的串 UVa 1291 带宽 UVa 140天平难题 UVa 1354贪心动态排序搜索图论数论字符串算法数据结构","categories":[{"name":"-算法专题","slug":"算法专题","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/"}],"tags":[{"name":"-算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"C++笔记","slug":"C++/C++笔记","date":"2023-03-13T10:26:45.000Z","updated":"2023-03-13T10:30:27.784Z","comments":true,"path":"2023/03/13/C++/C++笔记/","link":"","permalink":"http://example.com/2023/03/13/C++/C++%E7%AC%94%E8%AE%B0/","excerpt":"","text":"vector12vector&lt;int&gt; A;A[0]=1; 会报错，因为A还是空，需要A.push_back(1)","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"all","slug":"算法/all","date":"2023-03-13T01:17:35.000Z","updated":"2023-03-13T01:34:42.103Z","comments":true,"path":"2023/03/13/算法/all/","link":"","permalink":"http://example.com/2023/03/13/%E7%AE%97%E6%B3%95/all/","excerpt":"","text":"[toc] 数据结构数组二分法 非递归 1234567891011121314151617181920212223class Solution &#123; public int search(int[] nums, int target) &#123; if (target &lt; nums[0] || target &gt; nums[nums.length - 1]) &#123; return -1; &#125; int left = 0; int right = nums.length - 1; while (left &lt;= right) &#123; int mid = (left + right) / 2; if (nums[mid] == target) &#123; return mid; &#125; else if (target &lt; nums[mid]) &#123; right = mid - 1; &#125; else if (target &gt; nums[mid]) &#123; left = mid + 1; &#125; &#125; return -1; &#125;&#125; 递归 123456789101112131415161718192021222324252627282930package javasuanfa;public class Main &#123; public static void main(String[] args) &#123; int[] nums = &#123;1, 2, 3, 4, 5, 6&#125;; int target = 3; System.out.println(search(nums, target,0,nums.length-1)); &#125; public static int search(int[] nums, int target, int left, int right) &#123; if (target &lt; nums[0] || target &gt; nums[nums.length - 1]) &#123; return -1; &#125; left = 0; right = nums.length - 1; int mid = (left + right) / 2; if (target &lt; nums[mid]) &#123; return search(nums, target, left, mid - 1); &#125; else if (target &gt; nums[mid]) &#123; return search(nums, target, mid + 1, right); &#125; else &#123; return mid; &#125; &#125; &#125; 双指针删除数组元素1234567891011121314class Solution &#123; public int removeElement(int[] nums, int val) &#123; int slowp=0; for(int fastp=0;fastp&lt;nums.length;fastp++)&#123; if(nums[fastp]!=val)&#123; nums[slowp++]=nums[fastp]; &#125; &#125; return slowp; &#125;&#125; 有序数组平方1234567891011121314151617181920class Solution &#123; public int[] sortedSquares(int[] nums) &#123; int[] result =new int[nums.length]; int left=0; int right=nums.length-1; for(int k=nums.length-1;k&gt;=0;k--)&#123; int lsquare=nums[left]*nums[left]; int rqsuare=nums[right]*nums[right]; if(rqsuare&gt;lsquare) &#123; result[k] = rqsuare; right--; &#125; else &#123; result[k]=lsquare; left++; &#125; &#125; return result; &#125;&#125; 滑动窗口(长度最小子数组)123456789101112131415class Solution &#123; public int minSubArrayLen(int target, int[] nums) &#123; int left = 0; int sum = 0; int result = Integer.MAX_VALUE; for (int right = 0; right &lt; nums.length; right++) &#123; sum += nums[right]; while (sum &gt;= target) &#123; result = Math.min(result, right - left + 1); sum -= nums[left++]; &#125; &#125; return result == Integer.MAX_VALUE ? 0 : result; &#125;&#125; 螺旋矩阵1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution &#123; public int[][] generate Matrix(int n) &#123; int[][] result = new int[n][n]; //填充数字 int insert=1; //循环次数 int loop = n / 2; //偏移量 int offset=0; //起始位置 int StartX = 0; int StartY = 0; //坐标 int x = 0; int y = 0; //中间 int mid=n/2; while (loop&gt;0)&#123; x=StartX; y=StartY; //上行 for(;x&lt;n-offset-1;x++)&#123; result[y][x]=insert++; &#125; //右列 for (;y&lt;n-offset-1;y++)&#123; result[y][x]=insert++; &#125; //下列 for(;x&gt;StartX;x--)&#123; result[y][x]=insert++; &#125; //左列 for (;y&gt;StartY;y--)&#123; result[y][x]=insert++; &#125; loop--; offset++; StartX++; StartY++; &#125; if(n%2==1)result[mid][mid]=insert; if(n==1)result[0][0]=1; return result; &#125;&#125; 广义表1. 广义表的定义 广义表(Lists，又称列表)是线性表的推广。即广义表中放松对表元素的原子限制，容许它们具有其自身结构。 广义表是n(n≥0)个元素a1，a2，…，ai，…，an的有限序列。 其中： ①ai–或者是原子或者是一个广义表。 ②广义表通常记作： Ls&#x3D;( a1，a2，…，ai，…，an)。 ③Ls是广义表的名字，n为它的长度。 ④若ai是广义表，则称它为Ls的子表。 注意： ①广义表通常用圆括号括起来，用逗号分隔其中的元素。 ②为了区分原子和广义表，书写时用大写字母表示广义表，用小写字母表示原子。 ③若广义表Ls非空(n≥1)，则al是LS的表头，其余元素组成的表(a1，a2，…，an)称为Ls的表。 ​ ④广义表是递归定义的。 2. 广义表的表示 （1）广义表常用表示 ① E&#x3D;() E是一个空表，其长度为0。 ② L&#x3D;(a，b) L是长度为2的广义表，它的两个元素都是原子，因此它是一个线性表 ③ A&#x3D;(x，L)&#x3D;(x，(a，b)) A是长度为2的广义表，第一个元素是原子x，第二个元素是子表L。 ④ B&#x3D;(A，y)&#x3D;((x，(a，b))，y) B是长度为2的广义表，第一个元素是子表A，第二个元素是原子y。 ⑤ C&#x3D;(A，B)&#x3D;((x，(a，b))，((x，(a，b))，y)) C的长度为2，两个元素都是子表。 ⑥ D&#x3D;(a，D)&#x3D;(a，(a，(a，(…)))) D的长度为2，第一个元素是原子，第二个元素是D自身，展开后它是一个无限的广义表。 （2）广义表的深度 一个表的”深度”是指表展开后所含括号的层数。 【例】表L、A、B、C的深度为分别为1、2、3、4，表D的深度为∞。 （3）带名字的广义表表示 如果规定任何表都是有名字的，为了既表明每个表的名字，又说明它的组成，则可以在每个表的前面冠以该表的名字，于是上例中的各表又可以写成： ①E() ②L(a，b) ③A(x，L(a，b)) ④B(A(x，L(a，b))，y) ⑤C(A(x，l(a，b))，B(A(x，L(a，b))，y)) ⑥D(a，D(a，D(…))) （4）广义表的图形表示 ①图中的分支结点对应广义表 ②非分支结点一般是原子 ③但空表对应的也是非分支结点。 【例】下图给出了几个广义表的图形表示 图 广义表的图形表示 3. 广义表的操作 广义表的基本操作主要有以下5种： （1）GetHead(L)：求广义表的表头操作。如果广义表是空表，返回NULL，否则返回指向表头结点的指针。 （2）GetTail(L)：求广义表的表尾操作。如果广义表是空表，返回NULL，否则返回指向表尾结点的指针。 （3）GListLength(L)：返回广义表的长度操作。如果广义表是空表，则返回0，否则返回广义表的长度。 （4）GListDepth(L)：求广义表的深度操作。深度就是广义表中括号嵌套的层数。空表返回1，否则返回表的深度。 （5）CopyGList(&amp;T,L)：广义表的复制操作。由广义表L复制得到广义表T。复制成功返回1，否则返回0。 广义表中的每个元素可以用一个结点表示，表中有两类结点：原子结点和子表结点。广义表可以分解为表头和表尾，一个表头和一个表尾可以确定一个广义表。因此，一个表结点一般由三个域组成：标志域、指向表头的指针域和指向表尾的指针域。一个原子结点一般由两个域组成：标志域和值域。4. 广义表的运算 在此，只讨论广义表的两个特殊的基本运算：取表头head(Ls)和取表尾tail(Ls)。 根据表头、表尾的定义可知：任何一个非空广义表的表头是表中第一个元素，它可以是原子，也可以是子表，而其表尾必定是子表。 【例】 head(L)&#x3D;a， tail(L)&#x3D;(b) head(B)&#x3D;A， tail(B)&#x3D;(y) 由于tail(L)是非空表，可继续分解得到： head(tail(L))&#x3D;b， tail(tail(L))&#x3D;() 对非空表A和(y)，也可继续分解。 注意:广义表()和(())不同。前者是长度为0的空表，对其不能做求表头和表尾的运算；而后者是长度为l的非空表(只不过该表中惟一的一个元素是空表)，对其可进行分解，得到的表头和表尾均是空表()。 表 iterator迭代器 https://blog.csdn.net/qq_29689343/article/details/113832455 SeqList操作合集完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192#include &quot;SeqList.h&quot;#include &quot;stdlib.h&quot; //realloc#include &quot;String&quot; //string#include &quot;assert.h&quot; //assert#include &quot;iostream&quot; //coutusing namespace std;//初始化操作int SeqList:: InitList(SeqList&amp; L) &#123; L.elem = new int[LIST_INIT_SIZE]; L.length = 0; L.listsize = LIST_INIT_SIZE; return OK; &#125;//增加存储容量int SeqList:: addlistsize(SeqList&amp; L, int n) &#123; int* newbase = (int*)realloc(L.elem, (L.listsize + n * LISTINCREMENT) * sizeof(int)); if (!newbase)exit(OVERFLOW); L.elem = newbase; L.listsize += n * LISTINCREMENT;//增加储存容量 return OK;&#125;//结构销毁操作int SeqList:: DestroyList(SeqList&amp; L) &#123; delete[] L.elem; L.elem = NULL; L.length = 0; L.listsize = 0; return OK;&#125;//引用型操作bool SeqList::ListEmpty(SeqList L) &#123; return L.length == 0;&#125;int SeqList::ListLength(SeqList L) &#123; assert(L.elem != NULL); cout &lt;&lt; &quot;顺序表长度：&quot; &lt;&lt; L.length&lt;&lt;endl; return L.length;&#125;//求前驱int SeqList::PriorElem(SeqList L, int cur_e, int&amp; pre_e) &#123; assert(L.elem != NULL); if (LocateElem(L, cur_e) &lt;= 0) &#123; cout &lt;&lt; &quot;该元素无前驱&quot; &lt;&lt; endl; return ERROR; &#125; pre_e = L.elem[LocateElem(L, cur_e) - 1]; cout &lt;&lt; &quot;元素&quot;&lt;&lt;cur_e&lt;&lt;&quot;的前驱：&quot; &lt;&lt; pre_e &lt;&lt; endl; return OK;&#125;//求后驱int SeqList::NextElem(SeqList L, int cur_e, int&amp; next_e) &#123; assert(L.elem != NULL); if (LocateElem(L, cur_e) &gt;= L.length - 1) &#123; cout &lt;&lt; &quot;该元素无后驱&quot; &lt;&lt; endl; return ERROR; &#125; next_e = L.elem[LocateElem(L, cur_e) + 1]; cout &lt;&lt; &quot;元素&quot; &lt;&lt; cur_e &lt;&lt; &quot;的后驱：&quot; &lt;&lt; next_e &lt;&lt; endl; return OK;&#125;//获取第i个元素的值返回于eint SeqList::GetElem(SeqList L, int i, int&amp; e) &#123; assert(L.elem != NULL); if (i &lt; 0 || i &gt; L.length ) &#123; cout &lt;&lt; &quot;越界&quot; &lt;&lt; endl; return ERROR; &#125; e = L.elem[i - 1]; return OK;&#125;//定位元素int SeqList::LocateElem(SeqList L, int e) &#123; assert(L.elem != NULL); for (int i = 0; i &lt; L.length; ++i) &#123; if (L.elem[i] == e) &#123; cout &lt;&lt; &quot;元素&quot; &lt;&lt; e &lt;&lt; &quot;的位置：&quot; &lt;&lt; i&lt;&lt;endl; return i; &#125; &#125; cout &lt;&lt; &quot;该表内无&quot; &lt;&lt; e &lt;&lt; &quot;元素&quot; &lt;&lt; endl; return ERROR;&#125;//遍历打印int SeqList::ListTraverse(SeqList L) &#123; assert(L.elem != NULL); if (L.length == 0)cout &lt;&lt; &quot;该顺序表内无元素&quot; &lt;&lt; endl; cout &lt;&lt; &quot;L内元素为：&quot; ; for (int i = 0; i &lt; L.length; ++i) &#123; cout &lt;&lt; L.elem[i] &lt;&lt; &quot; &quot; ; &#125; cout &lt;&lt; endl; return OK;&#125;//置空int SeqList:: ClearList(SeqList&amp; L) &#123; delete[] L.elem; InitList(L); return OK;&#125;//改变i位置的值int SeqList::PutElem(SeqList&amp; L, int i, int e) &#123; assert(L.elem != NULL); if (i &lt; 0 || i &gt; L.length - 1) &#123; cout &lt;&lt; &quot;越界&quot; &lt;&lt; endl; return ERROR; &#125; L.elem[i] = e; return OK;&#125;//在第i个元素之前插入int SeqList::ListInsert(SeqList&amp; L, int i, int e) &#123; assert(L.elem != NULL); if (i &lt; 1 || i &gt; L.length + 1) &#123; cout &lt;&lt; &quot;插入位置越界&quot; &lt;&lt; endl; return ERROR; &#125; if (L.length &gt;= L.listsize) &#123;//存储空间已满 addlistsize(L, 1);//增加存储10Datatype容量 &#125; for (int j = L.length - 1; j &gt;= i - 1; --j) L.elem[j + 1] = L.elem[j]; L.elem[i - 1] = e; L.length++; return OK;&#125;//删除i个元素int SeqList::ListDelete(SeqList&amp; L, int i, int &amp;e) &#123; assert(L.elem != NULL); if (i &lt; 1 || i &gt; L.length) &#123; cout &lt;&lt; &quot;删除元素越界&quot; &lt;&lt; endl; return ERROR; &#125; e = L.elem[i]; for (; i &lt; L.length-1; ++i) L.elem[i] = L.elem[i+1]; L.length--; return OK;&#125;//尾插int SeqList::SeqListPushBack(SeqList &amp;L, int x) &#123; assert(&amp;L); //L.ListInsert(L,L.length+1,x); 调用插入函数 L.elem[L.length] = x; L.length++; return OK;&#125;//尾删int SeqList::SeqListPopBack(SeqList &amp;L) &#123; assert(&amp;L); int e; L.ListDelete(L,L.length-1,e); return e;&#125;//测试int SeqList:: Test() &#123; SeqList s; s.InitList(s);//初始化 s.SeqListPushBack(s, 1); //尾插 s.SeqListPushBack(s, 2); s.SeqListPushBack(s, 3); s.ListInsert(s, 4, 4); //指定插入 s.ListTraverse(s); //遍历 int e = 2, cure_e = 2; s.LocateElem(s, e);//获取e元素的位置 s.GetElem(s, 3, e);//获取第三个元素的值 s.PriorElem(s, cure_e, e);//求前驱 s.NextElem(s, cure_e, e);//求后驱 s.ListLength(s); //顺序表长度 s.PutElem(s, 2, 5);//改变第三个元素的值 s.SeqListPopBack(s); //尾删 s.ListTraverse(s); //遍历 s.ListLength(s); s.ClearList(s); //置空 s.ListTraverse(s); s.DestroyList(s); //销毁 s.ListTraverse(s); return OK;&#125; 函数列举初始化操作1234567int SeqList:: InitList(SeqList&amp; L) &#123; L.elem = new int[LIST_INIT_SIZE]; L.length = 0; L.listsize = LIST_INIT_SIZE; return OK; &#125; 增加存储容量1234567int SeqList:: addlistsize(SeqList&amp; L, int n) &#123; int* newbase = (int*)realloc(L.elem, (L.listsize + n * LISTINCREMENT) * sizeof(int)); if (!newbase)exit(OVERFLOW); L.elem = newbase; L.listsize += n * LISTINCREMENT;//增加储存容量 return OK;&#125; 结构销毁操作1234567int SeqList:: DestroyList(SeqList&amp; L) &#123; delete[] L.elem; L.elem = NULL; L.length = 0; L.listsize = 0; return OK;&#125; 判空123bool SeqList::ListEmpty(SeqList L) &#123; return L.length == 0;&#125; 求长12345int SeqList::ListLength(SeqList L) &#123; assert(L.elem != NULL); cout &lt;&lt; &quot;顺序表长度：&quot; &lt;&lt; L.length&lt;&lt;endl; return L.length;&#125; 求前驱12345678910111213int SeqList::PriorElem(SeqList L, int cur_e, int&amp; pre_e) &#123; assert(L.elem != NULL); if (LocateElem(L, cur_e) &lt;= 0) &#123; cout &lt;&lt; &quot;该元素无前驱&quot; &lt;&lt; endl; return ERROR; &#125; pre_e = L.elem[LocateElem(L, cur_e) - 1]; cout &lt;&lt; &quot;元素&quot;&lt;&lt;cur_e&lt;&lt;&quot;的前驱：&quot; &lt;&lt; pre_e &lt;&lt; endl; return OK;&#125; 求后驱123456789101112int SeqList::NextElem(SeqList L, int cur_e, int&amp; next_e) &#123; assert(L.elem != NULL); if (LocateElem(L, cur_e) &gt;= L.length - 1) &#123; cout &lt;&lt; &quot;该元素无后驱&quot; &lt;&lt; endl; return ERROR; &#125; next_e = L.elem[LocateElem(L, cur_e) + 1]; cout &lt;&lt; &quot;元素&quot; &lt;&lt; cur_e &lt;&lt; &quot;的后驱：&quot; &lt;&lt; next_e &lt;&lt; endl; return OK;&#125; 获取第i个元素的值返回于e12345678910int SeqList::GetElem(SeqList L, int i, int&amp; e) &#123; assert(L.elem != NULL); if (i &lt; 0 || i &gt; L.length ) &#123; cout &lt;&lt; &quot;越界&quot; &lt;&lt; endl; return ERROR; &#125; e = L.elem[i - 1]; return OK;&#125; 定位元素123456789101112int SeqList::LocateElem(SeqList L, int e) &#123; assert(L.elem != NULL); for (int i = 0; i &lt; L.length; ++i) &#123; if (L.elem[i] == e) &#123; cout &lt;&lt; &quot;元素&quot; &lt;&lt; e &lt;&lt; &quot;的位置：&quot; &lt;&lt; i&lt;&lt;endl; return i; &#125; &#125; cout &lt;&lt; &quot;该表内无&quot; &lt;&lt; e &lt;&lt; &quot;元素&quot; &lt;&lt; endl; return ERROR;&#125; 遍历打印1234567891011int SeqList::ListTraverse(SeqList L) &#123; assert(L.elem != NULL); if (L.length == 0)cout &lt;&lt; &quot;该顺序表内无元素&quot; &lt;&lt; endl; cout &lt;&lt; &quot;L内元素为：&quot; ; for (int i = 0; i &lt; L.length; ++i) &#123; cout &lt;&lt; L.elem[i] &lt;&lt; &quot; &quot; ; &#125; cout &lt;&lt; endl; return OK;&#125; 置空123456int SeqList:: ClearList(SeqList&amp; L) &#123; delete[] L.elem; InitList(L); return OK;&#125; 改变i位置的值12345678910int SeqList::PutElem(SeqList&amp; L, int i, int e) &#123; assert(L.elem != NULL); if (i &lt; 0 || i &gt; L.length - 1) &#123; cout &lt;&lt; &quot;越界&quot; &lt;&lt; endl; return ERROR; &#125; L.elem[i] = e; return OK;&#125; 在第i个元素之前插入12345678910111213141516int SeqList::ListInsert(SeqList&amp; L, int i, int e) &#123; assert(L.elem != NULL); if (i &lt; 1 || i &gt; L.length + 1) &#123; cout &lt;&lt; &quot;插入位置越界&quot; &lt;&lt; endl; return ERROR; &#125; if (L.length &gt;= L.listsize) &#123;//存储空间已满 addlistsize(L, 1);//增加存储10Datatype容量 &#125; for (int j = L.length - 1; j &gt;= i - 1; --j) L.elem[j + 1] = L.elem[j]; L.elem[i - 1] = e; L.length++; return OK;&#125; 删除i个元素12345678910111213int SeqList::ListDelete(SeqList&amp; L, int i, int &amp;e) &#123; assert(L.elem != NULL); if (i &lt; 1 || i &gt; L.length) &#123; cout &lt;&lt; &quot;删除元素越界&quot; &lt;&lt; endl; return ERROR; &#125; e = L.elem[i]; for (; i &lt; L.length-1; ++i) L.elem[i] = L.elem[i+1]; L.length--; return OK;&#125; 尾插12345678int SeqList::SeqListPushBack(SeqList &amp;L, int x) &#123; assert(&amp;L); //L.ListInsert(L,L.length+1,x); 调用插入函数 L.elem[L.length] = x; L.length++; return OK;&#125; 置空123456int SeqList:: ClearList(SeqList&amp; L) &#123; delete[] L.elem; InitList(L); return OK;&#125; 尾删12345678int SeqList::SeqListPopBack(SeqList &amp;L) &#123; assert(&amp;L); int e; L.ListDelete(L,L.length-1,e); return e;&#125; LinkedList操作合集123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250#include &quot;ListNode.h&quot;#include &quot;iostream&quot;using namespace std;ListNode::ListNode()&#123; this-&gt;val =0; this-&gt;next =nullptr;&#125;ListNode::ListNode(int val, ListNode* next)&#123; this-&gt;val = val; this-&gt;next = next;&#125;ListNode::ListNode(int val)&#123; this-&gt;val = val;&#125;ListNode::ListNode( ListNode* next)&#123; this-&gt;next = next;&#125;int ListNode::Val() &#123; return val;&#125;//初始化ListNode* ListNode::initList(ListNode* head,int a[],int n) &#123; int inputnum; int i=0; ListNode* node; ListNode* nodetemp; head = nullptr; nodetemp = nullptr; while (n--) &#123; inputnum=a[i]; i++; node = new ListNode; node-&gt;val = inputnum; if (head == nullptr) &#123; head = node; &#125; else &#123; nodetemp-&gt;next = node; &#125; nodetemp = node; nodetemp-&gt;next = nullptr; &#125; return head;&#125;//创建ListNode* ListNode::CreatList(ListNode* head,int n) &#123; cout &lt;&lt; &quot;input:&quot;; int inputnum; ListNode* node; ListNode* nodetemp; head = nullptr; nodetemp = nullptr; while (n--) &#123; cin &gt;&gt; inputnum; node = new ListNode; node-&gt;val = inputnum; if (head == nullptr) &#123; head = node; &#125; else &#123; nodetemp-&gt;next = node; &#125; nodetemp = node; nodetemp-&gt;next = nullptr; &#125; return head;&#125;//遍历int ListNode::ListTravel(ListNode* head) &#123; cout &lt;&lt; &quot;链表元素依次为：&quot; ; ListNode* curnode=new ListNode(); curnode = head; while (curnode != nullptr) &#123; cout &lt;&lt; curnode-&gt;val&lt;&lt;&quot; &quot;; curnode = curnode-&gt;next; &#125; return OK;&#125;//翻转链表(双指针)ListNode* ListNode::reverseList_1(ListNode* head) &#123; ListNode* temp; //保存cur下一个节点 ListNode* cur = head; ListNode* pre = NULL; while (cur) &#123; temp = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = temp; &#125; return pre;&#125;//翻转链表(递归)ListNode* ListNode::reverseList_2(ListNode* head) &#123; return reverse(NULL, head);&#125;ListNode* ListNode::reverse(ListNode* pre, ListNode* cur) &#123; if (cur == NULL)return pre; ListNode* temp = cur-&gt;next; cur-&gt;next = pre; return reverse(cur, pre);&#125;//链表左右两两交换ListNode* ListNode::swapPairs(ListNode* head) &#123; ListNode* dummtyHead = new ListNode(0);//虚拟头节点 dummtyHead-&gt;next = head; ListNode* cur = dummtyHead; while (cur-&gt;next != NULL &amp;&amp; cur-&gt;next-&gt;next != NULL) &#123; ListNode* tmp = cur-&gt;next;//记录临时节点 ListNode* tmp1 = cur-&gt;next-&gt;next-&gt;next;//记录临时节点 cur-&gt;next = cur-&gt;next-&gt;next-&gt;next;//第一步 cur-&gt;next-&gt;next = tmp;//第二步 cur-&gt;next-&gt;next-&gt;next = tmp1;//第三步 cur = cur-&gt;next-&gt;next;//cur向后移动两位，准备下一轮交换 &#125; return dummtyHead-&gt;next;&#125;//链表长度int ListNode::ListLength(ListNode* head) &#123; ListNode* cur = head; int n = 0; while (cur-&gt;next != NULL) &#123; cur = cur-&gt;next; n++; &#125; return n;&#125;//删除倒数第N个ListNode* ListNode::deletebehindN(ListNode* head, int n) &#123; ListNode* cur = head; int length = ListLength(head); for (int i = 0; i &lt; length - n; i++) &#123; cur = cur-&gt;next; &#125; cur-&gt;next = cur-&gt;next-&gt;next; return head;&#125;//删除倒数第N个(双指针)ListNode* ListNode::removeNthfromEnd(ListNode* head, int n) &#123; ListNode* dummyHead = new ListNode(0); dummyHead-&gt;next = head; ListNode* fast = dummyHead; ListNode* slow = dummyHead; while (n-- &amp;&amp; fast != nullptr) &#123; fast = fast-&gt;next; &#125; fast = fast-&gt;next;//再往前走一步，让slow指向删除节点前一个 while (fast != nullptr) &#123; fast = fast-&gt;next; slow = slow-&gt;next; &#125; slow-&gt;next = slow-&gt;next-&gt;next; return dummyHead-&gt;next;&#125;//判断是否有环ListNode* ListNode::ifcircle(ListNode* head) &#123; ListNode* fast; ListNode* slow; int count = 0; fast = slow = head; while (fast != NULL &amp;&amp; fast-&gt;next != NULL) &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if (fast == slow) &#123; ListNode* index1; ListNode* index2; index1 = head; index2 = fast; while (index1 != index2) &#123; count++; index1 = index1-&gt;next; index2 = index2-&gt;next; &#125; return index2; &#125; &#125; return NULL;&#125;//相交节点ListNode* ListNode::getIntersectionNode(ListNode* headA, ListNode* headB) &#123; ListNode* curA = headA; ListNode* curB = headB; int lenA = 0, lenB = 0; while (curA != NULL) &#123; lenA++; curA = curA-&gt;next; &#125; while (curB != NULL) &#123; lenB++; curB = curB-&gt;next; &#125; curA = headA; curB = headB; if (lenB &gt; lenA) &#123; int i = lenB - lenA; while (i--) &#123; curB = curB-&gt;next; &#125; &#125; else &#123; int i = lenA - lenB; while (i--) &#123; curA = curA-&gt;next; &#125; &#125; while (curA != curB) &#123; //地址相等 curA = curA-&gt;next; curB = curB-&gt;next; &#125; return curA;&#125; 函数列举初始化12345678910111213141516171819202122232425ListNode* ListNode::initList(ListNode* head,int a[],int n) &#123; int inputnum; int i=0; ListNode* node; ListNode* nodetemp; head = nullptr; nodetemp = nullptr; while (n--) &#123; inputnum=a[i]; i++; node = new ListNode; node-&gt;val = inputnum; if (head == nullptr) &#123; head = node; &#125; else &#123; nodetemp-&gt;next = node; &#125; nodetemp = node; nodetemp-&gt;next = nullptr; &#125; return head;&#125; 创建123456789101112131415161718192021222324ListNode* ListNode::CreatList(ListNode* head,int n) &#123; cout &lt;&lt; &quot;input:&quot;; int inputnum; ListNode* node; ListNode* nodetemp; head = nullptr; nodetemp = nullptr; while (n--) &#123; cin &gt;&gt; inputnum; node = new ListNode; node-&gt;val = inputnum; if (head == nullptr) &#123; head = node; &#125; else &#123; nodetemp-&gt;next = node; &#125; nodetemp = node; nodetemp-&gt;next = nullptr; &#125; return head;&#125; 遍历1234567891011int ListNode::ListTravel(ListNode* head) &#123; cout &lt;&lt; &quot;链表元素依次为：&quot; ; ListNode* curnode=new ListNode(); curnode = head; while (curnode != nullptr) &#123; cout &lt;&lt; curnode-&gt;val&lt;&lt;&quot; &quot;; curnode = curnode-&gt;next; &#125; return OK;&#125; 翻转链表(双指针)12345678910111213ListNode* ListNode::reverseList_1(ListNode* head) &#123; ListNode* temp; //保存cur下一个节点 ListNode* cur = head; ListNode* pre = NULL; while (cur) &#123; temp = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = temp; &#125; return pre;&#125; 翻转链表(递归)1234567891011ListNode* ListNode::reverseList_2(ListNode* head) &#123; return reverse(NULL, head);&#125;ListNode* ListNode::reverse(ListNode* pre, ListNode* cur) &#123; if (cur == NULL)return pre; ListNode* temp = cur-&gt;next; cur-&gt;next = pre; return reverse(cur, pre);&#125; 链表左右两两交换1234567891011121314151617ListNode* ListNode::swapPairs(ListNode* head) &#123; ListNode* dummtyHead = new ListNode(0);//虚拟头节点 dummtyHead-&gt;next = head; ListNode* cur = dummtyHead; while (cur-&gt;next != NULL &amp;&amp; cur-&gt;next-&gt;next != NULL) &#123; ListNode* tmp = cur-&gt;next;//记录临时节点 ListNode* tmp1 = cur-&gt;next-&gt;next-&gt;next;//记录临时节点 cur-&gt;next = cur-&gt;next-&gt;next-&gt;next;//第一步 cur-&gt;next-&gt;next = tmp;//第二步 cur-&gt;next-&gt;next-&gt;next = tmp1;//第三步 cur = cur-&gt;next-&gt;next;//cur向后移动两位，准备下一轮交换 &#125; return dummtyHead-&gt;next;&#125; 链表长度12345678910int ListNode::ListLength(ListNode* head) &#123; ListNode* cur = head; int n = 0; while (cur-&gt;next != NULL) &#123; cur = cur-&gt;next; n++; &#125; return n;&#125; 删除倒数第N个123456789101112ListNode* ListNode::deletebehindN(ListNode* head, int n) &#123; ListNode* cur = head; int length = ListLength(head); for (int i = 0; i &lt; length - n; i++) &#123; cur = cur-&gt;next; &#125; cur-&gt;next = cur-&gt;next-&gt;next; return head;&#125; 删除倒数第N个(双指针)123456789101112131415161718ListNode* ListNode::removeNthfromEnd(ListNode* head, int n) &#123; ListNode* dummyHead = new ListNode(0); dummyHead-&gt;next = head; ListNode* fast = dummyHead; ListNode* slow = dummyHead; while (n-- &amp;&amp; fast != nullptr) &#123; fast = fast-&gt;next; &#125; fast = fast-&gt;next;//再往前走一步，让slow指向删除节点前一个 while (fast != nullptr) &#123; fast = fast-&gt;next; slow = slow-&gt;next; &#125; slow-&gt;next = slow-&gt;next-&gt;next; return dummyHead-&gt;next;&#125; 判断是否有环123456789101112131415161718192021222324252627ListNode* ListNode::ifcircle(ListNode* head) &#123; ListNode* fast; ListNode* slow; int count = 0; fast = slow = head; while (fast != NULL &amp;&amp; fast-&gt;next != NULL) &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if (fast == slow) &#123; ListNode* index1; ListNode* index2; index1 = head; index2 = fast; while (index1 != index2) &#123; count++; index1 = index1-&gt;next; index2 = index2-&gt;next; &#125; return index2; &#125; &#125; return NULL;&#125; 相交节点12345678910111213141516171819202122232425262728293031323334353637ListNode* ListNode::getIntersectionNode(ListNode* headA, ListNode* headB) &#123; ListNode* curA = headA; ListNode* curB = headB; int lenA = 0, lenB = 0; while (curA != NULL) &#123; lenA++; curA = curA-&gt;next; &#125; while (curB != NULL) &#123; lenB++; curB = curB-&gt;next; &#125; curA = headA; curB = headB; if (lenB &gt; lenA) &#123; int i = lenB - lenA; while (i--) &#123; curB = curB-&gt;next; &#125; &#125; else &#123; int i = lenA - lenB; while (i--) &#123; curA = curA-&gt;next; &#125; &#125; while (curA != curB) &#123; //地址相等 curA = curA-&gt;next; curB = curB-&gt;next; &#125; return curA;&#125; 移除列表元素（JAVA）123456789101112131415161718192021public ListNode removeElements(ListNode head, int val) &#123; while (head != null &amp;&amp; head.val == val) &#123; head = head.next; &#125; // 已经为null，提前退出 if (head == null) &#123; return head; &#125; // 已确定当前head.val != val ListNode pre = head; ListNode cur = head.next; while (cur != null) &#123; if (cur.val == val) &#123; pre.next = cur.next; &#125; else &#123; pre = cur; &#125; cur = cur.next; &#125; return head;&#125; 设计链表（JAVA）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109//单链表class LinkedNode &#123; int val; LinkedNode next; LinkedNode()&#123;&#125; LinkedNode(int val) &#123; this.val=val; &#125;&#125;class MyLinkedList &#123; int size; LinkedNode head; public MyLinkedList() &#123; size = 0; head = new LinkedNode(0); &#125; public int get(int index) &#123; if(index&gt;=size)&#123; return -1; &#125; if(index&lt;0)&#123; index=0; &#125; LinkedNode pre=head; for(int i =0;i&lt;=index;i++)&#123; pre=pre.next; &#125; return pre.val; &#125; public void addAtHead(int val) &#123; addAtIndex(0, val); &#125; public void addAtTail(int val) &#123; addAtIndex(size, val); &#125; public void addAtIndex(int index, int val) &#123; if (index &gt; size) &#123; return; &#125; if (index &lt; 0) &#123; index = 0; &#125; size++; LinkedNode pre = head; for (int i = 0; i &lt; index; i++) &#123; pre = pre.next; &#125; LinkedNode toAdd = new LinkedNode(val); toAdd.next = pre.next; pre.next = toAdd; &#125; public void deleteAtIndex(int index) &#123; if (index &gt;= size) &#123; return; &#125; if (index &lt; 0) &#123; index = 0; &#125; size--; LinkedNode pre=head; for(int i=0;i&lt;index;i++)&#123; pre=pre.next; &#125; pre.next=pre.next.next; &#125; public void overTurn() &#123; ListNode prev = null; ListNode cur = head; ListNode temp = null; while (cur != null) &#123; temp = cur.next;//保存下一节点 cur.next = prev;//连接上一节点 prev = cur;//保存当前节点 cur = temp;//切换节点 &#125; head.next= prev; ListNode newnode =head; for(int i=0;i&lt;size;i++)&#123; newnode=newnode.next; &#125; newnode.next=null; &#125; public void reverseList(ListNode Start,ListNode End) &#123; head.next = reverse(Start,End ); &#125; private ListNode reverse(ListNode prev, ListNode cur) &#123; if (cur == null) &#123; return prev; &#125; ListNode temp = null; temp = cur.next;// 先保存下一个节点 cur.next = prev;// 反转 // 更新prev、cur位置 // prev = cur; // cur = temp; return reverse(cur, temp); &#125;&#125; 结构体定义12345678910111213141516171819202122232425262728#define _CRT_SECURE_NO_WARNINGS#include &quot;stdio.h&quot;#include &quot;cstdlib&quot;#define OK 1;#define ERROR -1;#define LIST_INIT_SIZE 100#define LISTINCREMENT 10typedef char ElemType;typedef int Status;typedef struct LNode &#123;//单链表 ElemType data; //数据 struct LNode* next; //下一指针&#125;LNode, * LinkList;typedef struct DuLNode &#123;//双向链表 ElemType data; struct DuLNode* prior; struct DuLNode* next;&#125;DuLNode, * DiLinkList;typedef struct SeqList &#123; int* elem;//线性表首地址 int length;//长度 int listsize = LIST_INIT_SIZE;//当前分配的存储空间&#125;; 表的初始化，不带头节点，内置，顺序123456789101112LinkList CreatSlist()&#123; LinkList head = NULL; for (int i = 5; i &gt;= 1; i--) &#123; LinkList newhead = (LinkList)malloc(sizeof(LNode)); newhead-&gt;data = i; newhead-&gt;next = head; head = newhead; &#125; return head;&#125; 顺序创建，输入，n123456789101112void CreatListno(LinkList&amp; L, int n) &#123; L = (LinkList)malloc(sizeof(LNode)); L-&gt;next = NULL; LinkList nL = L; for (int i = 0; i &lt; n; i++) &#123; LinkList p = (LinkList)malloc(sizeof(LNode)); scanf(&quot;%d&quot;, &amp;p-&gt;data); p-&gt;next = nL-&gt;next; nL-&gt;next = p; nL = p; &#125;&#125; 逆序创建输入单链表,n12345678910void CreateList(LinkList&amp; L, int n) &#123; L = (LinkList)malloc(sizeof(LNode)); L-&gt;next = NULL; for (int i = n; i &gt; 0; i--) &#123; LinkList p = (LinkList)malloc(sizeof(LNode)); scanf(&quot;%d&quot;, &amp; p-&gt;data); p-&gt;next = L-&gt;next; L-&gt;next = p; &#125;&#125; 遍历123456789void travel(LinkList L) &#123; LinkList p = L-&gt;next; if (!p)printf(&quot;空表&quot;); while (p != NULL) &#123; printf(&quot;%c &quot;, p-&gt;data); p = p-&gt;next; &#125; printf(&quot;\\n&quot;);&#125; 打印输出1234567891011void print(LinkList P)&#123; while (P != NULL) &#123; printf(&quot;%d &quot;, P-&gt;data); P = P-&gt;next; &#125; printf(&quot;\\n&quot;); return;&#125; 取第i个结点元素1234567891011Status GetElem(LinkList L,int i,ElemType &amp;e) &#123; LinkList p = L-&gt;next; int j = i; while (p &amp;&amp; j &lt; i) &#123; p = p-&gt;next; ++j; &#125; if (!p || j &gt; i)return ERROR; e = p-&gt;data; return OK;&#125; 在第i个元素之前插入12345678910111213141516Status ListInsert(LinkList &amp;L,int i,ElemType e) &#123; LinkList p = L; int j = i; while (p &amp;&amp; j &lt; i-1) &#123; p = p-&gt;next; ++j; &#125; if (!p || j &lt; i - 1) &#123; return ERROR; &#125; LinkList q = (LinkList)malloc(sizeof(LNode)); q-&gt;data = e; q-&gt;next = p-&gt;next; p-&gt;next = q; return OK;&#125; 删除data值为x的结点123456789101112131415161718192021222324void ListDel_X(LinkList&amp; L, int x) &#123; if (L-&gt;next == NULL) &#123; printf(&quot;空表无法删除\\n&quot;); return; &#125; LinkList p = L-&gt;next, pre_p = L; int flag = 0; while (p) &#123; if (p-&gt;data == x) &#123; pre_p-&gt;next = p-&gt;next; free(p); p = pre_p-&gt;next; //p=p-&gt;next; //pre_p-&gt;next=p; flag = 1; &#125; else &#123; pre_p = p; p = p-&gt;next; &#125; &#125; flag == 1 ? printf(&quot;已删除\\n&quot;) : printf(&quot;无此元素\\n&quot;);&#125; 删除data值为x的直接前驱结点1234567891011121314151617181920212223242526void ListDel_Xpre(LinkList&amp; L, int x) &#123; if (L-&gt;next == NULL) &#123; printf(&quot;空表无法删除\\n&quot;); return; &#125; LinkList p = L-&gt;next, pre_p = L; if (p-&gt;data == x) printf(&quot;首元素无前驱无法执行操作\\n&quot;); p = p-&gt;next; int flag = 0; while (p) &#123; if (p-&gt;data == x) &#123; pre_p-&gt;next = p; p = pre_p-&gt;next-&gt;next; //p=p-&gt;next; //pre_p-&gt;next=p; flag = 1; &#125; else &#123; pre_p = pre_p-&gt;next; p = p-&gt;next; &#125; &#125; flag == 1 ? printf(&quot;已删除直接前驱\\n&quot;) : printf(&quot;无此元素\\n&quot;);&#125; 删除第i个结点1234567891011Status ListDelete(LinkList&amp; L, int i, ElemType e) &#123; LinkList p = L; int j = i; while (p-&gt;next &amp;&amp; j &lt; i - 1) &#123; p = p-&gt;next; ++j; &#125; if (!p-&gt;next || j &gt; i - 1)return ERROR; p-&gt;next = p-&gt;next-&gt;next; return OK; &#125; 删除最小元素结点1234567891011121314151617Status DelMinNode(LinkList&amp; head) &#123; LinkList p = head-&gt;next, pre = head; LinkList minp=NULL, minpre=NULL; ElemType min = p-&gt;data; while (p != NULL) &#123; if (p-&gt;data &lt; pre-&gt;data) &#123; min = p-&gt;data; minp = p; minpre = pre; &#125; pre = p; p = p-&gt;next; &#125; minpre-&gt;next = minp-&gt;next; free(minp); return OK;&#125; 改造单向循环链表12345678Status linklist_cycle(LNode* head) &#123; LNode* p = head; if (!p)return ERROR; while (p-&gt;next != NULL)//时间复杂度为O(n)为链表长度 p = p-&gt;next; p-&gt;next = head; return OK;&#125; 连接循环链表12345678Status merge(LNode *L1,LNode *L2) &#123; LNode* p = L1, * q = L2; while (p-&gt;next != L1)p = p-&gt;next; while (q-&gt;next != L2)q = q-&gt;next; q-&gt;next = L1; p-&gt;next = L2; return OK;&#125; 顺序表逆置最小辅助空间(顺序表)123456789Status Invert_seqList(SeqList &amp;L) &#123; ElemType temp; for (int i = 0; i &lt; L.length / 2; i++) &#123; temp = L.elem[i]; L.elem[i] = L.elem[L.length - i - 1]; L.elem[L.length - i - 1] = temp; &#125; return OK;&#125; 逆置算法(三辅助)1234567891011121314Status invent(LinkList &amp;head)&#123; LinkList p, q, r; if (!head-&gt;next)return ERROR; p = head-&gt;next; q = p-&gt;next; p-&gt;next = NULL; while (q) &#123; r = q; q = q-&gt;next; head-&gt;next = r; r-&gt;next = p; p = r; &#125;&#125; 头插法1234567891011LinkList reserve(LinkList &amp;head) &#123; LinkList temp=NULL, phead=NULL; while (head != NULL) &#123; temp = head; head = head-&gt;next; temp-&gt;next = phead; phead = temp; &#125; return phead;&#125; 就地逆置12345678910111213LinkList reverse_2(LinkList&amp; head) &#123; LinkList p = NULL,q = NULL; p = head; q = head-&gt;next; while (q != NULL) &#123; p-&gt;next = q-&gt;next; q-&gt;next = head; head = q; q = p-&gt;next; &#125; p = NULL; return head;&#125; 判断回文123456789101112131415161718192021222324252627282930313233343536373839404142Status ifPalin()&#123; char c; int flag = 1; LinkList L1,L2; L1 = (LinkList)malloc(sizeof(LNode)); L2 = (LinkList)malloc(sizeof(LNode)); L1-&gt;next = NULL; L2-&gt;next = NULL; LinkList nL1= L1,nL2=L2; LinkList p= (LinkList)malloc(sizeof(LNode)); LinkList q = (LinkList)malloc(sizeof(LNode));while ((c=getchar())!=&#x27;@&#x27;) &#123; //顺序 p = (LinkList)malloc(sizeof(LNode)); p-&gt;data = c; p-&gt;next = nL1-&gt;next; nL1-&gt;next = p; nL1 = p; //逆序 q = (LinkList)malloc(sizeof(LNode)); q-&gt;data = c; q-&gt;next = nL2-&gt;next; nL2-&gt;next = q; &#125; nL1 = L1-&gt;next; nL2 = L2-&gt;next; while (nL1!=NULL) &#123; if (nL1-&gt;data == nL2-&gt;data) &#123; nL1 = nL1-&gt;next; nL2 = nL2-&gt;next; &#125; else &#123; printf(&quot;bu是&quot;); return 0; &#125; &#125; printf(&quot;是&quot;); return 1;&#125; 栈理论底层容器：缺省情况下deque(双向队列)&#x2F;list&#x2F;vector 12std::stack&lt;int, std::vector&lt;int&gt; &gt; third; // 使用vector为底层容器的栈std::queue&lt;int, std::list&lt;int&gt;&gt; third; // 定义以list为底层容器的队列 标准栈操作 push(x) – 将一个元素放入队列的尾部。pop() – 从队列首部移除元素。peek() – 返回队列首部的元素。empty() – 返回队列是否为空。 操作合集(用stackr容器)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Solution &#123;public: struct abb &#123; int data; &#125;abb;private: string s;public: //有效的括号 bool isValid(string s) &#123; if (s.size() % 2 != 0)return false;//为奇数一定不匹配 stack&lt;char&gt; st; cout &lt;&lt; st.empty(); for (int i = 0; i &lt; s.size(); i++) &#123; if (s[i] == &#x27;(&#x27;)st.push(&#x27;)&#x27;); else if (s[i] == &#x27;&#123;&#x27;)st.push(&#x27;&#125;&#x27;); else if (s[i] == &#x27;[&#x27;)st.push(&#x27;]&#x27;); else if (st.empty() || st.top() != s[i])return false; else st.pop(); &#125; return st.empty(); &#125; //删除字符串中的所有相邻重复项 string removeDuplicates(string S) &#123; stack&lt;char&gt; st; for (char s : S) &#123; if (st.empty() || s != st.top()) &#123; st.push(s); &#125; else &#123; st.pop(); &#125; &#125; string result = &quot;&quot;; while (!st.empty()) &#123; result += st.top(); st.pop(); &#125; reverse(result.begin(), result.end()); return result; &#125; //逆波兰表达式求值 int evalRPN(vector&lt;string&gt; &amp;s) &#123; stack&lt;int&gt; st; for (int i = 0; i &lt; s.size(); i++) &#123; int num1 = st.top(); st.pop(); int num2 = st.top(); st.pop(); if (s[i] == &quot;+&quot; || s[i] == &quot;-&quot; || s[i] == &quot;*&quot; || s[i] == &quot;/&quot;) &#123; if (s[i] == &quot;+&quot;)st.push(num1 + num2); if (s[i] == &quot;-&quot;)st.push(num1 - num2); if (s[i] == &quot;*&quot;)st.push(num1 * num2); if (s[i] ==&quot;/&quot;)st.push(num1 / num2); &#125; else &#123; st.push(stoi(s[i])); &#125; &#125; int result = st.top(); st.pop(); return result; &#125;&#125;; 操作合集（自定义结构体）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;cstdlib&gt;//malloc#define OK 1#define ERROR -1#define STACK_INIT_SIZE 100 //初始分配空间#define STACKINCREMENT 10 //分配增量typedef int ElemType;typedef int Status;//栈的链式实现typedef struct SNode&#123; ElemType data; struct SNode* next;&#125;SNode,*StackPtr;typedef struct &#123; StackPtr top;//栈顶指针 int count; //元素数&#125;LinkStack;Status InitStackLink(LinkStack &amp;S) &#123; S.top = NULL; S.count = 0; return OK;&#125;Status GetTopLink(LinkStack S,ElemType &amp;e) &#123; printf(&quot;COUNT:%d\\n&quot;,S.count); if (S.count == 0)return ERROR; e = S.top-&gt;data; printf(&quot;gettop:%d&quot;,e); return OK;&#125;Status PopLink(LinkStack &amp;S,ElemType &amp;e) &#123; if (S.count == 0)return ERROR; e = S.top-&gt;data; S.top = S.top-&gt;next; S.count--; return OK;&#125;Status PushLink(LinkStack&amp; S, ElemType e) &#123; SNode* p = (StackPtr)malloc(sizeof(SNode)); if (!p)printf(&quot;ERROR\\n&quot;); p-&gt;data = e; p-&gt;next = S.top; S.top = p; printf(&quot;push:%d\\n&quot;,S.top-&gt;data); S.count++; return OK;&#125;//栈的顺序实现typedef struct &#123; ElemType* base;//存储空间基址 ElemType* top;//栈顶指针 int StackSize;//已分配空间&#125;SqStack;//初始化操作Status InitStack(SqStack &amp;S) &#123; S.base = (ElemType*)malloc(STACK_INIT_SIZE*sizeof(ElemType)); if (!S.base) &#123; exit(OVERFLOW); &#125; S.top = S.base; S.StackSize = STACK_INIT_SIZE; return OK;&#125;//取栈顶元素Status GetTop(SqStack S) &#123; if (S.top == S.base)return ERROR; return *(S.top-1);&#125;//进栈Status Push(SqStack&amp; S, ElemType e) &#123; if (S.top - S.base &gt;= S.StackSize) &#123; S.base = (ElemType*)realloc(S.base, S.StackSize+STACKINCREMENT * sizeof(ElemType)); if (!S.base)exit(OVERFLOW); S.top = S.base + S.StackSize; S.StackSize += STACKINCREMENT; &#125; *(S.top++) = e; return OK;&#125;//出栈Status Pop(SqStack&amp; S, ElemType&amp; e) &#123; if (S.top == S.base)return ERROR; e = *(--S.top); return OK;&#125;//判断栈空bool StackEmpty(SqStack S) &#123; if (S.base == S.top)return true; else &#123; return false; &#125;&#125;//进制转换 不断取模入栈，num=num/nvoid conversion(int num,int n,ElemType &amp;e) &#123; ElemType temp; SqStack S; int flag = 1; while (num) &#123; Push(S, num % n); num = num / n; &#125; while (!StackEmpty(S)) &#123; Pop(S, temp); if (flag)flag = 0; else &#123; e = temp * 10 + temp; &#125; printf(&quot;&amp;d&quot;, temp); &#125; printf(&quot;\\n&quot;); printf(&quot;%d&quot;, e);&#125;//判断是否为运算符，是运算符返回1，若不是返回0int In(char c) &#123; switch (c) &#123; case &#x27;+&#x27;: case &#x27;-&#x27;: case &#x27;*&#x27;: case &#x27;/&#x27;: case &#x27;(&#x27;: case &#x27;)&#x27;: case &#x27;=&#x27;: return 1; default: return 0; &#125;&#125;//判断是否为数，是运算符返回1，若不是返回0int InNum(char c)&#123; if (c &gt;= 48 &amp;&amp; c &lt;= 57)return 1; else &#123; return 0; &#125;&#125;//比较优先级char Precede(char operate1, char operate2)&#123; int i, j; char pre[7][7] = &#123;// + - * / ( ) = &#123;&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;&#125;, &#123;&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;&#125;, &#123;&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&lt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;&#125;, &#123;&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&lt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;&#125;, &#123;&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;=&#x27;,&#x27;0&#x27;&#125;, &#123;&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;0&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;&#125;, &#123;&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;0&#x27;,&#x27;=&#x27;&#125; &#125;; switch (operate1) &#123; case &#x27;+&#x27;: i = 0; break; case &#x27;-&#x27;: i = 1; break; case &#x27;*&#x27;: i = 2; break; case &#x27;/&#x27;: i = 3; break; case &#x27;(&#x27;: i = 4; break; case &#x27;)&#x27;: i = 5; break; case &#x27;=&#x27;: i = 6; break; &#125; switch (operate2) &#123; case &#x27;+&#x27;: j = 0; break; case &#x27;-&#x27;: j = 1; break; case &#x27;*&#x27;: j = 2; break; case &#x27;/&#x27;: j = 3; break; case &#x27;(&#x27;: j = 4; break; case &#x27;)&#x27;: j = 5; break; case &#x27;=&#x27;: j = 6; break; &#125; return(pre[i][j]);&#125;//操作int Operate(int a, char operate, int b)&#123; int result; switch (operate) &#123; case&#x27;+&#x27;:return a + b; case&#x27;-&#x27;:return a - b; case&#x27;*&#x27;:return a * b; case&#x27;/&#x27;: //判断除数是否为0，若除数为零返回错误提示 if (b != 0) return a / b; else &#123; printf(&quot;0不能作为被除数!\\n&quot;); exit(1); &#125; &#125;&#125;//数学表达式求值ElemType EvaluateExpressione(char content[]) &#123; SqStack OPTR;//运算符栈 SqStack OPND;//运算数栈； InitStack(OPTR); InitStack(OPND); Push(OPTR, &#x27;=&#x27;); int temp; int e;//存放pop操作符 int a,b;//pop操作数 int x, y;//存放数 char ch;//读取内容字符 int i = 0;//表达式数组下标 ch = content[i]; while (ch != &#x27;=&#x27; || GetTop(OPTR) != &#x27;=&#x27;) &#123; if (InNum(ch)) &#123;//是操作数 x = ch - &#x27;0&#x27;; Push(OPND, x); y = x; ch = content[++i];//读取下一位字符并将指针向后偏移一位 while (InNum(ch)) &#123; x = ch - &#x27;0&#x27;; y = 10 * y + x; Pop(OPND, a); Push(OPND, y); ch = content[++i];//读取下一位字符并将指针向后偏移一位 &#125; &#125; else if(In(ch)) &#123;//操作符 switch (Precede(GetTop(OPTR), ch))//比较ch的与OPTR栈顶元素的优先级 &#123; case&#x27;&lt;&#x27;: Push(OPTR, ch); ch = content[++i]; //读取下一位字符并将指针向后偏移一位 break; case&#x27;&gt;&#x27;: Pop(OPTR, e); Pop(OPND, a); Pop(OPND, b); Push(OPND, Operate(b,e,a)); break; case&#x27;=&#x27;: Pop(OPTR,temp); ch =content[++i]; //读取下一位字符并将指针向后偏移一位 break; &#125; &#125; else &#123; printf(&quot;输入包含无效字符！&quot;); exit(1); &#125; &#125; return GetTop(OPND);&#125;//数学表达式求值ElemType EvaluateExpressione2( ) &#123; SqStack OPTR;//运算符栈 SqStack OPND;//运算数栈； InitStack(OPTR); InitStack(OPND); Push(OPTR, &#x27;=&#x27;); int a, b, e,x; char ch = getchar(); while (ch != &#x27;=&#x27; || GetTop(OPTR) != &#x27;=&#x27;) &#123; if (!In(ch)) &#123;//是操作数 Push(OPND,ch); printf(&quot;操作数&quot;); ch = getchar(); &#125; else &#123;//操作符 switch (Precede(GetTop(OPTR), ch))//比较ch的与OPTR栈顶元素的优先级 &#123; case&#x27;&lt;&#x27;: Push(OPTR, ch); ch = getchar(); break; case&#x27;&gt;&#x27;: Pop(OPTR, e); Pop(OPND, a); Pop(OPND, b); Push(OPND, Operate(b, e, a)); break; case&#x27;=&#x27;: Pop(OPTR, x); ch = getchar(); break; &#125; &#125; &#125; return GetTop(OPND);&#125;Status main() &#123; char content[100]; //定义一个字符数组用于存储表达式 int result; int i = 0; do &#123; i = 0; printf(&quot;请输入表达且以=结束:\\n&quot;); do &#123; content[i++] = getchar(); &#125; while (content[i - 1] != &#x27;=&#x27;); result = EvaluateExpressione(content); printf(&quot;%d\\n&quot;, result); getchar(); printf(&quot;请按回车以继续，若结束请输入！&quot;); &#125; while (getchar() != &#x27;!&#x27;); return 0;&#125; Pair数据类型1.1 pair类型概述 pair的功能就像它的名字一样，pair将一对值组合成一个值，这一对值可以具有不同的数据类型，两个值可以分别用pair的两个公有函数first和second访问。 pair类所在的头文件与命名函数是： 1#include &lt;utility&gt; 1.2 pair对象基本定义 pair是一种模板类型，其中包含两个数据值，两个数据的类型可以不同，基本的定义如下： 1pair&lt;int, string&gt; a; 表示a中有两个类型，第一个元素是int型的，第二个元素是string类型的，如果创建pair的时候没有对其进行初始化，则调用默认构造函数对其初始化。 1pair&lt;string, string&gt; a(&quot;James&quot;, &quot;Joy&quot;); 也可以像上面一样在定义的时候直接对其初始化。 由于pair类型的使用比较繁琐，因为如果要定义多个形同的pair类型的时候，可以时候typedef简化声明： 123typedef pair&lt;string, string&gt; author;author pro(&quot;May&quot;, &quot;Lily&quot;);author joye(&quot;James&quot;, &quot;Joyce&quot;); 1.3 pair对象访问 对于pair类，由于它只有两个元素，分别名为first和second，因此直接使用普通的点操作符即可访问其成员 123pair&lt;string, string&gt; a(&quot;Lily&quot;, &quot;Poly&quot;); string name;name = pair.second; 1.4 生成新的pair对象 可以使用make_pair对已存在的两个数据构造一个新的pair类型： 123456int a = 8;string m = &quot;James&quot;;pair&lt;int, string&gt; newone;newone = make_pair(a, m)； 队列操作合集1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class Myqueue &#123; //实现单调队列（从大到小）滑动窗口最大值public: deque&lt;int&gt; que; //弹出前检查是否为空且弹出元素是否为front元素 void pop(int value) &#123; if (!que.empty() &amp;&amp; value == que.front()) &#123; que.pop_front(); 7h77777777777777777777777777 &#125; void push(int value) &#123; while (!que.empty() &amp;&amp; value &gt; que.back()) &#123; que.pop_back(); &#125; que.push_back(value); &#125; int front() &#123; return que.front(); &#125; vector&lt;int&gt; maxSlidingwindow(vector&lt;int&gt;&amp; nums, int k) &#123; Myqueue que; vector&lt;int&gt; result; for (int i = 0; i &lt; k; i++) &#123; que.push(nums[i]); &#125; result.push_back(que.front()); for (int i = k; i &lt; nums.size(); i++) &#123; que.pop(nums[i - k]); que.push(nums[i]); result.push_back(que.front()); &#125; return result; &#125;&#125;; class priqueue &#123;//前k个高频元素（优先级队列）public: // 小顶堆 class mycomparison &#123; public: bool operator()(const pair&lt;int, int&gt;&amp; lhs, const pair&lt;int, int&gt;&amp; rhs) &#123; return lhs.second &gt; rhs.second; &#125; &#125;; vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123; // 要统计元素出现频率 unordered_map&lt;int, int&gt; map; // map&lt;nums[i],对应出现的次数&gt; for (int i = 0; i &lt; nums.size(); i++) &#123; map[nums[i]]++; &#125; // 对频率排序 // 定义一个小顶堆，大小为k priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, mycomparison&gt; pri_que; // 用固定大小为k的小顶堆，扫面所有频率的数值 for (unordered_map&lt;int, int&gt;::iterator it = map.begin(); it != map.end(); it++) &#123; pri_que.push(*it); if (pri_que.size() &gt; k) &#123; // 如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k pri_que.pop(); &#125; &#125; // 找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒序来输出到数组 vector&lt;int&gt; result(k); for (int i = k - 1; i &gt;= 0; i--) &#123; result[i] = pri_que.top().first; pri_que.pop(); &#125; return result; &#125;&#125;; 函数列举滑动窗口最大值12345678910111213141516171819202122232425262728293031323334class Myqueue &#123; //实现单调队列（从大到小）滑动窗口最大值public: deque&lt;int&gt; que; //弹出前检查是否为空且弹出元素是否为front元素 void pop(int value) &#123; if (!que.empty() &amp;&amp; value == que.front()) &#123; que.pop_front(); 7h77777777777777777777777777 &#125; void push(int value) &#123; while (!que.empty() &amp;&amp; value &gt; que.back()) &#123; que.pop_back(); &#125; que.push_back(value); &#125; int front() &#123; return que.front(); &#125; vector&lt;int&gt; maxSlidingwindow(vector&lt;int&gt;&amp; nums, int k) &#123; Myqueue que; vector&lt;int&gt; result; for (int i = 0; i &lt; k; i++) &#123; que.push(nums[i]); &#125; result.push_back(que.front()); for (int i = k; i &lt; nums.size(); i++) &#123; que.pop(nums[i - k]); que.push(nums[i]); result.push_back(que.front()); &#125; return result; &#125;&#125;; 前k个高频元素（优先级队列）123456789101112131415161718192021222324252627282930313233343536373839class priqueue &#123;public: // 小顶堆 class mycomparison &#123; public: bool operator()(const pair&lt;int, int&gt;&amp; lhs, const pair&lt;int, int&gt;&amp; rhs) &#123; return lhs.second &gt; rhs.second; &#125; &#125;; vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123; // 要统计元素出现频率 unordered_map&lt;int, int&gt; map; // map&lt;nums[i],对应出现的次数&gt; for (int i = 0; i &lt; nums.size(); i++) &#123; map[nums[i]]++; &#125; // 对频率排序 // 定义一个小顶堆，大小为k priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, mycomparison&gt; pri_que; // 用固定大小为k的小顶堆，扫面所有频率的数值 for (unordered_map&lt;int, int&gt;::iterator it = map.begin(); it != map.end(); it++) &#123; pri_que.push(*it); if (pri_que.size() &gt; k) &#123; // 如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k pri_que.pop(); &#125; &#125; // 找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒序来输出到数组 vector&lt;int&gt; result(k); for (int i = k - 1; i &gt;= 0; i--) &#123; result[i] = pri_que.top().first; pri_que.pop(); &#125; return result; &#125;&#125;; 树任务点 二叉树 二叉搜索树 avl树 红黑树 二叉搜索树、avl树、红黑树csdn树的定义和基本术语 树的定义：n（n≥0）个结点的有限集。在任一棵非空树中： 有且仅有一个特定称为根的结点 n>1时,其余结点可分为m(m>0)个互不相交的有限集T1,T2,…,Tm，Ti称为树的子树。 树的性质： 递归性 层次性 树的基本术语： 树的结点：数据元素及若干指向其子树的分支 结点的度：结点拥有的子树的个数 树的度：树中所以结点的度的最大值 叶子结点（终端结点）：树中所以结点的度的最大值 分支结点（非终端结点）：度大于0的结点 孩子：结点的子树的根 双亲：B是A的孩子，则A是B的双亲 兄弟：同一双亲的孩子互称兄弟 堂兄弟：双亲在同一层的结点 祖先：从根到该节点所经分支上的所有结点 子孙：以某结点为根的子树中的任一结点都是该结点的子孙 结点的层次：从根结点算起，根为第一层，它的孩子为第二层... 树的深度：树中结点的最大层次树数 路径的长：从结点n1到nk的路径的长为路径上的边的条数 深度：对任意结点ni,ni的深度为从根到ni的唯一路径的长 高：从ni到一片树叶的最长路径的长 有序树：树中结点的各子树从左到右有次序（不能互换） 无序树：树中结点的各子树从左到右无次序（能互换） 森林：m(m>=0)棵互不相交的树的集合 ​ 二叉树的性质 在二叉树的第i层上至多有2^(i-1)^个结点 深度为K的二叉树至多有2^K^-1个结点 任意一棵二叉树，终端结点数为n0,度为2的结点数为n2,则n0=n2+1 任意一课树，结点总数N，分支总数B，则N=B+1=n0+n1+n2.... 有n个结点的完全二叉树的深度为[log~2~^n^]+1(下取整) 按层序遍历二叉树有 若i=1，无双亲；若i>1，其双亲是[i/2](下取整) 若2i>n,为叶子结点；否则，其左孩子为2i 若2i+1>n,无右孩子；否则，其右孩子为2i+1 二叉树的种类满二叉树满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。 完全二叉树在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^(h-1)^ 个节点。优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。 二叉搜索树二叉搜索树是一个有序树。 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树 平衡二叉搜索树平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树 二叉树算法二叉树结点实现（存储结构）顺序存储123#define MAX_TREE_SIZE 100typedef TElemType SqBTree[MAX_TREE_SIZE];SqBTree bt; 缺点：浪费空间，始于满&#x2F;完全二叉树（要把空结点也表示出来） 链式存储二叉 含有n个结点的二叉链表有n+1个空链域 c 1234typedef struct BiTNode&#123; ElemType val; struct BiTNode *lchild,*rchild;&#125;BiTNode,*BiTree; c++ 123456struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#125;; java 123456789101112public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode() &#123;&#125; TreeNode(int val) &#123; this.val = val; &#125; TreeNode(int val, TreeNode left, TreeNode right) &#123; this.val = val; this.left = left; this.right = right; &#125;&#125; 三叉 c 1234typedef struct ThiTNode&#123; TElemType val; struct ThiTNode *lchild,*rchild,*parent;&#125;ThiTNode,*ThiTree; 遍历二叉树遍历方式 二叉树主要有两种遍历方式： 深度优先遍历：先往深走，遇到叶子节点再往回走。 广度优先遍历：一层一层的去遍历。 深度优先遍历 前序遍历（递归法，迭代法） 中序遍历（递归法，迭代法） 后序遍历（递归法，迭代法） 广度优先遍历 层次遍历（迭代法） 前中后指中间结点的遍历顺序 前序遍历：中左右 中序遍历：左中右 后序遍历：左右中 实例 算法实现递归遍历 确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。 确定终止条件： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。 确定单层递归的逻辑： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。 c++ 123456789101112131415161718192021void PreTravesal(TreeNode* cur,vector&lt;int&gt;&amp; result)&#123; if(cur==NULL) return;//终止条件 result.push(cur-&gt;val); PreTravesal(cur-&gt;lchild,result);//左孩子 PreTravesal(cur-&gt;rchild,result);//右孩子&#125;void InTravesal(TreeNode* cur,vector&lt;int&gt;&amp; result)&#123; if(cur==NULL) return;//终止条件 PreTravesal(cur-&gt;lchild,result);//左孩子 result.push(cur-&gt;val); PreTravesal(cur-&gt;rchild,result);//右孩子&#125;void PostTravesal(TreeNode* cur,vector&lt;int&gt;&amp; result)&#123; if(cur==NULL) return;//终止条件 PreTravesal(cur-&gt;lchild,result);//左孩子 PreTravesal(cur-&gt;rchild,result);//右孩子 result.push(cur-&gt;val);&#125; c 12345678910111213141516171819202122232425262728293031323334353637383940Status PreTraversal(BiTree T,Status(* Visit)(TElemType e)) &#123; if (T) &#123; if (Visit(T-&gt;data)) if (PreTraversal(T-&gt;lchild, Visit)) if (PreTraversal(T-&gt;rchild, Visit)) return OK; return ERROR;//防止Visit()返回0 &#125; else &#123; return OK; &#125; return OK;&#125;Status InTraversal(BiTree T, Status(*Visit)(TElemType e)) &#123; if (T) &#123; if (InTraversal(T-&gt;lchild, Visit)) if (Visit(T-&gt;data)) if (InTraversal(T-&gt;rchild, Visit)) return OK; return ERROR;//防止Visit()返回0 &#125; else &#123; return OK; &#125; return OK;&#125;Status PostTraversal(BiTree T, Status(*Visit)(TElemType e)) &#123; if (T) &#123; if (PostTraversal(T-&gt;lchild, Visit)) if (PostTraversal(T-&gt;rchild, Visit)) if (Visit(T-&gt;data)) return OK; return ERROR;//防止Visit()返回0 &#125; else &#123; return OK; &#125; return OK;&#125; 迭代遍历 迭代遍历（非统一） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; stack&lt;TreeNode*&gt; st; vector&lt;int&gt; result; if (root == NULL) return result; st.push(root); while (!st.empty()) &#123; TreeNode* node = st.top(); // 中 st.pop(); result.push_back(node-&gt;val); if (node-&gt;right) st.push(node-&gt;right); // 右（空节点不入栈） if (node-&gt;left) st.push(node-&gt;left); // 左（空节点不入栈） &#125; return result; &#125; vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; result; stack&lt;TreeNode*&gt; st; TreeNode* cur = root; while (cur != NULL || !st.empty()) &#123; if (cur != NULL) &#123; // 指针来访问节点，访问到最底层 st.push(cur); // 将访问的节点放进栈 cur = cur-&gt;left; // 左 &#125; else &#123; cur = st.top(); // 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据） st.pop(); result.push_back(cur-&gt;val); // 中 cur = cur-&gt;right; // 右 &#125; &#125; return result; &#125; vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; stack&lt;TreeNode*&gt; st; vector&lt;int&gt; result; if (root == NULL) return result; st.push(root); while (!st.empty()) &#123; TreeNode* node = st.top(); st.pop(); result.push_back(node-&gt;val); if (node-&gt;left) st.push(node-&gt;left); // 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈） if (node-&gt;right) st.push(node-&gt;right); // 空节点不入栈 &#125; reverse(result.begin(), result.end()); // 将结果反转之后就是左右中的顺序了 return result; &#125; 迭代遍历（统一） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970vector&lt;int&gt; preorderTraversalT(TreeNode* root) &#123; vector&lt;int&gt; result; stack&lt;TreeNode*&gt; st; if (root != NULL) st.push(root); while (!st.empty()) &#123; TreeNode* node = st.top(); if (node != NULL) &#123; st.pop(); if (node-&gt;right) st.push(node-&gt;right); // 右 if (node-&gt;left) st.push(node-&gt;left); // 左 st.push(node); // 中 st.push(NULL); &#125; else &#123; st.pop(); node = st.top(); st.pop(); result.push_back(node-&gt;val); &#125; &#125; return result; &#125; vector&lt;int&gt; inorderTraversalT(TreeNode* root) &#123; vector&lt;int&gt; result; stack&lt;TreeNode*&gt; st; if (root != NULL) st.push(root); while (!st.empty()) &#123; TreeNode* node = st.top(); if (node != NULL) &#123; st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中 if (node-&gt;right) st.push(node-&gt;right); // 添加右节点（空节点不入栈） st.push(node); // 添加中节点 st.push(NULL); // 中节点访问过，但是还没有处理，加入空节点做为标记。 if (node-&gt;left) st.push(node-&gt;left); // 添加左节点（空节点不入栈） &#125; else &#123; // 只有遇到空节点的时候，才将下一个节点放进结果集 st.pop(); // 将空节点弹出 node = st.top(); // 重新取出栈中元素 st.pop(); result.push_back(node-&gt;val); // 加入到结果集 &#125; &#125; return result; &#125; vector&lt;int&gt; postorderTraversalT(TreeNode* root) &#123; vector&lt;int&gt; result; stack&lt;TreeNode*&gt; st; if (root != NULL) st.push(root); while (!st.empty()) &#123; TreeNode* node = st.top(); if (node != NULL) &#123; st.pop(); st.push(node); // 中 st.push(NULL); if (node-&gt;right) st.push(node-&gt;right); // 右 if (node-&gt;left) st.push(node-&gt;left); // 左 &#125; else &#123; st.pop(); node = st.top(); st.pop(); result.push_back(node-&gt;val); &#125; &#125; return result; &#125; 层序遍历12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; queue&lt;TreeNode*&gt; que; if (root != NULL) que.push(root); vector&lt;vector&lt;int&gt;&gt; result; while (!que.empty()) &#123; int size = que.size(); vector&lt;int&gt; vec; // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的 for (int i = 0; i &lt; size; i++) &#123; TreeNode* node = que.front(); que.pop(); vec.push_back(node-&gt;val); if (node-&gt;left) que.push(node-&gt;left); if (node-&gt;right) que.push(node-&gt;right); &#125; result.push_back(vec); &#125; return result; &#125;&#125;;# 递归法class Solution &#123;public: void order(TreeNode* cur, vector&lt;vector&lt;int&gt;&gt;&amp; result, int depth) &#123; if (cur == nullptr) return; if (result.size() == depth) result.push_back(vector&lt;int&gt;()); result[depth].push_back(cur-&gt;val); order(cur-&gt;left, result, depth + 1); order(cur-&gt;right, result, depth + 1); &#125; vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; result; int depth = 0; order(root, result, depth); return result; &#125;&#125;; 创建二叉树12345678910111213//先序Status PreCreateBiTree(BiTree &amp;T)&#123; char ch; scanf(&quot;%c&quot;,&amp;ch); if(ch==&#x27;&#x27;)T=NULL; else&#123; if(!(T=(BiTnode*)malloc(sizeof(TNode)))) exit(OVERFLOW); T-&gt;data=ch;//中 PreCreateBiTree(T-&gt;lchild);//左 PreCreateBiTree(T-&gt;rchild);//右 &#125; return OK;&#125; 翻转二叉树123456789101112void invertTree(TreeNode* root)&#123; if(root==NULL) return; swap(root-&gt;lchild,root-&gt;rchild); invertTree(root-&gt;lchild); invertTree(root-&gt;rchild);&#125;void swap(TreeNode* lchild,TreeNode* rchild)&#123; TreeNode* temp; temp=lchild; lchild=rchild; rchild=temp;&#125; 对称二叉树1234567891011121314151617181920bool compare(TreeNode* L,TreeNode* R)&#123; //都空 if(L==NULL&amp;&amp;R==NULL) return true; //左空右不空 else if(L==NULL&amp;&amp;R!=NULL) return false; //右空左不空 else if(R==NULL&amp;&amp;L!=NULL) return false; //左右不空且不等 else if(L!=R) return false; //接下来就是左右都有值且相等 bool l=compare(L-&gt;lchild,R-&gt;rchild);//左子树：左 ；右子树：右 bool r=compare(L-&gt;rchild,R-&gt;lchild);//左子树：右 ；右子树：左 bool isSame=l&amp;&amp;r; //中 return isSame；&#125;bool isduic(TreeNode* root)&#123; if(root==NULL) return true; return compare(root-&gt;lchild,root-&gt;rchild);&#125; 统计叶子结点个数1234567Status CountLeaf(BiTree T,int&amp; count)&#123; if(T)&#123; if((T-&gt;lchild==NULL)&amp;&amp;(T-&gt;rchild==NULL))&#123;count++;return OK;&#125; CountLeaf(T-&gt;lchild,count); //访问左 CountLeaf(T-&gt;rchild,count); //访问右 &#125;else return ERROR;&#125; 求二叉树的深度1234567891011int Depth(BiTree T)&#123; int d=0,dl=0,dr=0; if(!T) d=0; else&#123; dl=Depth(T-&gt;lchild); dr=Depth(T-&gt;rchild); d=1+max(dl,dr); &#125; return d;&#125; 求二叉树的最小深度12345678910111213141516int getDepth(TreeNode* node) &#123; if (node == NULL) return 0; int leftDepth = getDepth(node-&gt;left); // 左 int rightDepth = getDepth(node-&gt;right); // 右 // 中 // 当一个左子树为空，右不为空，这时并不是最低点 if (node-&gt;left == NULL &amp;&amp; node-&gt;right != NULL) &#123; return 1 + rightDepth; &#125; // 当一个右子树为空，左不为空，这时并不是最低点 if (node-&gt;left != NULL &amp;&amp; node-&gt;right == NULL) &#123; return 1 + leftDepth; &#125; int result = 1 + min(leftDepth, rightDepth); return result;&#125; 求完全二叉树结点个数普通二叉树逻辑，按后序遍历 12345678910int getNodesNum(TreeNode* T)&#123; int n,ln,rn; if(!T) return 0; else&#123; ln=getNodesNum(T-&gt;lchild); rn=getNodesNum(T-&gt;rchild); n=ln+rn+1; return n; &#125;&#125; 12345678int getNodesNum(TreeNode* T,int &amp;count)&#123; if(T)&#123; count++; getNodesNum(T-&gt;lchild,count); getNodesNum(R-&gt;lchild,count); &#125;&#125; 完全二叉树逻辑，求每个子树的满二叉树 123456789101112131415161718int getNodesNum(TreeNode*T)&#123; if(!T)return 0; int ldeep=0,rdeep=0; TreeNode* lt=T-&gt;lchild; TreeNode* rt=T-&gt;rchild; while(lt)&#123; lt=lt-&gt;lchild; ldeep++; &#125; while(rt)&#123; rt=rt-&gt;rchild; rdeep++; &#125; if(ldeep==rdeep)&#123; return (2&lt;&lt;ldeep)-1; &#125; return getNodesNum(T-&gt;lchild)+getNodesNum(T-&gt;rchild)+1;&#125; 判断平衡二叉树123456789101112int getHeight(TreeNode* T)&#123; if(!T)return 0; int leftHeight=getHeight(T-&gt;lchild); if(leftHeight==-1)return -1; int rightHeight=getHeight(T-&gt;rchild); if(rightHeight==-1)return -1; return abs(leftHeight-rightHeight)&gt;1?-1: 1+max(leftHeight,rightHeight);&#125;Boolean ifph(TreeNode* T)&#123; return getHeight(T)==-1?false : true;&#125; 求根节点到叶子节点的所有路径1234567891011121314151617181920212223242526272829303132class Solution&#123; private: void traversal(TreeNode* T,vector&lt;int&gt;&amp; path,vector&lt;string&gt;&amp; result)&#123; path.push_back(T-&gt;val); if(T-&gt;lchild==NULL&amp;&amp;T-&gt;rchild==NULL)&#123; string spath; for(int i=0;i&lt;path.size()-1;i++)&#123; spath=path[i].toString(); spath+=&quot;-&gt;&quot;; &#125; spath+=path[path.szie()-1]; reslut.push_back(spath); return; &#125; if(T-&gt;lchild)&#123; Traversal(T-&gt;lchild,path,reslut); path.pop_back(); &#125; if(T-&gt;rchild)&#123; Traversal(T-&gt;rchild,path,reslut); path.pop_back(); &#125; &#125; public: vector&lt;string&gt; binaryTreePaths(TreeNode* T)&#123; vector&lt;string&gt; result; vector&lt;int&gt; path; if(T==NULL)return result; traversal(T,path,result); return result; &#125;&#125; 左叶子之和123456789101112131415161718192021222324252627282930313233class Solution&#123; int leftCount(TreeNod *T)&#123; if(!T)return 0; int left=0; if(T-&gt;left&amp;&amp;!T-&gt;left-&gt;left&amp;&amp;!T-&gt;right-&gt;right)&#123;//是左叶子 int left= T-&gt;left-&gt;val; &#125;else if(T-&gt;left)&#123; int left= leftCount(T-&gt;left); &#125; int right= leftCount(T-&gt;right); return left+right; &#125;&#125;class Solution &#123;public: int sumOfLeftLeaves(TreeNode* root) &#123; if (root == NULL) return 0; if (root-&gt;left == NULL &amp;&amp; root-&gt;right== NULL) return 0; int leftValue = sumOfLeftLeaves(root-&gt;left); // 左 if (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) &#123; // 左子树就是一个左叶子的情况 leftValue = root-&gt;left-&gt;val; &#125; int rightValue = sumOfLeftLeaves(root-&gt;right); // 右 int sum = leftValue + rightValue; // 中 return sum; &#125;&#125;; 求树最左边的值递归法 1234567891011121314151617181920212223242526class Solution&#123; public: int maxDepth=INT_MIN; int result; void travesal(TreeNode* T,int depth)&#123; if(T-&gt;left==NULL&amp;&amp;T-&gt;right==NULL)&#123; if(depth&gt;maxDepth)&#123; result=T-&gt;val; maxDepth=depth; &#125; return; &#125; if(T-&gt;left)&#123; travesal(T-&gt;left,depth+1);//隐藏回溯 &#125; if(T-&gt;left)&#123; travesal(T-&gt;left,depth+1);//隐藏回溯 &#125; return; &#125; int findBottomLeftValue(TreeNode* T)&#123; travesal(T,0); return result; &#125;&#125; 迭代层序遍历 12345678910111213141516171819class Solution&#123; public: int findBottomLeftValue(TreeNode* T)&#123; queue&lt;TreeNode*&gt;que; for(roo!=NULL)que.push(T); int reuslt=0; while(!qy=ue.empty())&#123; int size=que,size(); for(int i=0;i&gt;size;i++)&#123; TreeNode* node=que.front(); que.pop(); if(i==0)result=node-&gt;val; if(node-&gt;left)que.push(node-&gt;left); if(node-&gt;right)que.push(node-&gt;right); &#125; &#125; return result; &#125;&#125; AVL树AVL定义AVL树是带有平衡条件的二叉查找树，即每一个结点的左右子树的高度最多差1的二叉查找树（空树高定义为-1） AVL具体算法结点声明12345678struct AvlNode&#123; ElemType element; AvlNode *left; AvlNode *right; int height; AvlNode(const ElemType &amp;element,AvlNode *lt,AvlNode *rt,int h=0):element(element),left(lt),right(rt),height(h)&#125;; 返回结点高度1234int height(AvlNode *t)const&#123; return t==NULL ? -1:t-&gt;height;&#125; 单旋转123void rotateWithLeftChild(AvlNode *k2)&#123; &#125; 图图的定义和术语图G是由一个顶点集V和一个边集E构成的数据结构。 记为二元组形式： G= (V, E) 其中: V是由顶点构成的非空有限集合， 记为：V＝&#123;V0, V1, V2, …Vn-1&#125; E是由V中顶点的对偶构成的有限集合， 记为：E=&#123;(V0, V2), (V3, V4), … &#125;，若E为空，则图中只有顶 点而没有边。 有向图 弧、弧尾或初始点、弧头或终端点 无向图的定义和术语 子图: G =(V, E)，G’= (V’, E’)，若V’ V，E’ E，G’是G的子图 邻接点: 如果边(v, v’)∈E，v和v’互为邻接点 依附（相关联): 边(v，v’)依附于顶点v和v’。 顶点v的度: 和v相关联的边的数目。记为TD(v) 有向图的定义和术语 邻接到：弧&lt;v,v’&gt; ∈E，称v邻接到v’，v’邻接自v 顶点v的入度：以顶点v为头的弧的数目，记为ID（v） 顶点v的出度：以顶点v为尾的弧的数目，记为OD（v） 顶点v的度：TD(v)= ID(v)+ OD(v) 一个有n个顶点和e条边或弧的图，满足：e=sum(TD(v))/2 路径、回路和路径长度 在无向图G中，若存在一个顶点序列(Vp , Vi1 , Vi2 , … , Vin , Vq)， 使(Vp, Vi1)，(Vi1, Vi2)，…，(Vin, Vq)均为图G的边，则该称顶点 的序列为顶点Vp到顶点Vq的路径。若G是有向图，则路径是有向 的。 路径长度定义为路径上的边数或者弧的数目。 若一条路径中不出现重复顶点，则称此路径为简单路径。 若一条路径的起点和终点相同（Vp=Vq）称为回路或环。 除了起点和终点相同外，其余顶点不相同的回路，称为简单回 路或简单环。 无向图的连通性 连通：顶点v至v’ 之间有路径存在。 连通图：无向图 G 的任意两点之间都连通。 连通分量：无向图的极大连通子图。 有向图的连通性 连通：顶点v至v’ 之间有路径存在。 强连通图：有向图G的任意两点之间都连通。 强连通分量：有向图的极大连通子图。 无向图的生成树 无向图生成树：图的极小连通子图。包含图的n个结点和n-1条边 1、一棵有n个顶点的生成树有且仅有n-1条边 2、一个无向图有n个顶点和小于n-1条边，是非连通图 3、一个无向图有多于n-1条边，必有环 有向图的生成森林 有向树：如果一个有向图恰有一个顶点入度为0，其余顶点入度 均为1，则是有向树。 有向图的生成森林：由若干有向树组成，含有图中全部顶点，但 只有足以构成若干棵不相交的有向树的弧。 完全图 在图G中： 若G为无向图，任意两个顶点之间都有一条边，称G为无向完全图。顶点数为n，无向完全图的边数：e=n(n-1)/2 若G为有向图，任意两个顶点之间都有弧，称G为有向完全图。顶点数为n，有向完全图的弧数：e=n(n-1) 稀疏图(sparse graph)：有很少条边或弧(e&lt;nlog2n)的图。 稠密图(dense graph)：有很多条边或弧(e&gt;nlog2n)的图。 边或弧的权值(weight)：与弧或边相关的数。可以表示从一个顶点到另一个顶点的距离、花费的代价、所需的时间等。 网络(network)：带权的图称之为网络。 ​ 图的存储结构数组(邻接矩阵)表示法12345678910111213#define MAX_VERTEX_NUM 20typedef enum &#123;DG,DN,UDG,UDN&#125; GraphKindtypedef struct ArcCell&#123; int adj;&#125;ArcCell,AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];typedef struct &#123; int vex[MAX_VERTEX_NUM]; AdjMatrix arcs; int vexnum,arcnum; GraphKind kind;&#125; 邻接表12345678910111213141516#define MAX_VERTEX_NUM 20typedef int infoType;typedef struct ArcNode&#123; int adjvex; //邻接下标,当前表结点 struct ArcNode *nextrac;//下一邻接结点 infoType info;//边权值&#125;ArcNode;typedef struct VNode&#123;ArcNode *firstarc;int data;//有关信息&#125;VNode,AdjList[MAX_VERTEX_NUM];typedef struct &#123; AdjList vertices;//头结点数组 int vexnum,arcnum; int kind;&#125;ALGraph; 构造无向图UDG(邻接矩阵)12345678910111213141516void creatUDG(MGraph &amp;G)&#123; int a,b; int i,j; scanf(&quot;%d,%d&quot;,&amp;G.vexnum,&amp;G.arcnum);//读入顶点、边数 for(int i=0;i&lt;G.vexnum;i++&gt;)scanf(&quot;%d&quot;,&amp;G.vex[i]);//构造顶点数组 for(int i=0;i&lt;G.vexnum;i++) for(int j=0;j&lt;G.vexnum;i++&gt;) G.vertices[i][j]=&#123;0,NULL&#125;; for(int k=0;k&lt;G.arcnum;k++)&#123; scanf(&quot;%d,%d&quot;,&amp;a,&amp;b); i=LocateVex(G,a); j=LocateVex(G,b); G.arcs[i][j].adj=1; G.arcs[i][j].adj=G.arcs[j][i]; &#125;&#125; 构造无向图UDG(邻接表)12345678910111213141516void creatNG(ALGraph &amp;G)&#123;scanf(&quot;%d,%d&quot;,&amp;G.vexnum,&amp;G.arcnum);//读入顶点、边数for(int i=0;i&lt;G.vexnum;i++)&#123;//读入顶点值 scanf(&quot;%d&quot;,&amp;G.vertices[i].data); G.vertices[i].firstarc=NULL;&#125;for(i=0;i&lt;G.arcnum;i++)&#123; int a,b; scanf(&quot;%d,%d&quot;,&amp;a,&amp;b); p=(ArcNode*)malloc(sizeof(ArcNode)); q=(ArcNode*)malloc(sizeof(ArcNode)); p-&gt;adjvex=a;q-&gt;adjvex=b; p-&gt;nextarc=G.vertices[b].firstrac;G.vertices[b].firstrac=p;//&lt;b,a&gt; q-&gt;nextarc=G.vertices[a].firstrac;G.vertices[a].firstrac=q;//&lt;a,b&gt;&#125;&#125; 遍历深度优先遍历时间复杂度分析当用邻接表时，时间复杂度O(n+e),遍历所有顶点O(n),查找所有顶点的邻接点O(e)当用邻接矩阵时，时间复杂度O(nn),遍历所有顶点O(n),查找一个顶点的邻接点O(n),查找所有顶点的邻接点O(nn) 深度优先搜索(递归)123456789101112131415161718192021222324252627282930313233343536373839404142434445Boolean visited[MAX];//是否已被访问Status(*VisitFunc)(int v); void DFSTraverse(Graph G,Status(*Visit)(int v))&#123; VisitFunc=Visit; for(int v=0;v&lt;G.vexnum;++v) visited[v]=FLASE; for(int v=0;v&lt;G.vexnum;++v) if(!visited[v])DFS(G,v);&#125;void DFS()&#123; visited[v]=TRUE;VisitFunc(v); for(w=FirstAdjVex(G,v);w;w=NextAdjVex(G,v,w)) if(!visited[w])DFS(G,w);&#125;Boolean visited[MAX];Status (*VisitFunc)(int v);void DFSTraverse(Graph G,Status(*Vistit)(int v))&#123; VisitFunc=Visit; for(int i=0;i&lt;G.vexnum;i++)visited[i]=false; for(int i=0;i&lt;G.vexnum;i++)&#123; if(!visited[i])GFS(G,v); &#125;&#125;void GFS(Graph G,int v)&#123; visited[v]=true; VisitedFunc(v);//访问 for(int w=FirstAdjVex(G,v);w;w=NextAdjVex(G,v,w))&#123; if(!visited[w])GFS(G,v); &#125;&#125;int FirstAdjVex(Graph G,int v)&#123; return G.vertices[v].firstarc-&gt;adjvex;&#125;int NextAdjVex(Graph G,int v,int w)&#123; p=(ArcNode*)malloc(sizeof(ArcNode)); p=G.vertices[v].firstarc; while(p-&gt;adjvex!=w)&#123; p=p-&gt;nextarc; &#125; return p-&gt;nextarc-&gt;adjvex;&#125; 深度优先遍历（非递归）1234567891011121314151617181920212223242526272829303132333435363738394041424344Boolean visited[MAX];void GFS(Graph p,Status(*Visit)(int v))&#123; for(int i=0;i&lt;G.vexnum;i++)visited[i]=false; int p=0; cur=(ArcNode*)malloc(sizeof(ArcNode)); cur=G.vertices[0].firstarc; Stack&lt;int&gt; s; Visit(p); visited[p]=true; s.push(p); while(!s.empty())&#123; for(p=cur-&gt;adjvex;visited[p]&amp;&amp;cur!=null;cur=cur-&gt;nextarc,p=cur-&gt;adjvex)&#123;&#125; if(cur==NULL)&#123; s.pop(); cur=G.vertices[s.top()].firstarc; continue; &#125; Visit(p); visited[p]=true; s.push(p); cur=G.vertices[p].firsttarc; &#125; &#125;void DFStraverse(Graph G,Status(*Visit)(int v))&#123;for(int v=0;v&lt;G.vexnum;v++)visited[v]=false;stack&lt;int&gt; s;int u,w;for(v=0;v&lt;G.vexnum;v++)&#123; if(!visited[v])&#123; Visit(v);visited[v]=true;s.push(v); while(!s.empty())&#123; for(w=FirstAdjVex(G,u);w;w=NextAdjVex(G,u,w))&#123; if(!visited[u])&#123; Visit(v);visited[v]=true;s.push(v); break; &#125; &#125; if(!w)&#123;s.pop();&#125; &#125; &#125;&#125;&#125; 广度优先时间复杂度分析图的遍历本质上都是对每个顶点查找邻接点的过程，所以时间复杂度同深度遍历 广度优先遍历123456789101112131415161718void BFStraverse(Graph G,Status(*Visit)(int v))&#123;for(int v=0;v&lt;G.vexnum;v++)visited[v]=false;InitQueue(Q);int u,w;for(v=0;v&lt;G.vexnum;v++)&#123; if(!visited[v])&#123; Visit(v);visited[v]=true;EnQueue(Q,v); while(!QueueEmpty(Q))&#123; DeQueue(Q,u); for(w=FirstAdjVex(G,u);w;w=NextAdjVex(G,u,w))&#123; if(!visited[u])&#123; Visit(v);visited[v]=true;EnQueue(Q,v); &#125; &#125; &#125; &#125;&#125;&#125; 求无向图连通分支数量123456789int count(Graph G)&#123;for(int i=0;i&lt;G.vexnum;i++)&#123; if(visited[i]==0)&#123; k++; DFS(G,visit); &#125;&#125;return k;&#125; 最小生成树Prim算法12345678910111213141516171819202122struct&#123; vertexType adjvex;//顶点下标 int lowcost;//最小权值&#125;closedge[MAXA];void MiniSpanTree(MGrap G,VexType u)&#123; int k=LocateVex(u); for(int i=0;i&lt;vexnum;i++)&#123; if(i!=k) closedge[i]=&#123;k,G.arcs[k][i].adj&#125;; &#125; closege[k].lowcost=0;//以0判断是否纳入 for(int i=1;i&lt;vexnum;i++)&#123; k=Mini(closedge);//找到与以纳入顶点的最路径 printf(&quot;%c-&gt;%c&quot;,closedge[k].adjvex,G.vex[k])//输出一条边 closedge[k].lowcost=0;//纳入 for(int j=0;j&lt;vexnum;j++)&#123;//更新closedge if(G.arcs[k][j].adj&lt;closedge[j].lowcost) closedge[j]=&#123;G.vex[k],G.arcs[k][j].adj&#125;; &#125; &#125;&#125; kruscal算法12345678910111213141516171819202122232425262728293031void kruskal(Edge E[],int n,int e)&#123; int i,j,m1,m2,sn1,sn2,k,sum=0; int vset[n+1]; for(i=1;i&lt;=n;i++) //初始化辅助数组 vset[i]=i; k=1;//表示当前构造最小生成树的第k条边，初值为1 j=0;//E(边集)中边的下标，初值为0 while(k&lt;e)//生成的边数小于e时继续循环 &#123; m1=E[j].vex1; m2=E[j].vex2;//取一条边的两个邻接点 sn1=vset[m1]; sn2=vset[m2]; //分别得到两个顶点所属的集合编号 if(sn1!=sn2)//两顶点分属于不同的集合，该边是最小生成树的一条边 &#123;//防止出现闭合回路 printf(&quot;V%d-V%d=%d\\n&quot;,m1,m2,E[j].weight); sum+=E[j].weight; k++; //生成边数增加 if(k&gt;=n) break; for(i=1;i&lt;=n;i++) //两个集合统一编号 if (vset[i]==sn2) //集合编号为sn2的改为sn1 vset[i]=sn1; &#125; j++;//扫描下一条边 &#125; printf(&quot;最小权值之和=%d\\n&quot;,sum);&#125; AOV 网络和拓扑排序定义偏序：若集合 X 上的关系R是传递的、自反的、反对称的，则称R是集合X上的偏序关系。指集合中部分成员之间可比较。 全序：若关系R 是集合 X 上的偏序关系，如果对于每个x,y属于X，必有xRy 或yRx ，则称R是集合X上的全序关系。指集合中全部成员之间可比较。 拓扑排序：由一个集合上的一个偏序得到该集合上的一个全序的操作。这个全序被称为拓扑有序。 AOV(Activity On Vertices)网：有向图表示工程，顶点表示活动，有向边&lt;vi,vj&gt;表示活动vi必须先于活动vj进行,其中vi是vj的直接前驱，vj是vi的直接后继。若从顶点vi到vk有一条路径，则vi是vk的前驱、vk是vi的后继。 在AOV网中，不应该出现有向环。 AOV网中检测环的办法：对有向图构造其顶点的拓扑排序序列，若网中所有顶点都在它的拓扑有序序列中，则不存在环。（对一个无向图来说，可以用深度优先遍历，若遇到回边，则必定存在环） 算法实现1234567891011121314151617181920Status TopologicalSort(ALGraph G)&#123; int Indegree[MAX]; stack&lt;int&gt; S; FindeIndegree(G,Indegree);//计算各结点的入度 for(int i=0,i&lt;G.vexnum;i++)&#123; if(!Indegree[i])push(S,i); &#125; int count=0; p=(ArcNode*)malloc(sizeof(ArcNode)); while(!empty(S))&#123; pop(S,k);printf(&quot;%d&quot;,G.vertices[k].adjvex);count++; for(p=G.vertices[k].firstarc;p;p=p-&gt;nextarc)&#123; int q=p-&gt;adjvex; if(!(--Indegree[q]))push(S,q); &#125; &#125; if(count&lt;G,vexnum)return ERROR; return OK;&#125; AOV-网 关键路径AOE-网(Active On Edge)：在带权的有向无环图中，顶点表示事件，弧表示工程的一个活动，弧上权值表示活动持续的时间。用来估算工程完成时间。 源点：入度为0的顶点。汇点：出度为0的顶点。路径长度：AOE网中路径上各活动持续时间之和。关键路径：路径长度最长的路径。 设活动ai在有向无环图G的有向边&lt;j,k&gt;上： 事件vj的最早发生时间ve(j):从源点v0到vj的最长路径长度。ve(0)&#x3D;0;ve(j)&#x3D;从源点到顶点j的最长的路径长度。ve(k)&#x3D;Max{ve(j)+dut(&lt;j,k&gt;)} 事件vj的最迟开始时间vl(j)：保证汇点vn-1在ve(n-1)时刻完成的前提下，事件vj最迟允许开始的时间。vl(n-1) &#x3D; ve(n-1)＝从源点到汇点的最长路径长度;vl(k)&#x3D;从汇点到顶点k的最短的路径长度。vl(j)&#x3D;Min{vl(k)-dut(&lt;j,k&gt;)} 设活动ai在有向边&lt;j,k&gt;上,有： 活动ai的最早开始时间e(i)：从源点v0到vj的最长路径长度。e(i)&#x3D; ve(j); 活动ai的最迟开始时间l(i)：是不推迟工程完成的前提下，该活动允许的最迟开始时间。l(i)&#x3D;vl(k)-dut(&lt;j,k&gt;) 活动ai时间余量：l(i)-e(i) 关键活动：满足l(i)&#x3D;e(i)的活动。关键路径上的活动都是关键活动。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 int ve[MAX]; int vl[MAX];Status TopologicalSort(ALGraph G,stack T)&#123; int Indegree[MAX]; stack&lt;int&gt; S; FindeIndegree(G,Indegree);//计算各结点的入度 for(int i=0,i&lt;G.vexnum;i++)&#123; if(!Indegree[i])push(S,i); ve[i]=0; &#125; int count=0; p=(ArcNode*)malloc(sizeof(ArcNode)); while(!empty(S))&#123; pop(S,k);push(T,k);printf(&quot;%d&quot;,G.vertices[k].adjvex);count++; for(p=G.vertices[k].firstarc;p;p=p-&gt;nextarc)&#123; int q=p-&gt;adjvex; if(!(--Indegree[q]))push(S,q); if(ve[k]+*(p-&gt;info)&gt;ve[q])ve[q]=ve[k]+*(p-&gt;info); &#125; &#125; if(count&lt;G,vexnum)return ERROR; return OK;&#125;Status CriticalPath(ALGraph G)&#123; stack&lt;int&gt; T; int i=0; if(!TopologicalSort(Graph G,stack T)) return ERROR;//判断是否有环且求ve for(int i=0,i&lt;G.vexnum;i++)&#123; vl[i]=ve[G.vexnum-1]; &#125; while(!empty(T))&#123;//求vl pop(T,i); for(p=G.vertices[i].firstarc;p;p=p-&gt;nextarc)&#123; int j=p-&gt;adjvex; if(vl[i]&gt;vl[j]-*(p-&gt;info))vl[i]=ve[j]-*(p-&gt;info); &#125; &#125; for(int i=0,i&lt;G.vexnum;i++)&#123;//对每一个弧判断是否是关键路径/活动 for(p=G.vertices[i].firstarc;p;p=p-&gt;nextarc)&#123; int k=p-&gt;adjvex; int e=ve[i]; int l=vl[k]-*(p-&gt;info); if(e==l)printf(&quot;%d;%d;%d&quot;,i,k,*(p-&gt;info)); &#125; &#125;&#125; 最短路径Dijkstra算法用于求源点到其余顶点的最短路径 1234567891011121314151617181920212223242526272829void ShortPath(MGraph G,int v0,PathMatrix &amp;P,ShortPathTable &amp;D)&#123; bool final[MAX]; int v; for(int v=0;v&lt;G.vexnum;v++)&#123; final[v]=false; D[v]=G.arcs[v0][v];//所有顶点初始化 for(int w=0;w&lt;G.vexnum;w++)P[v][w]=false;//初始化P数组 if(D[v]&lt;INFINITY)P[v][v0]=P[v][v]=true;//将与v0有直接路径的顶点更改p &#125; D[v0]=0;fina[v0]=true;P[v0][v0]=true;//处理v0 for(int i=0;i&lt;G.vexnum;i++)&#123;//进行n-1次 min=INFINITY; for(int w=0;w&lt;G.vexnum;w++)&#123; if(!final[w]) if(D[w]&lt;min)&#123;v=w;min=D[w];&#125; &#125; if(min&lt;INFINITY)&#123; final[v]=true; for(int v=0;v&lt;G.vexnum;v++)&#123; if(!final[v]&amp;&amp;(min+G.arcs[w][v])&lt;D[v])&#123; D[v]=min+G.arcs[w][v]; P[v][w]=P[v][w]=true; &#125; &#125; &#125; &#125;&#125; Floyd算法用于求点到点的最短路径 123456789101112131415161718192021222324252627282930313233343536373839#define INFINITY 999void ShortPath(MGraph G,PathMatrix &amp;P[],DistanceMatrix &amp;D)&#123; for(int v=0;v&lt;G.vexnum;v++) for(int w=0;w&lt;G.vexnum;w++)&#123; D[v][w]=G.arcs[v][w]; for(int u=0;u&lt;G.vexnum;u++)P[v][w][u]=0; if(D[v][w]&lt;INFINITY)P[v][w][v]=P[v][w][w]=true; &#125; for(int u=0;u&lt;G.vexnum;u++) for(int v=0;v&lt;vexnum;v++) for(int w=0;w&lt;vexnum;w++)&#123; if(D[v][w]&gt;D[v][u]+D[u][w])&#123; D[v][w]=D[v][u]+D[u][w]; for(int i=0;i&lt;G.vexnum;G++)&#123; P[v][w][i]=p[v][u][i]||p[u][w][i]; &#125; &#125; &#125;&#125;#define INFINITY 999void ShortPath(MGraph G,PathMatrix &amp;P[],DistanceMatrix &amp;D)&#123; for(int v=0;v&lt;G.vexnum;v++) for(int w=0;w&lt;G.vexnum;w++)&#123; D[v][w]=G.arcs[v][w];//初始化D for(int u=0;u&lt;G.vexnum;u++)P[v][w][u]=false;//初始化P if(D[v][w]&lt;INFINITY)P=[v][w][v]=P[v][w][w]=true;//有直接路径v-&gt;w &#125; for(int u=0;u&lt;G.vexnum;u++) for(int v=0;v&lt;G.vexnum;v++) for(int w=0;w&lt;G.vexnum;w++)&#123; if(D[v][u]+D[u][w]&lt;D[v][w])&#123; D[v][w]=D[v][u]+D[u][w]; for(int i=0;i&lt;G.vexnum;i++)&#123; P[v][w][i]=P[v][u][i]||P[u][w][i];//把从v-&gt;w的最短路径上经过的点全置为true &#125; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include&lt;stdio.h&gt;#include&lt;cstdlib&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;#define MAX_VERTEX_NUM 20typedef int Status;typedef struct ArcNode &#123; int adjvex; //邻接下标,当前表结点 struct ArcNode* nextarc;//下一邻接结点 int info;//边权值&#125;ArcNode;typedef struct VNode &#123; ArcNode* firstarc; int data;//有关信息&#125;VNode, AdjList[MAX_VERTEX_NUM];typedef struct &#123; AdjList vertices;//头结点数组 int vexnum, arcnum; int kind;&#125;ALGraph;bool visited[MAX_VERTEX_NUM];//创建邻接表图void creatNG(ALGraph&amp; G) &#123; int a, b; ArcNode* p, *q; printf(&quot;input顶点，边数:&quot;); scanf_s(&quot;%d,%d&quot;, &amp;G.vexnum, &amp;G.arcnum);//读入顶点、边数 for (int i = 0; i &lt; G.vexnum; i++) &#123;//读入顶点值 printf(&quot;输入第%d个顶点值:&quot;,i); scanf_s(&quot;%d&quot;,&amp;G.vertices[i].data); ArcNode* p = (ArcNode*)malloc(sizeof(ArcNode)); G.vertices[i].firstarc = p; p-&gt;adjvex = -1; &#125; for (int i = 0; i &lt; G.arcnum; i++) &#123; printf(&quot;输入第i条边:&quot;); scanf_s(&quot;%d,%d&quot;, &amp;a, &amp;b); p = (ArcNode*)malloc(sizeof(ArcNode)); q = (ArcNode*)malloc(sizeof(ArcNode)); p-&gt;adjvex = a; q-&gt;adjvex = b; p-&gt;nextarc = G.vertices[b].firstarc; G.vertices[b].firstarc = p;//&lt;b,a&gt; q-&gt;nextarc = G.vertices[a].firstarc; G.vertices[a].firstarc = q;//&lt;a,b&gt; &#125;&#125;int visit(int v) &#123; printf(&quot;%d &quot;,v); return 0;&#125;int FirstAdjVex(ALGraph G, int v) &#123; return G.vertices[v].firstarc-&gt;adjvex;&#125;int NextAdjVex(ALGraph G, int v, int w) &#123; ArcNode* p; p = (ArcNode*)malloc(sizeof(ArcNode)); p = G.vertices[v].firstarc; while (p-&gt;adjvex != w) &#123; p = p-&gt;nextarc; &#125; return p-&gt;nextarc-&gt;adjvex;&#125;//深度优先void DFStraverse(ALGraph G, Status(*Visit)(int v)) &#123; for (int v = 0; v &lt; G.vexnum; v++)visited[v] = false; stack&lt;int&gt; s; int u, w; for (int v = 0; v &lt; G.vexnum; v++) &#123; if (!visited[v]) &#123; Visit(v); visited[v] = true; s.push(v); while (!s.empty()) &#123; v=s.top(); s.pop(); for (w = FirstAdjVex(G, v); w!=-1; w = NextAdjVex(G, v, w)) &#123; if (!visited[w]) &#123; Visit(w); visited[w] = true; s.push(w); break; &#125; &#125; //if (w!=-1) &#123; s.pop(); &#125; &#125; &#125; &#125;&#125;//广度void BFStraverse(ALGraph G, Status(*Visit)(int v)) &#123; for (int v = 0; v &lt; G.vexnum; v++)visited[v] = false; queue&lt;int&gt; Q; int u, w; for (int v = 0; v &lt; G.vexnum; v++) &#123; if (!visited[v]) &#123; Visit(v); visited[v] = true; Q.push(v); while (!Q.empty()) &#123; u = Q.front(); Q.pop(); for (w = FirstAdjVex(G, u); w != -1; w = NextAdjVex(G, u, w)) &#123; if (!visited[w]) &#123; Visit(w); visited[w] = true; Q.push(w); &#125; &#125; &#125; &#125; &#125;&#125;int main() &#123; ALGraph G; creatNG(G); DFStraverse(G, visit); printf(&quot;\\n&quot;); BFStraverse(G, visit);&#125; 算法查找定义查找表(Search Table) ：由同一类型的数据元素(或记录)构成的集合。 对查找表经常进行的操作: 1）查询某个“特定的”数据元素是否在查找表中； 2）检索某个“特定的”数据元素的各种属性； 3）在查找表中插入一个数据元素； 4）从查找表中删去某个数据元素。 静态查找表(Static Search Table) : 仅作上述1）和2）操作的查找表 动态查找表(Dynamic Search Table):作上述1）、2）、3）、4）操作的查找表 关键字(Key):数据元素中某个数据项的值，用以标识一个数据元素 主关键字(Primary Key):可以唯一标识一个记录的关键字 次关键字(Secondary Key):用以识别若干记录的关键字 平均查找长度 查找算法的性能分析：通常以关键字和给定值进行比较的记录个数的平均值为衡量算法好坏的依据. 平均查找长度(Average Search Length)：查找算法在查找成功时平均查找长度和查找不成功时平均查找长度之和。 查找成功的平均查找长度：为确定记录在查找表中的位 置，需和给定值进行比较的关键字个数的期望值， 令： Pi:查找表中第i个记录的概率 Ci:找到表中其关键字与给定值相等的第i个记录时，和给定值比较过的关键字的个数． ASL(SS)=NUM(PiCi); 查找不成功平均查找长度：查找不成功时和给定值进行比较 的关键字个数的期望值称为查找不成功时平均查找长度。 顺序表的查找代码实现 123456int Search_Seq( SSTable ST, KeyType key ) &#123; ST.elem[0]. key = key;//哨兵 for ( i = ST.length ; ! EQ(ST.elem[i]. key, key ) ; - - i ); return i; &#125; // Search_Seq 性能分析 等概率下查找成功的平均查找长度： $P_{i}&#x3D;\\frac{1}{n}$$C_{i}&#x3D;n-i+1$$$ASL_{SS}&#x3D;\\frac{1}{n}\\sum_{i&#x3D;1}^{n}(n-i+1)&#x3D;\\frac{n+1}{2}$$ 等概率下查找不成功的平均查找长度（假定查找成功和查找不 成功的可能性相同，对每个记录的查找概率也相同）： $P_{i}&#x3D;\\frac{1}{2}$$C_{i}&#x3D;n+1$$$ASL_{SF}&#x3D;\\frac{1}{2}*(n+1)&#x3D;\\frac{n+1}{2}$$ 平均查找长度：$$ASL&#x3D;\\frac{n+1}{4}+\\frac{n+1}{2}&#x3D;\\frac{3}{4}(n+1)$$ 有序表的二分查找代码实现 123456789101112int Search_Bin ( SSTable ST, KeyType key ) &#123; low = 1 ; high = ST.length ; while ( low &lt;= high ) &#123; mid = ( low + high ) / 2 ; if ( EQ(ST.elem[mid]. key, key ) ) return mid ; else if ( LT( key , ST.elem[mid]. key ) ) high = mid -1 ; else low = mid + 1; &#125; return 0 ； &#125; // Search_Bin 性能分析 一般情况下，表长为n的折半查找的判定树的深度和含有n个 结点的完全二叉树的深度相同，设$n&#x3D;2^{h}-1$且查找概率相等 （1&#x2F;n），则折半查找成功的平均查找长度$$ASL_{SS}&#x3D;\\frac{1}{n}\\sum_{j&#x3D;1}^{h}j*2^{j-1}&#x3D;\\frac{n+1}{n}\\log_{2}{(n+1)}-1$$ 分块有序的查找（索引顺序表的查找）定义 顺序表+索引表组成 索引表按关键字有序，可用二分或顺序查找性能分析 长度为n的表平均分成n块，每块含有s个记录 $ASL_{bs}&#x3D;L_{b}+L_{s}$ $L_{b}$:索引表确定所在块的平均查找长度 $L_{s}$:块中查找元素的平均查找长度 $ASL_{bs}&#x3D;L_{b}+L_{s}&#x3D;b\\sum_{j&#x3D;1}^{b}j+s\\sum_{j&#x3D;1}^{s}j&#x3D;\\frac{b+1}{2}+\\frac{s+1}{2}$ 二叉查找树（二叉排序树）定义二叉排序树(二叉查找树）(Binary Sort Tree, BST)：空树或具有下列性质的二叉树:根的左子树若非空，则左子树上的所有结点的关键字值均小于根结点的值。根的右子树若非空，则右子树上的所有结点的关键字值均大于根结点的值。它的左右子树同样是二叉排序树。 中序遍历二叉排序树可得到一个关键字的有序序列算法实现1.查找 12345Status Search(BiTree T,KeyType key)&#123; if(T==NULL||EQ(key,T-&gt;data.key))return T; else if(LT(key,T-&gt;data.key)) return Search(T-&gt;left,key); else return Search(T-&gt;right,key);&#125; 2.插入&#x3D;&#x3D;改进查找算法&#x3D;&#x3D; 123456Status Search(BiTree T,KeyType key,BiTree f,BiTree &amp;p)&#123; if(!T)&#123;p=f; return false;&#125; else if(EQ(kEY,T-&gt;data.key))&#123;p=T;return true;&#125; else if(LT(key,T-&gt;data.key))return Search(T-&gt;left,key,T,p); else return Search(T-&gt;right,key,T,p);&#125; 123456789101112Status Insert(BiTree &amp;T,Element e)&#123; Bitree p; if(!Search(Bitree T,e.key,NULL,p))&#123;//查询失败 Bitree s=(BiTree)malloc(sizeof(BiTNode)); s-&gt;data=e;s-&gt;left=s-&gt;right=NULL; if(!p)T=s;//插入结点是根结点 else if(LT(e.key,p-&gt;data.key)) p-&gt;left=s; else p-&gt;right=s; return true; &#125; reutrn false;&#125; 3.删除 123456789101112131415161718192021222324252627282930Status DeleteBST(BSTree &amp;T,int key)&#123; if(!T)return FALSE;//空树 else&#123; if(EQ(key,T-&gt;data)) return Delete(T); else if(LT(key,T-&gt;data))&#123; return DeleteBST(T-&gt;lchild,key); &#125; else return DeleteBST(T-&gt;rchild,key); &#125;&#125;Status Delete(BSTree &amp;p)&#123; BSTree q=(BSTree)malloc(szieof(BiTNode)) if(!p-&gt;rchild)&#123; q=p;p=p-&gt;lchild;free(q); &#125;else if(!p-&gt;lchild)&#123; q=p;p=p-&gt;rchild;free(q); &#125;else&#123; q=p; s=p-&gt;lchild; while(s-&gt;rchild)&#123;//找左子树最大值 q=s; s=s-&gt;rchild; &#125; p-&gt;data=s-&gt;data;//取左子树最大值 if(q!=p)q-&gt;rchild=s-&gt;lchild;//悬挂最大值的左子树 else q-&gt;lchild=s-&gt;lchild; free(s); &#125;&#125; 性能分析 最坏情况：单支树，深度为n,$ASL_(ss)&#x3D;\\frac{n+1}{2}$ 最好情况：折半查找判定树，深度为n,$ASL_(ss)$与$log_(2)^(n)$成正比 哈希表排序插入排序直接插入排序（基于顺序查找）介绍 稳定排序 从未排序中依次取出元素与已排序的元素依次比较并插入到合适位置 缺点：大量数据时，比较和移动操作过多 优点：容易实现，适用于基本有序时间复杂度 $$O(n^{2})$$ 最好情况：比较n-1，移动0 最坏情况：比较$\\sum_{i&#x3D;2}^{n}i&#x3D;\\frac{(n+2)(n-1)}{2}$,移动$\\sum_{i&#x3D;2}^{n}(i+1)&#x3D;\\frac{(n+4)(n-1)}{2}$代码 12345678910111213141516171819202122void InsertionSort(SqLiist &amp;L)&#123; for(i=2;i&lt;=L.length;i++)&#123; if(LT(L.r[i].key,L.r[i-1].key))&#123; L.r[0]=L.r[i];//监视哨 L.r[i]=L.r[i-1]; for(int j=i-2;LT(L.r[0].key,L.r[j].key);--j) L.r[j+1]=L.r[j];//比监事哨大的一律右移动 L.r[j+1]=L.r[0]; &#125; &#125;&#125;void InsertionSort(SqLit &amp; L)&#123; for(int i=2;i&lt;=L.length;++i)&#123; if(LT(L.r[i].key,L.r[i-1].key))&#123; L.r[0]=L.r[i]; //复制为监视哨 L.r[i]=L.r[i-1]; for(int j=i-2;LT(L.r[0].key,L.r[j].key);--j) L.r[j+1]=L.r[j]; L.r[j+1]=L.r[0]; &#125; &#125;&#125; 折半插入排序（基于折半查找）介绍 稳定 把直接插入排序比较代码替换为折半查找插入位置时间复杂度 $$O(n^{2}) 仅仅优化了比较次数代码 123456789101112131415void BiInsertionSort(SqList &amp;L)&#123; for(int i=2;i&lt;L.length;i++)&#123; L.r[0]=L.r[i]; low=1;high=i-1; while(low&lt;=high)&#123; m=(low+high)/2; if(LT(L.r[0].key,L.r[m],key))&#123; high=m-1; &#125;else low=m+1; &#125; for(int j=i-1;j&gt;=high+1;j--) L.r[j+1]=L.r[j];//后移数据 L.r[high+1]=L.r[0];//插入 &#125;&#125; 希尔排序（基于逐趟缩小增量）介绍 不稳定 使用增量进行直接插入排序时间复杂度 在$O(nlog_{2}^{n})$与$O(n^{2})$之间代码 1234567891011121314151617void ShellSort (SqList &amp;L, int dlta[], int t)&#123; // 增量为dlta[]的希尔排序 for (k=0; k&lt;t; ++t) ShellInsert(L, dlta[k]); //一趟增量为dlta[k]的插入排序&#125; // ShellSortvoid ShellInsert ( SqList &amp;L, int dk ) &#123; for ( i=dk+1; i&lt;=L.length; ++i ) if (LT( L.r[i].key,L.r[i-dk].key)) &#123; L.r[0] = L.r[i]; // 暂存在r[0] for (j=i-dk; j&gt;0&amp;&amp; LT(L.r[0].key,L.r[j].key); j-=dk) L.r[j+dk] = L.r[j]; // 记录后移，查找插入位置 L.r[j+dk] = L.r[0]; // 插入 &#125; // if&#125; // ShellInsert 冒泡排序介绍 稳定 对n个数进行n-1趟排序，每次冒泡最大值时间复杂度 $O(n^{2})$ 最坏比较$\\sum_{i&#x3D;n}^{2}(i-1)&#x3D;\\frac{n(n-1)}{2}$ 最坏移动$3\\sum_{i&#x3D;n}^{2}(i-1)&#x3D;\\frac{3n(n-1)}{2}$代码 1234567891011121314151617181920212223242526void bubble_sort(int arr[], int size)&#123; int i = 0; int change = 1;//交换标志 for (i = 0,change=1; i &lt; size - 1&amp;&amp;change; i++) &#123; change = 0; int j = 0; for (j = 0; j &lt; size - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; change = 1; &#125; &#125; printf(&quot;第%d趟交换结果：&quot;,i+1); for (int k = 0; k &lt; size; k++) &#123; printf(&quot;%d &quot;, arr[k]); &#125; printf(&quot;\\n&quot;); &#125;&#125; 快速排序介绍 稳定 首先选一个枢值（即比较的基准），通过一趟排序将待排序记录分割成独立的两部分前一部分记录的关键码均小于或等于枢值，后一部分记录的关键码均大于或等于枢值，然后分别对这两部分重复上述方法，直到整个序列有序。时间复杂度 平均时间复杂度&#x3D;最好时间复杂度&#x3D;$O(nlog_{2}^{n})$ 最坏时间复杂度$O(n^{2})$（当序列有序时，退化为冒泡排序）代码 12345678910111213141516171819202122232425262728int Partition (SqList&amp; L, int low, int high) &#123;L.r[0]=L.r[low]; pivotkey = L.r[low].key; while (low&lt;high) &#123; while (low&lt;high &amp;&amp; L.r[high].key&gt;=pivotkey) --high; L.r[low]=L.r[high]; while (low&lt;high &amp;&amp; L.r[low].key&lt;=pivotkey) ++low; L.r[high]=L.r[low]; &#125;L.r[low]=L.r[0]; return low; // 返回枢轴所在位置&#125; // Partitionvoid QSort (SqList &amp;L, int low, int high) &#123; // 对记录序列R[s..t]进行快速排序 if (low &lt; high) &#123; // 长度大于1 pivotloc = Partition(L, low, high); // 对 R[s..t] 进行一次划分 QSort(L, low, pivotloc-1); // 对低子序列递归排序，pivotloc是枢轴位置 QSort(L, pivotloc+1, high); // 对高子序列递归排序 &#125;&#125; // QSortvoid QuickSort( SqList &amp; L) &#123; // 对顺序表进行快速排序 QSort(L, 1, L.length);&#125; // QuickSort 选择排序简单选择排序介绍 从无序序列中选出最小记录插入到有序序列时间复杂度 $O(n^{2})$ 比较总次数$\\sum_{i&#x3D;1}^{n-1}(n-i)&#x3D;\\frac{n(n-1)}{2}$代码 1234567891011void SelectSort (SqList &amp;L) &#123; // 对记录序列R[1..n]作简单选择排序。 for (i=1; i&lt;L.length; ++i) &#123; // 选择第 i 小的记录，并交换到位 j = SelectMinKey(L, i); // 在 R[i..n] 中选择关键字最小的记录 if (i!=j) L.r[i]←→L.r[j]; // 与第 i 个记录交换 &#125;&#125; // SelectSort 堆排序介绍 不稳定 大根堆&#x2F;小根堆：完全二叉树中所有非终端结点的值均不小于(或不大于)其左、右孩子结点的值。 若在输出堆顶的最小(大)值之后，使得剩余n-1个元素的序列重又建成一个堆，则得到 n个元素中的次小(大)值。此反复执行，便能得到一个有序序列，这个过程称之为堆排序。复杂度 时间复杂度$O(nlog_{2}^{n})$ 空间复杂度$O(1)$ 归并排序基数排序复杂度总结&#x3D;&#x3D;选择排序不稳定&#x3D;&#x3D; 基础算法埃及分数旅行规划对以自身为中心的景点按距离排序出行时间 12345678910111213141516171819202122#include&lt;stdio.h&gt;int main()&#123; int a,b,c,d,e; printf(&quot;分子，分母&quot;); scanf(&quot;%d,%d&quot;,&amp;a,&amp;b); printf(&quot;%d/%d=&quot;,a,b); do &#123; c=b/a; e=c+1; printf(&quot;1/%d+&quot;,e); a=a*e-b; b=b*e; &#125;while(a!=1&amp;&amp;b%a!=0); if(a!=1&amp;&amp;b%a==0) printf(&quot;1/%d&quot;,b/a); else printf(&quot;1/%d&quot;,b/a); return 0;&#125; 五个莫尼森数1234567891011121314151617181920212223242526272829303132333435#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main()&#123; int m,p=2,a=1,t,i,b,x; while(a&lt;=5) &#123; m=pow(2.0,p)-1; for(t=2;t&lt;m;t++) if(m%t==0)break; if(m==t) &#123; a++; printf(&quot;%d\\n&quot;,m); &#125; do &#123; p++; for(x=2;x&lt;p;x++) if(p%x==0)continue; &#125;while(p!=x); &#125; return 0;&#125; /*t = 0; while ( t == 0 ) &#123; p++; for ( t = 1, j = 2; t &amp;&amp; j &lt;= sqrt( p ); j++ ) if ( p % j == 0 ) t = 0; &#125;*/ 输出星号123456789101112131415161718192021##include &lt;stdio.h&gt; int main() &#123;int i,j,k; for (i=0;i&lt;=3;i++) &#123;for (j=0;j&lt;=2-i;j++) printf(&quot; &quot;); for (k=0;k&lt;=2*i;k++) printf(&quot;*&quot;); printf(&quot;\\n&quot;); &#125; for (i=0;i&lt;=2;i++) &#123;for (j=0;j&lt;=i;j++) printf(&quot; &quot;); for (k=0;k&lt;=4-2*i;k++) printf(&quot;*&quot;); printf(&quot;\\n&quot;); &#125; return 0; &#125; 分解质因数1234567891011121314151617181920#include &lt;stdio.h&gt;int main()&#123; int n, i; scanf( &quot;%d&quot;, &amp;n ); printf( &quot;%d=&quot;, n ); for ( i = 2; i &lt;= n; i++ ) while ( n != i ) &#123; if ( n % i == 0 ) &#123; printf( &quot;%d*&quot;, i ); n = n / i; &#125; else break; &#125; printf( &quot;%d&quot;, n ); &#125; 完数1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;int main()&#123; int i,j,sum=0; for(i=2;i&lt;=1000;i++) &#123; for(j=1;j&lt;i;j++) &#123; if(i%j==0) sum+=j; &#125; if(sum==i) &#123; printf(&quot;%d=1&quot;,sum); for(j=2;j&lt;i;j++) &#123; if(i%j==0) printf(&quot;+%d&quot;,j); &#125; &#125; if(sum==i)&#123; printf(&quot;\\n&quot;); &#125; sum=0; &#125; return 0;&#125; 质数12345678910111213141516171819202122232425#include &lt;stdio.h&gt;int main()&#123; int i,j,n=0; for(i=100;i&lt;=200;i++) &#123; for(j=2;j&lt;i;j++) &#123; if(i%j==0) break; &#125; if(j==i) &#123; printf(&quot;%d &quot;,i); n++; if(n%10==0) printf(&quot;\\n&quot;); &#125; &#125; return 0;&#125; 公约数，公倍数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;stdio.h&gt;int main()&#123; int m,n,r,x,t; while(2) &#123; printf(&quot;输入两个正整数：&quot;); scanf(&quot;%d,%d&quot;,&amp;n,&amp;m); if(n&lt;m) &#123;x=n; n=m; m=x; &#125;t=n*m; while(m!=0) &#123; r=n%m; n=m; m=r; &#125; printf(&quot;最大公约数为:%d\\n&quot;,n); printf(&quot;最小公倍数为:%d\\n&quot;,t/n); &#125; return 0;&#125;#include&lt;stdio.h&gt;int main()&#123; int m,n,i,x; scanf(&quot;%d,%d&quot;,&amp;m,&amp;n);/* for(i=m;i&gt;0;i--) if(m%i==0&amp;&amp;n%i==0) &#123;printf(&quot;max公约数:%d\\nmin公倍数:%d&quot;,i,m*n/i); break; &#125;*/ x=m*n; while(i!=0) &#123;i=m%n; m=n; n=i; &#125; printf(&quot;max公约数:%d\\nmin公倍数:%d&quot;,m,x/m); return 0; &#125; 分解质因子式123456789101112131415161718192021222324252627282930313233343536373839#include&lt;stdio.h&gt; #include&lt;math.h&gt;int main(void)&#123;int i,j;long int m, n;int count;int isPrime,flag;isPrime = 1;flag = 0;scanf(&quot;%ld&quot;,&amp;n);printf(&quot;%ld=&quot;,n);m = sqrt(n);for(i = 2; i &lt;= m;i++)&#123;if(n%i == 0)&#123;//printf(&quot;%d&quot;,i);isPrime = 0;count = 1;n = n / i;while(n%i == 0)&#123;n = n / i;count++;&#125;if(flag)printf(&quot;*&quot;);elseflag = 1;if(count == 1)printf(&quot;%d&quot;,i);elseprintf(&quot;%d^%d&quot;,i,count);&#125;&#125;if(isPrime)printf(&quot;%d&quot;,n);return 0;&#125; 统计单词个数12345678910111213141516#include&lt;stdio.h&gt;int main()&#123; char string[81]; int i,sum=0,word=0; char c; gets(string); for(i=0;(c=string[i]!=&#x27;\\0&#x27;;i++) if(c==&#x27;&#x27;)word=0; else if(word==0)&#123; word=1; num++; &#125; printf(&quot;There are %d words in this line.\\n&quot;,sum); retun 0;&#125; 数字变字符123456#include&lt;stdio.h&gt;int main()&#123; return 0;&#125; 1234567891011121314151617181920212223242526272829public class VedioExtractSpeech &#123; public static void main(String[] args) &#123; System.out.println(&quot;toChinese：&quot;+toChinese(&quot;1230456&quot;)); System.out.println(&quot;toChinese2：&quot;+toChinese2(&quot;1230456&quot;)); &#125; private static String toChinese(String str) &#123; String[] s1 = &#123; &quot;零&quot;, &quot;一&quot;, &quot;二&quot;, &quot;三&quot;, &quot;四&quot;, &quot;五&quot;, &quot;六&quot;, &quot;七&quot;, &quot;八&quot;, &quot;九&quot; &#125;; String[] s2 = &#123; &quot;十&quot;, &quot;百&quot;, &quot;千&quot;, &quot;万&quot;, &quot;十&quot;, &quot;百&quot;, &quot;千&quot;, &quot;亿&quot;, &quot;十&quot;, &quot;百&quot;, &quot;千&quot; &#125;; String result = &quot;&quot;; int n = str.length(); for (int i = 0; i &lt; n; i++) &#123; int num = str.charAt(i) - &#x27;0&#x27;; if (i != n - 1 &amp;&amp; num != 0) &#123; result += s1[num] + s2[n - 2 - i]; &#125; else &#123; result += s1[num]; &#125; &#125; return result; &#125; private static String toChinese2(String str) &#123; String[] s2 = &#123;&quot;零&quot;, &quot;一&quot;, &quot;二&quot;, &quot;三&quot;, &quot;四&quot;, &quot;五&quot;, &quot;六&quot;, &quot;七&quot;, &quot;八&quot;, &quot;九&quot;&#125;; StringBuffer sb=new StringBuffer(); for (char c : str.toCharArray()) &#123; sb.append(s2[Integer.parseInt(String.valueOf(c))]); &#125; return sb.toString(); &#125;&#125; 取每一位数字12int a = 4567895：a//10000%10 二分法循环12345678910111213141516171819202122232425int search(int* nums, int numsSize, int target)&#123; int low=0 , high=numsSize-1; int half=(low+high)/2; while (low&lt;=high)&#123; half = (low + high) / 2; if (nums[half]==target) break; if (nums[half]&gt;target)&#123; high=half-1; continue; &#125; if (nums[half]&lt;target)&#123; low=half+1; continue; &#125; &#125; if(nums[half]==target)&#123; return half; &#125; else return -1; &#125; 123456789101112131415161718192021222324252627282930313233package javasuanfa;public class Main &#123; public static void main(String[] args) &#123; int[] nums = &#123;1, 2, 3, 4, 5, 6&#125;; int target = 3; System.out.println(search(nums, target)); &#125; public static int search(int[] nums, int target) &#123; if (target &lt; nums[0] || target &gt; nums[nums.length - 1]) &#123; return -1; &#125; int left = 0; int right = nums.length - 1; while (left &lt;= right) &#123; int mid = (left + right) / 2; if (nums[mid] == target) &#123; return mid; &#125; else if (target &lt; nums[mid]) &#123; right = mid - 1; &#125; else if (target &gt; nums[mid]) &#123; left = mid + 1; &#125; &#125; return -1; &#125; &#125; 123456789101112131415161718192021222324252627282930package javasuanfa;public class Main &#123; public static void main(String[] args) &#123; int[] nums = &#123;1, 2, 3, 4, 5, 6&#125;; int target = 3; System.out.println(search(nums, target,0,nums.length-1)); &#125; public static int search(int[] nums, int target, int left, int right) &#123; if (target &lt; nums[0] || target &gt; nums[nums.length - 1]) &#123; return -1; &#125; left = 0; right = nums.length - 1; int mid = (left + right) / 2; if (target &lt; nums[mid]) &#123; return search(nums, target, left, mid - 1); &#125; else if (target &gt; nums[mid]) &#123; return search(nums, target, mid + 1, right); &#125; else &#123; return mid; &#125; &#125; &#125; 排序算法打擂台12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;int main()&#123; int a[3][4]=&#123;&#123;0,1,2,3&#125;,&#123;4,5,6,7&#125;,&#123;8,9,10,11&#125;&#125;,t,x,y,max,row,colum; max=a[0][0]; for(x=0;x&lt;=2;x++) &#123;for(y=0;y&lt;=3;y++) if(a[x][y]&gt;max) &#123; max=a[x][y]; row=x; colum=y; &#125; else &#123; row=0; colum=0; &#125; &#125; printf(&quot;max=%d\\nrow=%d\\ncolum=%d\\n&quot;,max,row+1,colum+1); return 0;&#125; 冒泡排序c语言1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;void bubble_sort(int arr[], int size)&#123; int i = 0; int change = 1;//交换标志 for (i = 0,change=1; i &lt; size - 1&amp;&amp;change; i++) &#123; change = 0; int j = 0; for (j = 0; j &lt; size - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; change = 1; &#125; &#125; printf(&quot;第%d趟交换结果：&quot;,i+1); for (int k = 0; k &lt; size; k++) &#123; printf(&quot;%d &quot;, arr[k]); &#125; printf(&quot;\\n&quot;); &#125;&#125;int main()&#123; int size = 0; printf(&quot;输入数组大小size:&quot;); scanf(&quot;%d&quot;, &amp; size); int arr[100]; int i = 0; printf(&quot;输入要升序排序的数组:&quot;); for (i = 0; i &lt; size; i++) &#123; scanf(&quot;%d&quot;,&amp;arr[i]); &#125; printf(&quot;排序前：&quot;); for (i = 0; i &lt; size; i++) &#123; printf(&quot;%d &quot;, arr[i]); &#125; printf(&quot;\\n&quot;); bubble_sort(arr, size); // 冒泡排序函数 printf(&quot;排序后：&quot;); for (i = 0; i &lt; size; i++) &#123; printf(&quot;%d &quot;, arr[i]); &#125; return 0;&#125; 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;int main()&#123; int a[10],t,i,n; printf(&quot;input10nums:&quot;); for(i=0;i&lt;=9;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(n=0;n&lt;=8;n++)//8=N-2&#123; for(i=0;i&lt;=8-n;i++)//8-n=N-2-n &#123;if(a[i]&gt;a[i+1]) &#123;t=a[i]; a[i]=a[i+1]; a[i+1]=t; &#125; &#125;&#125;for(i=0;i&lt;=9;i++)printf(&quot;%d\\n&quot;,a[i]); return 0;&#125; java123456789101112131415161718192021222324252627public class Main&#123; public static void main(String []args)&#123; int arry[]=&#123;3,2,5,6,8,7&#125;; Main sorter=new Main(); sorter.sort(arry); &#125; public void sort(int[] array)&#123; for(int i = 0;i&lt;array.length-1;i++)&#123; for(int k = 0;k&lt;array.length-1-i;k++)&#123; if(array[k]&gt;array[k+1])&#123; int temp=array[k]; array[k]=array[k+1]; array[k+1]=temp; &#125; &#125; &#125; showArray(array); &#125; public void showArray(int[] aray)&#123; for(int x:aray)&#123; System.out.print(x ); &#125; &#125; &#125; 链表冒泡排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define LEN sizeof(struct student)struct student&#123;long num; int score; struct student *next;&#125;;struct student lista,listb;int n,sum=0;int main()&#123;struct student *creat(void); struct student *insert(struct student *,struct student *); void print(struct student *); struct student *px(struct student *abh,int sum); struct student *ahead,*bhead,*abh; printf(&quot;input list a:\\n&quot;); ahead=creat(); sum=sum+n; printf(&quot;input list b:\\n&quot;); bhead=creat(); sum=sum+n; abh=insert(ahead,bhead); abh=px(abh,sum); print(abh); return 0;&#125;struct student *creat(void) //建立链表函数 &#123;struct student *p1,*p2,*head; n=0; p1=p2=(struct student *)malloc(LEN); printf(&quot;input number &amp; scores of student:\\n&quot;); printf(&quot;if number is 0,stop inputing.\\n&quot;); scanf(&quot;%ld,%d&quot;,&amp;p1-&gt;num,&amp;p1-&gt;score); head=NULL; while(p1-&gt;num !=0) &#123;n=n+1; if (n==1) head=p1; else p2-&gt;next=p1; p2=p1; p1=(struct student *)malloc(LEN); scanf(&quot;%ld,%d&quot;,&amp;p1-&gt;num,&amp;p1-&gt;score); &#125; p2-&gt;next=NULL; return(head);&#125; /*struct student *insert(struct student *ah,struct student *bh) //插入函数 &#123;struct student * pa1,* pa2,* pb1,* pb2; pa2=pa1=ah; pb2=pb1=bh; do &#123;while((pb1-&gt;num&gt;pa1-&gt;num) &amp;&amp; (pa1-&gt;next !=NULL)) &#123;pa2=pa1; pa1=pa1-&gt;next; &#125; if (pb1-&gt;num &lt;= pa1-&gt;num) &#123;if (ah==pa1) ah=pb1; else pa2-&gt;next=pb1; pb1=pb1-&gt;next; pb2-&gt;next=pa1; pa2=pb2; pb2=pb1; &#125; &#125;while ((pa1-&gt;next!=NULL) || (pa1==NULL &amp;&amp; pb1!=NULL)); if ((pb1!=NULL) &amp;&amp; (pb1-&gt;num&gt;pa1-&gt;num) &amp;&amp; (pa1-&gt;next==NULL)) pa1-&gt;next=pb1; return(ah); &#125;*/struct student *insert(struct student *ah,struct student *bh)&#123; struct student *pnew; pnew=ah; while(pnew-&gt;next!=NULL) &#123; pnew=pnew-&gt;next; &#125; pnew-&gt;next=bh; return(ah);&#125;struct student *px(struct student *abh,int sum)&#123; struct student *p,*p1,*p2,*p2pre; p=NULL; p1=p2=p2pre=abh; int count=1; while(count&lt;sum) &#123; p1=p2=p2pre=abh; while(p1-&gt;next!=NULL) &#123; p2pre=p2; p2=p1; p1=p1-&gt;next; if((p1-&gt;num)&lt;(p2-&gt;num)) &#123; if(abh==p2)abh=p1; else p2pre-&gt;next=p1; p2-&gt;next=p1-&gt;next; p1-&gt;next=p2; &#125; &#125; count++; &#125; return abh; &#125;void print(struct student *head) //输出函数 &#123;struct student *p; printf(&quot;There are %d records: \\n&quot;,sum); p=head; if (p !=NULL) do &#123;printf(&quot;%ld %d\\n&quot;,p-&gt;num,p-&gt;score); p=p-&gt;next; &#125;while (p !=NULL); &#125; 快速排序c语言1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;stdio.h&gt;void quicksort(int arry[],int L,int R)&#123; if(L&gt;=R) return ; int left=L,right=R; int pivot=arry[L]; while(left&lt;right) &#123; while(left&lt;right&amp;&amp;arry[right]&gt;=pivot) &#123;right--; &#125; //if(left&lt;right) arry[left]=arry[right]; while(left&lt;right&amp;&amp;arry[left]&lt;=pivot) &#123;left++; &#125; //if(left&lt;right) arry[right]=arry[left]; //if(left&gt;=right) //arry[left]=pivot; &#125; arry[left]=pivot; quicksort(arry,L,right-1); quicksort(arry,right+1,R);&#125;int main()&#123; int arry[9]; int i,j; for(i=0;i&lt;9;i++) &#123;printf(&quot;%dth:&quot;,i+1); scanf(&quot;%d&quot;,&amp;arry[i]); &#125; quicksort(arry,0,8); for(j=0;j&lt;9;j++) &#123;printf(&quot;%d &quot;,arry[j]); &#125; return 0;&#125; 反转排序java123456789101112131415161718192021222324public class Main&#123; public static void main(String []args)&#123; int arry[]=&#123;3,2,5,6,8,7&#125;; Main sorter=new Main(); sorter.sort(arry); &#125; public void sort(int[] array)&#123; int temp; int len=array.length; for(int i = 0;i&lt;len/2;i++)&#123; temp=array[i]; array[i]=array[len-1-i]; array[len-1-i]=temp; &#125; showArray(array); &#125; public void showArray(int[] aray)&#123; for(int x:aray)&#123; System.out.print(x ); &#125; &#125; &#125; 链表快速排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define LEN sizeof(struct student)struct student&#123; int num; int score; struct student* next;&#125;;struct student lista, listb;int n, sum = 0;int main()&#123; struct student* creat(void); struct student* insert(struct student*, struct student*); void print(struct student*); struct student* bianli(struct student* abh); void px(struct student* abh, struct student* abe); void swapnode(struct student* i, struct student* j); struct student* ahead, * bhead, * abh,*abe; printf(&quot;input list a:\\n&quot;); ahead = creat(); sum = sum + n; printf(&quot;input list b:\\n&quot;); bhead = creat(); sum = sum + n; abh = insert(ahead, bhead); abe = bianli(abh); px(abh, abe); print(abh); return 0;&#125;struct student* creat(void) //建立链表函数&#123; struct student* p1, * p2, * head; n = 0; p1 = p2 = (struct student*)malloc(LEN); printf(&quot;input number &amp; scores of student:\\n&quot;); printf(&quot;if number is 0,stop inputing.\\n&quot;); scanf(&quot;%ld,%d&quot;, &amp;p1-&gt;num, &amp;p1-&gt;score); head = NULL; while (p1-&gt;num != 0) &#123; n = n + 1; if (n == 1) head = p1; else p2-&gt;next = p1; p2 = p1; p1 = (struct student*)malloc(LEN); scanf(&quot;%ld,%d&quot;, &amp;p1-&gt;num, &amp;p1-&gt;score); &#125; p2-&gt;next = NULL; return(head);&#125;/*struct student *insert(struct student *ah,struct student *bh) //插入函数 &#123;struct student * pa1,* pa2,* pb1,* pb2; pa2=pa1=ah; pb2=pb1=bh; do &#123;while((pb1-&gt;num&gt;pa1-&gt;num) &amp;&amp; (pa1-&gt;next !=NULL)) &#123;pa2=pa1; pa1=pa1-&gt;next; &#125; if (pb1-&gt;num &lt;= pa1-&gt;num) &#123;if (ah==pa1) ah=pb1; else pa2-&gt;next=pb1; pb1=pb1-&gt;next; pb2-&gt;next=pa1; pa2=pb2; pb2=pb1; &#125; &#125;while ((pa1-&gt;next!=NULL) || (pa1==NULL &amp;&amp; pb1!=NULL)); if ((pb1!=NULL) &amp;&amp; (pb1-&gt;num&gt;pa1-&gt;num) &amp;&amp; (pa1-&gt;next==NULL)) pa1-&gt;next=pb1; return(ah); &#125;*/struct student* insert(struct student* ah, struct student* bh)&#123; struct student* pnew; pnew = ah; while (pnew-&gt;next != NULL) &#123; pnew = pnew-&gt;next; &#125; pnew-&gt;next = bh; return(ah);&#125;/*struct student* px(struct student* abh, int sum)&#123; struct student* p, * p1, * p2, * p2pre; p = NULL; p1 = p2 = p2pre = abh; int count = 1; while (count &lt; sum) &#123; p1 = p2 = p2pre = abh; while (p1-&gt;next != NULL) &#123; p2pre = p2; p2 = p1; p1 = p1-&gt;next; if ((p1-&gt;num) &lt; (p2-&gt;num)) &#123; if (abh == p2)abh = p1; else p2pre-&gt;next = p1; p2-&gt;next = p1-&gt;next; p1-&gt;next = p2; &#125; &#125; count++; &#125; return abh;&#125;*/struct student* bianli(struct student* abh)&#123; struct student* abe; abe = abh; while (abe-&gt;next != NULL) &#123; abe = abe-&gt;next; &#125; return abe;&#125;void px(struct student* abh, struct student* abe)&#123; if ((abe == abh) || (abh-&gt;next == NULL) || (abh == NULL)) return ; void swapnode(struct student* i, struct student* j); struct student* ipre, * i, * j; int pivot; ipre = abh; j=i = abh-&gt;next; pivot = abh-&gt;num; while (j != NULL) &#123; if (j-&gt;num &lt; pivot) &#123; swapnode(i, j); ipre=i; i=i-&gt;next; &#125; j=j-&gt;next; &#125; swapnode(abh, ipre); px(abh, ipre); px(i, abe); return ;&#125;void swapnode(struct student* i, struct student* j)&#123; int a, b; a = i-&gt;num; i-&gt;num = j-&gt;num; j-&gt;num = a; b = i-&gt;score; i-&gt;score = j-&gt;score; j-&gt;score = b;&#125;void print(struct student* head) //输出函数&#123; struct student* p; printf(&quot;There are %d records: \\n&quot;, sum); p = head; if (p != NULL) do &#123; printf(&quot;%ld %d\\n&quot;, p-&gt;num, p-&gt;score); p = p-&gt;next; &#125; while (p != NULL);&#125; 简单插入排序1 希尔排序法1 选择法排序c语言123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;int main()&#123; int i,j,k,n,m,max,t; //scanf(&quot;%d&quot;,&amp;n); int a[]=&#123;1,2,5,9,5&#125;; int len = sizeof(a)/sizeof(a[0]); // for(k=0;k&lt;=len;k++) //scanf(&quot;%d&quot;,a[k]); for(j=0;j&lt;len-1;j++) &#123;max=a[j]; for(i=j+1;i&lt;=len;i++) if(a[i]&gt;max) &#123; max=a[i]; t=a[j]; a[j]=a[i]; a[i]=t; &#125; &#125; for(k=0;k&lt;=len-1;k++) printf(&quot;%d&quot;,a[k]) ; return 0;&#125; java123456789101112131415161718192021222324252627282930public class Main&#123; public static void main(String []args)&#123; int arry[]=&#123;3,2,5,6,8,7&#125;; Main sorter=new Main(); sorter.sort(arry); &#125; public void sort(int[] array)&#123; int index; for(int i = 1;i&lt;array.length;i++)&#123; index=0; for(int k = 1;k&lt;=array.length-i;k++)&#123; if(array[k]&gt;array[index])&#123; index=k; &#125; &#125; int temp=array[array.length-i]; array[array.length-i]=array[index]; array[index]=temp; &#125; showArray(array); &#125; public void showArray(int[] aray)&#123; for(int x:aray)&#123; System.out.print(x ); &#125; &#125; &#125; 堆排序法1 双指针删除数组元素1234567891011121314Int return()&#123;Int slowp=0;Int fastp=0;For(fastp=0;fastp&lt;=numszie;fastp++)&#123;If(nums[fastp]!=val)Nums[slowp++]=nums[fastp];&#125;Return slowp;&#125; 123456789101112public int removeElement(int[] nums, int val) &#123; int slowp=0; for(int fastp=0;fastp&lt;nums.length;fastp++)&#123; if(nums[fastp]!=val)&#123; nums[slowp++]=nums[fastp]; &#125; &#125; return slowp; &#125; 数组平方排序123456789101112131415161718192021222324/** * Note: The returned array must be malloced, assume caller calls free(). */int* sortedSquares(int* nums, int numsSize, int* returnSize)&#123; *returnSize=numsSize; int k; int left=0; int right=numsSize-1; int* result=(int*)malloc(sizeof(int) * numsSize); for(k=numsSize-1;k&gt;=0;k--)&#123; int lsquare=nums[left]*nums[left]; int rsquare=nums[right]*nums[right]; if(rsquare&gt;lsquare)&#123; result[k]=rsquare; right--; &#125; else&#123; result[k]=lsquare; left++; &#125; &#125; return result;&#125; 123456789101112131415161718public int[] sortedSquares(int[] nums) &#123; int[] result =new int[nums.length]; int left=0; int right=nums.length-1; for(int k=nums.length-1;k&gt;=0;k--)&#123; int lsquare=nums[left]*nums[left]; int rqsuare=nums[right]*nums[right]; if(rqsuare&gt;lsquare) &#123; result[k] = rqsuare; right--; &#125; else &#123; result[k]=lsquare; left++; &#125; &#125; return result; &#125; 滑动窗口12345678910111213public int minSubArrayLen(int target, int[] nums) &#123; int left = 0; int sum = 0; int result = Integer.MAX_VALUE; for (int right = 0; right &lt; nums.length; right++) &#123; sum += nums[right]; while (sum &gt;= target) &#123; result = Math.min(result, right - left + 1); sum -= nums[left++]; &#125; &#125; return result == Integer.MAX_VALUE ? 0 : result; &#125; 迷宫12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/* * To change this template, choose Tools | Templates * and open the template in the editor. */package migong;/** * * @author Administrator */public class Main &#123; /** * @param args the command line arguments */ public static void main(String[] args) &#123; //绘制迷宫 int[][] map = new int[8][7]; //最上与最下s for (int i = 0; i &lt; 7; i++) &#123; map[0][i] = 1; map[7][i] = 1; &#125; //最左与最右 for (int i = 0; i &lt; 8; i++) &#123; map[i][0] = 1; map[i][6] = 1; &#125; //额外 map[3][1] = map[3][2] = 1; map[4][2] = map[5][2] = map[6][2] = 1; map[4][4] = map[5][4] = map[6][4] = 1; System.out.println(&quot;当前地图======&quot;); for (int i = 0; i &lt; map.length; i++) &#123; for (int j = 0; j &lt; map[i].length; j++) &#123; System.out.print(map[i][j] + &quot;&quot;); &#125; System.out.println(); &#125; //找路 T t1 = new T(); t1.findway(map, 1, 1); System.out.println(&quot;\\n======找路的情况如下======&quot;); for (int i = 0; i &lt; map.length; i++) &#123; for (int j = 0; j &lt; map[i].length; j++) &#123; System.out.print(map[i][j] + &quot;&quot;); &#125; System.out.println(); &#125; &#125;&#125;class T &#123; //初始位置(1,1) // 0表示可以走 1 表示障碍物 2表示可以走(通路)3走过但是死路 public boolean findway(int[][] map, int i, int j) &#123; if (map[6][5] == 2) &#123;//找到 return true; &#125; else &#123; if (map[i][j] == 0) &#123;//可以走没走过 map[i][j] = 2; if (findway(map, i + 1, j)) &#123; return true; &#125; else if (findway(map, i, j + 1)) &#123; return true; &#125; else if (findway(map, i - 1, j)) &#123; return true; &#125; else if (findway(map, i, j - 1)) &#123; return true; &#125; else &#123; map[i][j] = 3; return false; &#125; &#125; else &#123; return false; &#125; &#125; &#125;&#125;s","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]}],"categories":[{"name":"记录","slug":"记录","permalink":"http://example.com/categories/%E8%AE%B0%E5%BD%95/"},{"name":"-算法专题","slug":"算法专题","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/"},{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"记录","slug":"记录","permalink":"http://example.com/tags/%E8%AE%B0%E5%BD%95/"},{"name":"-算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]}