{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"链接","date":"2023-03-12T15:18:32.854Z","updated":"2023-03-12T15:18:32.854Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-09-20T08:55:20.574Z","updated":"2023-09-20T08:55:20.574Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"课程笔记/数理逻辑/作业一","date":"2023-09-19T10:05:38.970Z","updated":"2023-09-20T08:42:18.828Z","comments":true,"path":"2023/09/0ee89a660c45.html","link":"","permalink":"http://example.com/2023/09/0ee89a660c45.html","excerpt":"","text":"$\\phi$$\\Gamma$第1 次作业 (2023-09-18)Deadline：9 月25 日（周一）课前一、请用自己的语言简述如下记号的含义： 指赋值满足命题A，v^(A)&#x3D;T A为永真式，指对任何赋值v有v^(A)&#x3D;T 是语义层次的推理，$\\phi$为$\\Gamma$的语义结论，当且仅当前提$\\Gamma$描述的所有模型均满足结论$\\phi$，基于事实的推理4) 是语法层次的推理，前提$\\Gamma$可以推出结论$\\phi$，基于规则的推理 为一个矢列，$\\Gamma$为前件，$\\Delta$为后件，$\\Gamma$、$\\Delta$是命题的有穷集合 当有效时，可以记为 二、第一讲习题3(c)4.5(b)6.只证3(b)、3(f)8(e)11.13.三、饲养员老王的鸡被偷吃了，经侦查锁定了猫、狗、黄鼠狼三只嫌疑动物，并确认了以下三条线索：a：猫、狗、黄鼠狼中必有凶手；b：如果猫是凶手，那么狗不是凶手;dsc：如果黄鼠狼是凶手，那么猫也是凶手。（1）请列出所有可能的情况，并证明你的结论。（2）根据以上线索，是否可以推出“d：如果猫不是凶手，那么狗是凶手”？请作出判断，并给出一个语义证明。（3）如果根据上述线索能推出d，那么请给出一个语法证明。","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"数理逻辑","slug":"课程笔记/数理逻辑","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91/"}],"tags":[]},{"title":"","slug":"课程笔记/R/实验一/实验一","date":"2023-09-19T01:43:21.246Z","updated":"2023-09-20T08:42:18.846Z","comments":true,"path":"2023/09/42d3656aee50.html","link":"","permalink":"http://example.com/2023/09/42d3656aee50.html","excerpt":"","text":"《商务智能与R 语言》课程作业一学号：2120211724 姓名：周泽安问题1：输入数值型向量，并把它转化为字符型；输入逻辑型向量，并把它转化为数值型 问题2：随机产生一个包括负数和正数的向量(整数），负数采用“1-负数”替代，即-3变成4，正数用“1+正数”替代，即2变成3 12345678910111213# 生成一个包含正数和负数的随机向量# 向量的长度n &lt;- 10 # 生成从n个从-n到n的随机数random_vector &lt;- sample(-n:n, n, replace = TRUE)# 替代负数和正数replaced_vector &lt;- ifelse(random_vector &lt; 0, 1 - random_vector, 1 + random_vector)# 打印生成和替代后的向量print(random_vector)print(replaced_vector) 问题3：随机产生一个包括负数和正数的向量(整数），负数用NA替代，再将NA用0替代 问题4：产生随机数，形成矩阵，负的1-该数，正的1加该数 12345678910111213141516# 设置矩阵的行数和列数rows &lt;- 3cols &lt;- 4# 生成随机数的矩阵random_matrix &lt;- matrix(runif(rows * cols, -10, 10), nrow = rows, ncol = cols)# 打印生成矩阵print(random_matrix)# 替代负数和正数random_matrix[random_matrix &lt; 0] &lt;- 1 - random_matrix[random_matrix &lt; 0]random_matrix[random_matrix &gt;= 0] &lt;- 1 + random_matrix[random_matrix &gt;= 0]# 打印替代后的矩阵print(random_matrix) 问题5：如何取矩阵上三角和下三角矩阵 12345678910111213# 创建一个示例矩阵 exmatrix &lt;- matrix(1:9, nrow = 3) # 打印矩阵print(exmatrix)# 提取上三角矩阵 upper_triangle &lt;- exmatrix[upper.tri(exmatrix)] # 打印上三角矩阵 print(upper_triangle)# 提取下三角矩阵lower_triangle &lt;- exmatrix[lower.tri(exmatrix)]# 打印下三角矩阵print(lower_triangle) 问题6：产生随机数（有正有负），形成矩阵，矩阵中小于0的用NA替代 123456789101112131415# 设置矩阵的行数和列数rows &lt;- 3cols &lt;- 4# 生成随机数的矩阵random_matrix &lt;- matrix(runif(rows * cols, -10, 10), nrow = rows, ncol = cols)# 打印生成矩阵print(random_matrix)# NA替代负数random_matrix[random_matrix &lt; 0] &lt;- NA# 打印替代后的矩阵print(random_matrix) 在过去的两年中，我经历了重要的成长和学习过程，我愈发坚定了自己的政治信仰，更加深入地理解了党的基本路线和方针政策，这不仅强化了我的责任感，也使我更加坚定了为人民服务的信念。 学习方面，我积极参与了各类学术竞赛和课外活动，通过不断的学习和实践，提高了自己的知识水平和解决问题的能力，同时也锤炼了团队合作的技巧。 在集体活动方面，我参与了班级和学校组织的各种活动，并担任了一些关键职务。这不仅锻炼了我的组织和领导能力，还增进了我与同学们的友情和合作关系。 社会实践方面，我积极参与了一些志愿者活动，为社区和学校做出了一些贡献，这让我体验到了奉献的喜悦，并培养了更深的社会责任感。 关于特长爱好，我培养了一些兴趣，如绘画和音乐，这不仅丰富了我的精神生活，还提升了我的创造力和审美能力。 在组织管理方面，我积极参与了学生会和其他组织的管理工作，这让我学会了协调和组织各类活动，提高了自己的领导和管理技巧。 最后，身体状况方面，我注重体育锻炼，保持了良好的身体健康，这有助于我更好地应对各种学习和生活的挑战。 综上所述，这两年的成长过程中，我在各个方面都有了进步，这些经验和收获将继续激励我，为更好地为党和人民事业贡献力量而不懈努力。","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"R","slug":"课程笔记/R","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/R/"},{"name":"实验一","slug":"课程笔记/R/实验一","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/R/%E5%AE%9E%E9%AA%8C%E4%B8%80/"}],"tags":[]},{"title":"","slug":"工具记录/软件工程基础","date":"2023-09-18T06:17:45.982Z","updated":"2023-09-20T08:42:18.828Z","comments":true,"path":"2023/09/ae144853cad2.html","link":"","permalink":"http://example.com/2023/09/ae144853cad2.html","excerpt":"","text":"第一章 软件工程概述1.1软件工程的发展历程1.1.1软件危机软件危机指在计算机软件的开发和维护工程中所遇到的一系列严重问题严重问题表现方面: 软件开发进度和成本难以控制 软件产品难以满足用户需求 软件质量难以得到保证 软件产品难以进行维护 软件的文档资料难以管理 软件产品的生产效率难以得到提高 1.1.2软件危机原因 对软件开发缺乏正确的理论指导 软件人员与用户缺乏充分的交流 对软件开发过程缺乏整体认识 对软件产品缺乏有效一致的质量评价 1.1.3 软件的本质特性 复杂性 一致性 可变性 不可见性 1.2 软件工程的概念1.2.1 软件工程的定义专注于规划、设计、开发、测试、维护和管理软件系统的过程实现满足用户要求的软件产品的定义、开发、发布和维护的过程或进行研究的学科 1.2.2 软件工程的目标 降低开发成本 完成需求中各项功能与性能指标 软件易于修改，软件机构易于理解 降低维护费用 按时完成开发与交付 1.2.4 软件工程的基本原理 用分阶段的生命周期计划严格管理 坚持进行阶段评审 执行严格的产品质量控制 采用现代化程序设计技术 结果应能清楚地审查 开发人员应少而精 承认不断改进软件工程的必要性 1.3 软件与软件过程1.3.1 软件的概念软件的定义:程序，数据和文档的有机组合软件的实现是一个从现实问题域（输入）到信息域（输出）的过程，此过程包括程序、数据、文档以及他们之间的联系。 软件的特点: 软件是逻辑实体而非物理实体 软件是智力产品，生产的过程主要集中在研发上 软件永不磨损，但它会退化，直至被弃用 软件开发远未达到软件工程目标提及的产业化生产 软件越来越复杂，今后将会更加复杂 1.3.3 软件生命周期 可行性分析与计划阶段 需求分析阶段 设计阶段 实现阶段 测试阶段 运行和维护阶段 1.4软件过程模型1.4.1瀑布模型瀑布模型，也称软件生存周期模型。优点：（1）在软件工程中占有重要地位，它提供了软件开发的基本框架，这比依靠“个人技艺”开发软件好得多。（2）有利于大型软件开发过程中人员的组织、管理，有利于软件开发方法和工具的研究与使用，从而提高了大型软件项目开发的质量和效率。缺点：（1）阶段的划分完全固定，阶段之间产生大量的文档，极大地增加了工作量；（2）由于开发模型是线性的用户只有等到整个过程的末期才能见到开发成果，从而增加了开发的风险；（3）早期的错误可能要等到开发后期的测试阶段才能发现，进而带来严重后果。适用：（1）在开发时间内需求没有或很少变化；（2）分析设计人员应对应用领域很熟悉；（3）低风险项目（对目标、环境很熟悉）；（4）用户使用环境很稳定；用户除提出需求以外，很少参与开发工作。 1.4.2原型模型优点：（1）可以得到比较良好的需求定义，容易适应需求的变化；（2）有利于开发与培训的同步；（3）开发费用低、开发周期短且对用户更友好。缺点：（1）客户与开发者对原型理解不同；（2） 准确的原型设计比较困难；（3） 不利于开发人员的创新。适用：（1）对所开发的领域比较熟悉而且有快速的原型开发工具；（2）项目招投标时，可以以原型模型作为软件的开发模型；（3）进行产品移植或升级时，或对已有产品原型进行客户化工作时，原型模型是非常适合的。 1.4.3增量模型优点：（1）采用增量模型的优点是人员分配灵活，刚开始不用投入大量人力资源；（2）如果核心产品很受欢迎，则可增加人力实现下一个增量；（3）可先发布部分功能给客户，对客户起到镇静剂的作用。缺点：（1）并行开发构件有可能遇到不能集成的风险，软件必须具备开放式的体系结构；（2）增量模型的灵活性可以使其适应这种变化的能力大大优于瀑布模型和快速原型模型，但也很容易退化为边做边改模型，从而是软件过程的控制失去整体性。适用：（1）进行已有产品升级或新版本开发，增量模型是非常适合的；（2）对完成期限严格要求的产品，可以使用增量模型；（3）对所开发的领域比较熟悉而且已有原型系统，增量模型也是非常适合的。 1.4.4螺旋模型优点：（1）设计上的灵活性,可以在项目的各个阶段进行变更；（2）以小的分段来构建大型系统,使成本计算变得简单容易；（3）客户始终参与每个阶段的开发,保证了项目不偏离正确方向以及项目的可控性；（4） 随着项目推进,客户始终掌握项目的最新信息 , 从而他或她能够和管理层有效地交互。缺点：（1）采用螺旋模型需要具有相当丰富的风险评估经验和专门知识，在风险较大的项目开发中，如果未能够及时标识风险，势必造成重大损失；（2）过多的迭代次数会增加开发成本，延迟提交时间。 适用： 只适合于大规模的软件项目 1.4.5喷泉模型优点： 喷泉模型允许灵活的人员分配，起初不需要投入大量人力资源。 如果核心产品概念受欢迎，可以增加人力资源以实现下一个喷泉。 具有开放式的体系结构，允许并行开发构件。缺点： 并行开发构件可能面临无法集成的风险，需要具备开放式体系结构。 喷泉模型的灵活性可能导致软件过程的控制失去整体性，可能退化为边做边改模型。适用： 适用于已有产品的升级或新版本开发。 对于有严格完成期限要求的产品，可以采用喷泉模型。 在开发领域相对熟悉且已有原型系统的情况下，也适用于喷泉模型。 1.4.6敏捷过程模型优点： 敏捷过程模型强调快速交付和响应变化，适应性强。 可以根据需求不断迭代和改进产品，满足客户的实际需求。 高度合作和沟通，促进团队协作和客户参与。缺点： 对于某些大型项目或要求高度规范的项目，敏捷过程可能不够适用。 需要客户积极参与和不断提供反馈，否则可能导致项目进展不稳定。 需要团队具备高度的自组织和自管理能力。适用： 适用于需要快速交付和频繁变更的项目。 对于客户需求不断演化的项目，敏捷过程模型是非常适合的选择。 需要高度合作和团队协作的项目也适合采用敏捷过程模型。 1.4.7 渐进交付迭代模型优点： 分阶段交付： 渐进交付迭代模型允许将软件系统分成多个可交付的阶段，每个阶段都能够产生部分可用的系统，从而满足客户部分需求。 逐步完善： 通过迭代的方式，每个迭代周期都可以改进和完善之前版本的软件，使其更符合用户需求和质量标准。 风险管理： 通过将项目分成多个迭代，可以更好地管理和控制项目风险，及早发现和解决问题。 客户参与： 客户可以在每个迭代周期中查看和评估部分可用的系统，提供反馈，确保最终的软件产品符合其期望。缺点： 增加复杂性： 管理多个迭代周期和交付阶段可能增加了项目的管理和协调复杂性。 时间和成本： 如果不恰当地规划迭代周期，可能会导致项目超出预算或超过时间表。 需求变化： 随着迭代的进行，客户需求可能会发生变化，需要灵活应对变更，否则可能导致范围膨胀。适用： 大型项目： 渐进交付迭代模型适用于大型和复杂的项目，可以将项目分成多个管理和开发容易控制的部分。 客户需求不确定： 当客户需求不够清晰或可能会变化时，采用迭代方式可以更好地适应变化。 风险管理重要： 当项目中存在重要的风险，需要及早发现和解决时，渐进交付迭代模型是一种合适的选择。 需要快速交付部分功能： 如果需要在项目的早期阶段交付部分功能以满足紧急需求，这种模型也很有用。 1.4.10 软件过程模型的比较 1.5 软件开发方法1.5.1 结构化开发方法首先提出用结构化分析（SA）对软件进行需求分析之后用结构化设计（SD）方法进行系统设计最后用结构化编程（SP）实现软件 提高了软件开发的效率和质量，降低了错误率 1.5.2 面对对象开发方法面对对象&#x3D;对象+类+继承+消息 1.6 案例描述基本 书上基本功能 提高 自动匹配自动筛选自动调剂 另选难度更大的 基本 书本基本功能 提高 考试过程 提交答卷 改卷 手动 自动 分配试卷 成绩分析 平均分统计 分数段统计 知识点掌握分析 考试 选择考试学员 题库选择 配置试卷 组卷 图表 自动链接相关知识点 试题库 判断 单选 多选 按章节 按难度 学员管理 注册 主动导入 同义词近义词反义词数据库","categories":[{"name":"工具记录","slug":"工具记录","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7%E8%AE%B0%E5%BD%95/"}],"tags":[]},{"title":"","slug":"工具记录/普通话/普通话","date":"2023-09-15T15:03:35.952Z","updated":"2023-09-20T08:42:18.829Z","comments":true,"path":"2023/09/55322f34c6bd.html","link":"","permalink":"http://example.com/2023/09/55322f34c6bd.html","excerpt":"","text":"资料(10 封私信 &#x2F; 29 条消息) 普通话考试之前要准备些什么？ - 知乎 (zhihu.com)题型普通话考试题型内容及分值（四部分） - 知乎 (zhihu.com) 60篇重点60二噁英(化合物): èr è yīnɡ氟fú利lì昂ánɡ土tǔ地dì板bǎn结jié 59迸溅：beng四声 jian四声枯槐：ku一声 huai二声盘虬卧龙：pan二声 qiu二声 wo四声 long二声 58涤dí清qīnɡ 57田tián垄lǒnɡ阡qiān陌mò踟chí蹰chú 54张zhānɡ鹗è 48丫yā枝zhī泊bó 42绶shòu带dài 40金jīn鬃zōnɡ毛máo 38岱dài宗zōnɡ坊fánɡ 37澄chénɡ明mínɡ 36池chí沼zhǎo 35圭ɡuī土tǔ地dì 32乌wù桕jiù 29藏cànɡ经jīnɡ洞dònɡ帛bó画huà 25皱zhòu缬xié着zhe尘chén滓zǐ挹yì你nǐ以yǐ为wéi眼yǎn 24唐tánɡ招zhāo提tí寺sì 22春chūn水shuǐ淙cónɡ淙cónɡ悭qiān吝lìn哺bǔ育 18割ɡē刈yì朝zhāo霞xiá 17一yī髻jì儿ér 16黑黢qū黢qū 13曝bù晒shài 11盘pán踞jù 10短duǎn柬jiǎn擤xǐnɡ 19削xiāo得de很hěn薄báo的de篾miè扎zā飘piāo荡dànɡ游yóu弋yì 3 黑hēi 黝yǒu 黝yǒu浣huàn 纱shā 捶chuí 布bù槐huái 阴yīn绿lǜ 苔tǎi 1桠yā 枝zhī晕yùn 圈quan婆pó 娑suō虬qiú 枝zhī 我的愿望&#x2F;理想我喜爱的职业引子每个人都有着属于自己的理想，这份理想或许就是支撑着我们一路向前的动力，而我的理想是当一名人民教师 产生原因我喜欢当人民教师有如下几个原因 一是我觉得人民教师这个职业是圣神的是伟大的，教师把自己的毕生所学传授给学生们，让学生们沐浴在知识的海洋中茁壮成长，这一传承的过程十分伟大并且具有社会价值 其次，出于自己儿时的私心，当人民教师可以有许多的业余时间，我可以用这些业余时间或提升自己或做自己想做的事情 工作稳定，父母期望 努力过程高考择校，做家教，做演讲，打辩论 结果经过努力过程，哪些方面得到提升：专业技能、交际能力 感悟理想是我前进的动力，就算之后实现了人民教师，依然还是会为了成为一名更加优秀的人民教师奋斗 我的学习生活引子我们的一生可以说都离不开学习，学习不光是坐在课堂上听老师讲课，更是平时生活中的练习、阅读以及思考，而今天我要讲的是我学习素描的学习生活 原因为什么学习素描，从排斥兴趣辅导班，到看到写生的人引起学习兴趣 学习过程兴趣辅导班的学习、平时在家的练习、外出的写生、相关书籍的阅读 感悟学习是永无止境的，对我来说，素描更是如此，一开始的线条练习，到形体、再到阴影，最后哪怕掌握了所有技巧，依然要学习感情的表达绘画，我会继续坚持学习下去。 我的成长之路引子相信每个人都有着属于自己独特的成长之路，与回忆，而我的成长之路，给我带来最宝贵成长经验的大概就是童年发生的一些事情经历把童年经历重复一遍总结以上就是我最的成长之路，童年的那件事带给了我太多教训与成长，让我以后。。。 童年的记忆引子每个人都有属于自己独特的童年记忆，或是开心，或是遗憾，但毫无疑问，这些多样的童年记忆都是我们最难忘，最宝贵的童年记忆 经历被爸妈强迫选择兴趣培养班，在选择的途中，发现写生的画家，从此种下一颗梦想的种子，开始素描的学习、平时在家的练习、外出的写生、相关书籍的阅读但是长大后，看见小提琴、吉他他人这些可以表现的兴趣，才发现小时候父母的话是如此对， 感悟小时候爸妈可能做法让我们稍有排斥，但本意都是为了我们好，未来我会主动尝试不同的爱好，兴趣。 我尊敬的人引子相信在每个人的生活中都有着让自己尊敬的那位，他的某些行为令你触动，并且可能深深地影响着你，而我最尊敬的人是我的母亲 原因带给我的影响感悟12345678910111213我尊敬的人：我的母亲在我的生活中，有一个我尊敬的人，她就是我的母亲。母亲是我生命中最重要的支持者和导师，她的坚韧、善良和无私的品质一直深深地影响着我，塑造了我成为今天的自己。母亲的坚韧是我最令人钦佩的品质之一。她在我成长的过程中经历了各种挫折和困难，但从未放弃过。无论面临多大的困境，她都会坚持不懈地努力工作，为了我和家庭的幸福而奋斗。她的毅力和决心教育了我坚韧的重要性，鼓励我在面对挑战时坚持不拔。母亲的善良也深深地感染了我。她总是乐于助人，对周围的人充满关爱和理解。她教导我要善待他人，尊重每个人的感受，努力让世界变得更美好。她的善良不仅体现在她的言行举止中，还体现在她对待生活中各种不幸和挫折的态度上。她总是告诉我，宽容和善良是生活中最宝贵的财富。母亲的无私也是我尊敬她的原因之一。她为了我和家庭，常常牺牲自己的个人利益。她教育我要有爱心和慷慨的心，愿意为他人做出牺牲。她的无私行为是我为人处世的楷模，也启发了我参与志愿活动和回馈社会的决心。与母亲的相处也教会了我许多重要的价值观。她常常鼓励我追求知识，强调教育的重要性。她教导我要诚实守信，坚守原则，不轻易妥协。她还鼓励我积极追求梦想，相信自己的能力。母亲是我人生导师的典范，她的言传身教一直激励着我不断成长和进步。母亲不仅是我尊敬的人，也是我永远的榜样。她的坚韧、善良和无私一直鼓舞着我追求卓越，成为一个更好的人。我深知母亲的教诲和爱是我生命中最宝贵的财富，我会一直珍惜并传承她所教导的价值观。在我心中，母亲永远是我尊敬和崇敬的人，她的影响将伴随我一生。 我的朋友经历初中，一起上小学，失意的时候互相安慰，去他家吃饭高中，经常起诉遇到的困难，一起去旅游（爬山）大学，一座城市，一起探讨 谈谈卫生与健康 背引言：卫生与健康是我们生活中至关重要的方面，它们直接影响着我们的生活质量和长寿。在这篇文章中，我们将深入探讨卫生与健康的主题，强调它们在我们日常生活中的至关重要性。 卫生习惯：良好的卫生习惯是维护健康的第一步。定期洗手、保持个人卫生、保持环境清洁都是预防传染病的关键。此外，正确使用口罩和遵守基本卫生规定也可以降低疾病传播的风险。 营养与健康：饮食对我们的健康有着深远的影响。均衡的饮食提供身体所需的营养素，增强免疫系统，降低慢性疾病的风险。建议多吃水果、蔬菜、全麦食品和蛋白质，同时限制糖分和饱和脂肪的摄入。 锻炼与健康：体育锻炼不仅有助于维持健康的体重，还可以增强心肺功能、改善心理健康，并降低慢性病的风险。每天至少进行30分钟的中等强度运动可以带来许多益处。 心理健康：心理健康同样重要。应对压力、焦虑和抑郁至关重要。与亲朋好友建立良好的社交联系，学会放松和应对挑战，可以提高心理健康水平。 预防疾病：定期体检和接种疫苗是预防疾病的关键步骤。早期发现和治疗疾病可以提高治愈率，降低医疗费用。 结论：卫生与健康是我们生活中不可或缺的一部分，它们直接关系到我们的生活质量和寿命。通过培养良好的卫生习惯、健康的饮食、体育锻炼以及积极维护心理健康，我们可以过上更加健康、幸福的生活。因此，让我们共同努力，将卫生与健康放在生活的首要位置，以实现更长寿、更幸福的未来。 卫生对健康的重要性健康的生活范式对身体健康的重要性健康饮食适度锻炼充足睡眠减轻压力 医疗保健的重要性定期检查，遵医嘱 12345678910111213谈谈卫生与健康卫生与健康是我们生活中至关重要的方面，它们直接关系到我们的生活质量和幸福。良好的卫生习惯和健康生活方式对于预防疾病、延长寿命以及提高生活质量都具有至关重要的作用。首先，卫生对于健康至关重要。保持身体清洁和环境卫生可以减少细菌和病毒的传播，降低感染疾病的风险。定期洗手、保持口腔卫生、保持食品安全等都是预防疾病的基本措施。此外，保持家庭和工作场所的清洁也有助于创造一个健康的生活环境。其次，健康生活方式对于维护身体健康至关重要。健康饮食、适度锻炼、充足睡眠和减轻压力都是保持身体健康的关键。均衡的饮食可以提供身体所需的营养，增强免疫系统，预防慢性疾病。适度的体育锻炼可以增强心血管健康、减轻体重、提高精神状态。足够的睡眠有助于恢复体力和促进大脑功能。减轻压力可以降低心理健康问题的风险，如焦虑和抑郁。此外，及时的医疗保健也是维护健康的重要部分。定期体检和医疗检查可以帮助早期发现潜在的健康问题，从而及时采取措施。遵医嘱服药、接种疫苗、定期检测生命体征都是保持健康的关键步骤。卫生与健康也与社会公平和全球公共卫生密切相关。不同社会群体之间的卫生差距可能导致健康不平等。因此，政府和社会应该致力于提高卫生保健的可及性和公平性，确保每个人都能享受到健康的权利。总之，卫生与健康是我们生活中不可或缺的重要组成部分。通过良好的卫生习惯和健康生活方式，我们可以预防疾病，延长寿命，提高生活质量。因此，我们每个人都应该重视卫生与健康，将其作为生活的首要任务，为自己和社会的健康作出积极的贡献。 我的假日生活我的业余生活引子假期大概是人们最憧憬与喜爱的吧，我也不例外，短到两天的周末，长到两个月的暑假生活，统统都是我的最爱，我的业余生活可谓是丰富多彩，下面就让我来展开讲讲。介绍一天我的业余生活大体可看成以下几部分组成一是学习专业技能的学习…除了专业技能的学习，当然还包括一些兴趣爱好的学习，比如素描…二是运动约着三两好友打篮球当然认识新朋友也是一大乐趣，一两场球就会快速熟络三是家人除了学习与运动，我还会抽时间陪伴我的家人，一起去逛古镇，或是商场，不论玩什么，与家人的沟通十分开心…总结我的业余生活整体是丰富多彩的，除了学习还运动，更是陪伴了家人。。。怪不得我总是觉得假期生活这么快呢 我喜欢的季节（或天气）引子谈到喜欢的季节，相信每个人都有属于自己的答案与理由。有人喜欢春的草长莺飞，有人喜欢夏的骄阳似火，有人喜欢秋的天高气爽，有的人喜欢冬的银装素裹，而我则喜欢尤其钟爱夏日的时光。原因一是夏天对我都独特之处，小时候每年夏天都会回老家，乡下的夏日可以说一直是我的白月光，和爷爷一起下田，和朋友的追逐打闹，小溪嬉戏，这些挥之不去的记忆一直埋藏于我的心底，让我对夏天产生别样的情愫二是夏天可以尽情的挥洒汗水，约上三三两两的伙伴相约傍晚的篮球场，挥洒汗水都感觉令我着迷，认识新朋友三是夏天一般都在假期，可以赶超总结以上就是我喜欢夏天的原因，不论以后怎样，我想夏天发生的点点滴滴一定会成为我最宝贵的记忆。。。 我和体育引子体育可以说已经是我生活中必不可少的一部分了，我所喜爱的体育生活包括羽毛球、篮球、跑步等等，而我接触到这些运动并且从掌握到熟练最后爱上他们，都有一些要感谢的人原因经历先是羽毛球，我从小是一个比较内向的人，初中上体育课时，老师让同学们自由活动，大家都三三两两的分散运动去了，有喜欢踢足球的，有喜欢打篮球的，还有喜欢打兵乓球的，而当时的我不仅内向而且没有一项擅长的运动，这时一位同学发现了我的窘迫，便拉起我的手邀请我一起去打羽毛球，教我，陪我聊天，之后成了形影不离的朋友，哪怕毕业了也会一起约着打球再是篮球，我高中的班级大部分男生都喜欢打篮球，我想要融进去，便也在一旁自己练习，这时班级里一个打的很棒的人主动想和我一起玩，之后便一起打篮球，也成为了很好的朋友跑步则是受大学一起打篮球的伙伴的影响，养成了每天跑步四公里的习惯，跑完的感受，是毅力的锻炼总结体育可以说已经是我不可分离的一部分了，带给了我太多好处，比如健康，朋友，毅力。。。 我的家乡（或熟悉的地方）引子相信每个人的内心深处都有着独属于家乡的珍贵回忆，这是我们宝贵的记忆更是我们宝贵的财富，人的一生就像风筝，不论我们身处何地，总有一根线在牵引着我们，而线的另一头就是我们的家乡。介绍家乡与一些回忆我都家乡位处乡下，是一片大概只有三四十户的小乡村，四周种满了水稻，是一片生长在田野里的乡村，我很喜爱我的家乡，每当假期回到这都会有一种与世隔绝的感觉，倘若你有心事，到田野里走上一遭，不论什么烦恼都会烟消云散了，由于只有四十户人家，家家之间都尤为的熟络，走在哪都像回家了一般，饭点了家家都会招呼你去他家吃点呢，很是亲切 而有关家乡，我另一个宝贵的记忆是关于爷爷的，小时候爷爷带我长大，去下田，抓蚂蚱，赶公鸡，赶集，和爷爷彻夜长谈，就算现在回去也会和爷爷一起睡，谈天说地 总结家乡是我们最熟悉的地方，但又是我们这些离开家乡的人最向往的地方，携带着对家乡的思念，让我有动力走下去，让爷爷骄傲。 我向往的地方引子每个人都有自己向往的地方，或是宜居的城市，或是美丽的度假圣地，而对我来说，最令我向往的却是我的家乡，我无时不刻都无法隐藏我对家乡的思念，人的一生就像风筝，不论我们身处何地，总有一根线在牵引着我们，而线的另一头就是我们的家乡。介绍家乡与一些回忆我都家乡位处乡下，是一片大概只有三四十户的小乡村，四周种满了水稻，是一片生长在田野里的乡村，我很喜爱我的家乡，每当假期回到这都会有一种与世隔绝的感觉，倘若你有心事，到田野里走上一遭，不论什么烦恼都会烟消云散了，由于只有四十户人家，家家之间都尤为的熟络，走在哪都像回家了一般，饭点了家家都会招呼你去他家吃点呢，很是亲切 而有关家乡，我另一个宝贵的记忆，让我向往的是因为我的爷爷，小时候爷爷带我长大，去下田，抓蚂蚱，赶公鸡，赶集，和爷爷彻夜长谈，就算现在回去也会和爷爷一起睡，谈天说地 总结家乡是我们最熟悉的地方，但又是我们这些离开家乡的人最向往的地方，携带着对家乡的思念，让我有动力走下去，让爷爷骄傲。 谈谈美食引子相信有不少人和我一样，对美食没有一点抵抗力，而我也相信，对于和我一样喜欢美食的吃货们来说，不仅仅喜欢吃，更喜欢钻研美食，自己动手制作美食，因为对我来说，自己做的不论如何都是美味的制作美食的种类可谓是数不胜数，可以是高档餐厅里的美味佳肴，也可以是家里的每一道平常的菜品，令我影响最深的一道美食是白菜肥牛千层锅，这道美食是我亲手做给家里人吃的，当时因为疫情原因，妈妈在卧室隔离，不能给家里人做饭，于是热衷美食的我准备大展手脚一番准备工作白菜、肥牛、金针菇、砂锅、调味料（生抽，老抽，盐）过程金针菇打底、白菜叠肥牛呈圈形摆放小火慢炖结果爸妈都特别喜欢，因为这道菜吃了两碗饭呢时间不够加上西瓜汤圆、布丁总结美食是一种让人愉悦的食物，他不一定多贵，不一定多好吃，但是他肯定带给了我们独特的宝贵的回忆，在品尝美食时可以忘记很多烦恼 我所在的集体（学校、机关、公司等）引子人是具有社会属性的，不论我们想不想，我们总是生活在集体之中，或是学校班级、或是公司，甚至是小组也算是集体，而我生活在一个令我感到温暖的集体班级之中原因向上一起参加各种比赛温暖受伤被照顾团结打班赛总结我很珍惜，这个集体，给我带来了很多成长，感悟，我也要。。。付出 我喜爱的文学艺术形式 背123456789101112131415我喜爱的文学艺术形式：音乐音乐是一种极富情感和创造力的文学艺术形式，通过声音、旋律和节奏，能够深刻地触动人心，传达情感、故事和思想。音乐是我生活中不可或缺的一部分，对我来说，它不仅是一种艺术，更是一种灵魂的滋养。首先，音乐具有强大的情感表达能力。不同的音乐风格和曲调可以传递各种情感，从欢乐和兴奋到忧郁和伤感，音乐可以让人们在情感世界中流连忘返。一首动听的音乐可以让人心情愉悦，也可以在沮丧时给予安慰和慰籍。其次，音乐是一种跨越文化和语言的沟通方式。无论我们来自哪里，我们都能够欣赏和理解音乐的美妙。音乐能够连接不同文化和背景的人，让我们感受到世界的多样性和丰富性。音乐也有助于提高集中力和创造力。很多人发现，在听音乐的时候，他们更容易集中注意力，提高工作效率。此外，音乐也能够启发创造力，让人们产生新的想法和灵感。另外，音乐也有着独特的社交和文化价值。音乐会和音乐节汇聚了人们，创造了共鸣和共享的机会。音乐还扮演着文化传承的角色，传递着历史、传统和价值观。最后，音乐也有着医疗和心理健康的益处。许多研究表明，音乐有助于减轻焦虑、降低压力、促进睡眠和提高情绪。音乐治疗也被广泛用于帮助人们应对心理健康问题。总之，音乐是一种令人着迷的文学艺术形式，它通过声音和旋律创造了美妙的情感体验，连接了不同的文化和背景，启发了创造力，促进了社交交流，甚至对心理健康有益。无论是聆听还是创作音乐，音乐都是一门美妙的艺术，丰富了我们的生活，使我们更加感知世界的美好。 1234567我喜爱的文学艺术形式：绘画绘画是一种极富创造力和表现力的文学艺术形式，它通过色彩、线条和形状的组合，传达出艺术家内心深处的思想、情感和观点。我对绘画的热爱源自它的无限可能性和对美的探索。绘画能够以各种形式展现，包括油画、水彩画、素描、雕塑等等。每种形式都有其独特的美和表现力，能够引发观者的共鸣和思考。绘画也是一种极具个性和风格的艺术形式。不同的艺术家有着不同的创作方式和审美观，因此他们的作品各具特色。从印象派的色彩斑斓到抽象表现主义的抽象构图，绘画的多样性让人们可以在艺术作品中发现无限的美。除了艺术家的创作，观者在欣赏绘画时也可以自由地赋予作品各种不同的解读和情感。每个人都可以从一幅画中找到自己的共鸣点，这种主观性的体验使绘画更加丰富和有趣。最重要的是，绘画具有深刻的历史和文化背景。通过研究不同时期和地区的绘画作品，我们可以了解到不同文化的表达方式和价值观。绘画作为一种跨越时空的文化语言，连接着人类的历史和情感。总之，绘画是我喜爱的文学艺术形式，因为它展示了无限的创造力和表现力，能够触发深层次的情感和思考。绘画丰富了我们的生活，让我们更加敏感和欣赏世界的美。无论是欣赏艺术家的作品还是自己尝试创作，绘画都是一种独特而有价值的艺术形式。 我爱的动物 背引言：我一直以来都对大自然中的奇妙生灵充满着浓厚的兴趣，但有一种动物一直深深地吸引着我，那就是北极熊。在接下来的文章中，我将分享我对北极熊的喜爱以及对它们的深入了解。 生活习性：北极熊是北极地区的主要居民，它们生活在世界上最寒冷的环境之一。这些动物经常漫步在冰雪覆盖的地区，它们是出色的游泳者，并可以长时间在寒冷的水中游弋。北极熊主要以海豹为食，这使得它们成为极端环境中的顶级捕食者。 特殊的生理特征：北极熊的外貌令人着迷，它们拥有浓密的白色皮毛，这不仅提供了隔绝寒冷的作用，还使它们在雪地中更容易捕猎。它们的大爪子和强壮的体格使其成为独一无二的生物。另一个令人惊叹的特征是它们的皮肤是黑色的，这有助于吸收阳光的热量。 文化和象征意义：在北极地区的一些文化中，北极熊被视为神圣的动物，与自然界的平衡和生存密切相关。它们还在当地的传说和故事中扮演着重要的角色，传达着关于生存、坚韧和智慧的寓意。 保护问题：然而，北极熊面临着严重的生存威胁，主要是由于气候变化和冰川融化导致的栖息地丧失。它们也受到了捕猎和污染的影响。为了保护这些令人惊叹的生物，国际社会采取了一系列措施，包括限制捕猎和减少温室气体排放。 结论：北极熊不仅是令人惊叹的生物，也是北极环境中的关键成员。我之所以如此喜爱它们，是因为它们的生活方式、适应性和文化象征意义都让我深受启发。然而，我们必须共同努力，确保它们的生存环境不再受到威胁，以便它们的未来代代相传。北极熊是我们珍贵的地球伙伴之一，我们有责任保护它们，以保护我们自己的星球。 12345678910111213我喜爱的动物：熊猫在世界各种各样的动物中，熊猫一直是我最喜欢的动物之一。熊猫以其可爱的外貌、温和的性格和珍稀的身份而闻名于世，它们具有许多令人喜爱的特点，深深吸引着我。首先，熊猫的可爱外貌让人难以抗拒。它们有着圆圆的大眼睛、黑白相间的柔软毛发和圆润的脸庞，看上去就像是一只大大的毛绒绒的玩偶。每当看到熊猫的照片或视频，我都不禁会心一笑，感到心情愉悦。其次，熊猫的性格温和而和善。它们通常是悠闲、宁静的动物，不容易发火或攻击人类。熊猫的和善性格让它们成为了受人喜爱的动物，也使得与它们亲近的经历变得更加难得而特殊。更重要的是，熊猫的稀有性使它们更加引人注目。熊猫是濒危物种，只生活在中国的某些地区，数量非常有限。保护熊猫已经成为国际社会的共同责任，各种保护项目和保护地的建立都旨在拯救这一珍贵的物种。对我来说，熊猫的稀有性让我更加珍惜和喜爱它们，也激励我支持保护它们的工作。最后，熊猫的生活习性也令人着迷。它们主要以竹子为食，是唯一以植物性食物为主的熊科动物。熊猫的饮食习惯和生活方式在动物界中非常独特，这也使得它们成为了生态系统中的特殊环节。总之，熊猫是我喜爱的动物，不仅因为它们的可爱外貌、温和性格和珍稀身份，还因为它们引发了我对生物多样性和环境保护的关注。熊猫是地球上宝贵的生物资源之一，我们每个人都有责任为它们的保护贡献一份力量，以确保它们的未来世代能够继续欣赏这个可爱的物种。 难忘的旅行 背12345678910111213难忘的旅行：登上普通山峰的经历与感悟曾经的一次旅行，我选择了攀登一座并不出名的普通山峰，这次经历给我留下了深刻的感悟和难以忘怀的记忆。旅程的开始并不轻松。我们背着沉重的背包，沿着蜿蜒的山路艰难前行。途中，我感到疲惫和气喘吁吁，有时甚至怀疑自己是否能坚持到底。然而，正是在这些困难中，我学会了坚持和克服，体验到了身体的力量和意志的坚定。随着海拔的不断上升，气温开始下降，大气中弥漫着一股清新的气息。森林渐渐变得茂密，鸟儿的歌声萦绕在耳边，这些自然的美妙让我感到无比愉悦。登山途中，我有机会欣赏到壮观的自然景观，如瀑布、峡谷和湖泊。这些美景使我对大自然的奇妙之处有了更深刻的理解和欣赏。在攀登过程中，我结识了一群志同道合的伙伴，我们互相鼓励，分享食物和笑声。这种团队合作和友情让我感到温馨和满足，也教会我在困境中寻找支持和快乐。最终，当我们登上山峰的顶端时，我感到一种巨大的成就感。站在山巅，俯瞰着下方的景色，我感到了一种与自然和世界相融合的感觉。这一刻，我明白了冒险的真正意义，它不仅是征服山峰，更是征服自己，挑战自己的极限。这次登山经历教会了我坚持不懈、勇往直前的重要性。它让我更加珍惜自然的美丽和人与自然的联系。最重要的是，它让我学会了欣赏生活中的小事情，感恩身边的人和事。这次旅行虽然没有攀登著名的山峰，但它留下的感悟和记忆将永远珍藏在我心中，激励我勇敢面对生活中的各种挑战。 我喜欢的节日背引言：春节，又称中国农历新年，是我最喜欢的节日之一。这是中国传统文化中最重要的节日之一，也是一年中最富有独特文化和兴奋气氛的时刻。 节庆活动：春节期间，中国各地都充满了喜庆的氛围。人们会彩扎灯笼，贴春联，进行烟花晚会，家家户户都会进行大扫除，以迎接新年的到来。走亲访友、互赠红包、品尝美食也是春节不可或缺的传统活动。 文化和传统：春节传承着丰富的文化和传统，如舞龙、舞狮、戏曲表演等。红色被视为幸运色，因此人们穿红色的衣服，家里也会挂红灯笼，这代表着好运和繁荣。 人际关系和团聚：春节是家庭团聚的时刻，人们会不远万里回到家乡与亲人团聚。这个节日强调了家庭的重要性，让人们更加珍惜亲情和友情。 传递价值观：春节传达着团结、和谐和吉祥的价值观。它教导我们尊重传统、关心家庭、分享喜悦，并展望未来的繁荣和成功。 结论：春节对我来说不仅仅是一个节日，它代表着文化传统和人际关系的重要性。庆祝春节让我感到兴奋和幸福，因为它提醒了我家庭的温馨和团聚的重要性，同时也传递了积极的价值观。无论身在何处，春节都将永远是我心中珍贵的时刻，一个充满欢乐和祝福的节日。 我喜欢的明星（或其他知名人士）背12345678910111213我喜欢的明星（或其他知名人士）“春蚕到死丝方尽，蜡炬成灰泪始干”这是描写老师无私奉献的千古名句，而我今天想讲的一名我喜欢的知名人士就是感动中国人物张桂梅老师。2021年，我在电视上第一次见到张桂梅老师，那时候她被评为感动中国年度人物，需要上台领奖。你别看她皮肤黝黑，皱纹爬满了沧桑的脸庞，走路也慢悠悠慢悠悠的，但谁能想到正是这么一个弱不禁风的人帮助了一千八百多名孩子走出大山，奔赴属于自己的美好未来。颁奖典礼结束后，我查阅相关资料，了解到了张桂梅老师更多的事迹，这也让我深深的喜欢上了她。张桂梅老师原先在大理一所中学任教，后来丈夫去世后才来到华坪任教，谁想到第二年就查出子宫肌瘤，当地人为了帮她继续治疗，一起募捐来凑手术费和医药费，张桂梅感动不已，创立了儿童福利院，希望用自己的绵薄之力回馈大家的善意；同时，看到大山里的女孩整日在家做苦力，为了让他们走出大山，她希望创办一所免费的女子高级中学。但学校的创立需要很多钱，张桂梅老师去政府企业筹款，五年仅仅筹到一万元期间甚至被误认为骗子，然而她坚持不懈，最终在全社会的帮助下成功创办免费的女子高中；张桂梅老师将自己的一生都奉献给了大山里的孩子，教学之路崎岖坎坷，以至于他患上心脏病、肺气肿等多种疾病，行走困难，但她仍然坚持每天第一个出现在学校里，监督大家学习，也正是她的努力，大山里的孩子慢慢拥有自己的未来和人生。 我喜欢张桂梅老师的知恩图报、喜欢她做事不畏艰辛、喜欢她对大山孩子里的无私奉献。她的事迹深深感动着我，也鼓励着我成为像她一样优秀的人。 购物（消费）的感受 背引言：购物是我们生活中常常涉及的活动之一，它不仅提供了所需的物品和服务，还可以激发各种感受。在这篇文章中，我将分享我对购物的感受以及购物对我们的生活的影响。 购物的欢愉：购物可以给人带来欢愉和满足感。寻找心仪的物品、试穿时的自信、购买后的满足感，都让购物成为一种愉悦的体验。购物时，我们可以表达自己的品味和风格，让自己感觉更加自信和愉快。 购物的压力：然而，购物也可能带来压力。不断涌现的新产品、销售促销和社交媒体上的时尚潮流，可能让人感到购物焦虑，担心错过了什么。这种压力有时会导致过度消费，对财务和环境造成不利影响。 消费和身份认同：购物也与身份认同有关。人们常常通过购物来表达自己的个性、兴趣和价值观。我们选择的服装、家居装饰和其他物品都反映了我们想要展示给世界的形象。这种购物的方式可以成为一种自我表达的途径。 可持续消费：如今，越来越多的人开始关注可持续消费。他们更注重产品的质量、耐用性和制造过程的环保性。可持续消费是对过度消费的一种回应，它强调了对资源的负责和对未来世代的关注。 结论：购物是一个复杂的活动，既可以带来快乐和满足，又可能引发压力和负面影响。关键在于如何理智地看待和管理自己的购物行为。通过理解购物的感受，我们可以更好地掌控自己的消费习惯，追求更加可持续和满足的生活方式。购物是我们与物质世界互动的一种方式，我们应该以明智和负责任的方式进行。 12345678人的衣食住行，处处都要花钱，购物自然而然成为了我们生活当中不可缺少的一部分。随着社会的进步和互联网的发展人们的购物方式已经从传统单一的线下购物变成了“线上线下”并行的购物方式。有些人倾向于线下购物，有些人倾向于线上购物。实际上，两种购物方式各有优点和缺点，同时也有需要注意的地方。线下购物最大的优势就是消费者可以看得见摸得着商品，他们可以亲自试穿衣服，看看这件衣服到底适不适合自己。而且还可以当场检查一下质量问题，检查线头、拉链等等，保证自己购买的商品是完好无损的。在线下购物的时候，消费者可以和店家进行讨价还价，以此减少自己的购物成本。与此同时，线下购物的时候可以和朋友一起，通过逛街购物来增加彼此之间的情谊。而线下购物的缺点就在于消耗的金钱和时间成本大。因为线下购物活动区域小，且商家门店费用贵，因此线下商品一般价格更贵一点。线上购物的最大优势就是消费者尅跨越时空的限制，随时随地浏览淘宝、京东等，进行线上购物。网上的商品琳琅满目，可选择的空间很大，而且价格低，一般不会出现断货的情况。而且目前物流发展的越来越快，购买的东西很快就能到手。然而，网上容易出现盗版东西，甚至会出现抄袭现象。与此同时，在大数据的帮助下，一些商家可以长时间占领消费者的浏览界面。总而言之，线上购物和线下购物各有优缺点，而消费者购物时必须要树立理性概念选择适合自己的，也不要被一些广告所蒙蔽。 谈谈社会公德（或职业道德）背引言：社会公德是一个跨足社会和个体的重要概念，它涵盖了尊重他人、履行社会责任、追求公平和正义等多个方面。在当今复杂多变的社会中，社会公德变得愈发重要。本文将探讨社会公德的概念、其在社会和个人生活中的价值，以及如何培养和提高社会公德。 社会公德的重要性：社会公德是社会运作的基石。它不仅有助于建立和谐社会，还能够改善人际关系，促进社会发展。在个体层面，社会公德有助于建立信任、提高自尊和幸福感。在更广泛的层面上，社会公德有助于创造一个更加公平、公正和和谐的社会。 社会公德的具体方面： A. 尊重他人： 尊重他人是社会公德的基石。它包括尊重他人的观点、信仰、文化和个人空间。尊重他人不仅仅是一种行为，更是一种态度，它能够改善社交关系，减少冲突，并建立互信。 B. 社会责任感： 社会责任感是关心社区和社会的一种态度。它包括参与志愿活动、支持慈善事业以及尽力改善社会状况。具备社会责任感的个体能够为社会的发展和进步做出贡献。 C. 公平和正义： 社会公德还包括追求公平和正义。这意味着反对不平等和歧视，支持公平的机会分配，并在面对不正义时采取行动。公平和正义是建立公正社会的关键元素。 社会公德的培养：社会公德可以通过以下步骤来培养和提高： A. 教育和自我反思： 学习有关社会公德的知识，反思自己的行为和价值观，以了解如何改进。 B. 实践和坚持： 尝试参与社会活动和志愿工作，以实际行动来培养社会公德。坚持这些行为，使其成为日常生活的一部分。 C. 成功人士的社会公德实践： 学习成功人士如何在他们的生活中实践社会公德。他们的经验故事可以提供宝贵的启发和指导。 社会公德与社会和文化：社会公德在不同文化中可能有不同的体现方式，但其核心价值通常是相似的。全球化使不同文化之间的交流更加频繁，因此理解和尊重不同文化中的社会公德是至关重要的。 结论：社会公德是一个重要的概念，它涵盖了尊重他人、履行社会责任、追求公平和正义等多个方面。良好的社会公德不仅有助于建立和谐社会，还有助于个人幸福和社会进步。通过教育、自我反思、实践和坚持，我们可以不断培养和提高自己的社会公德。这是我们每个人都能够为创造更美好社会做出的贡献。 123456789职业道德是一个人从事某种职业的时候，要履行自己的基本职责，遵守相关的要求和规定。遵守职业道德是一个人从事某项职业的基本义务，也反映了这个人的道德素质水平。但在现在社会中仍然出现了一些未能遵守职业道德的事情。现代社会，竞争越来越激烈，很多家庭都希望自己的小孩能够出人头地，因此有些人就抓住家长望子成龙、望女成凤的心理，做出了一些超越职业道德底线的事情。比如说有些老师上课的时候不给同学讲明白，等到课后就跟家长说小孩子学习能力有待提高，需要报一些补习班，于是老师就可以通过办补习班挣一些外快。现在国家已经在严厉打击这种行为，但仍然有一些人在顶风作案。教师是一个光荣的职业，他应该是无私奉献的，应该毫无保留地将自己地知识教授给同学，而不是有所保留去开一些补习班，这严重违反了职业道德。不仅老师，其他领域也存在一些违反职业道德的人。比如说前端时间曝光的医院腐败事件，有些医院领导在购买医疗器材吃回扣。医生在我们心中是形象是白衣天使，他的职责是治病救人，就算有些人当上了领导，承担了一定的管理职责，也应该时刻记住他是一名医生，要以病人的利益为重，那些腐败的人忘记了他们成为医生时所宣读的誓言，突破了职业道德的底线，抹黑了医生的形象。诸如此类的现象会扰乱社会秩序、会侵害人民利益，我们希望这些事情不再发生。一方面，国家要加大惩处力度，打击一些严重违反职业道德，甚至触犯法律的行为；一些行业协会也可以加大监管力度，协助政府；另一方面，我们自己要树立正确的职业观、遵守职业道德。 谈谈个人修养 背引言：个人修养是一个广泛而深刻的主题，它关乎我们如何生活、如何与他人相处以及如何发展自己。在当今繁忙而充满挑战的世界中，个人修养变得愈发重要。本文将探讨个人修养的概念、其在个体生活中的重要性以及如何培养和提高个人修养。 个人修养的重要性：个人修养是指一个人的道德、品质和行为准则。它涵盖了礼仪与礼貌、自律与责任感、沟通与决策能力等方面。良好的个人修养不仅能够帮助我们建立良好的人际关系，还有助于我们在职业生涯中取得成功。此外，个人修养也有助于提高自我认知，实现内在平静和心灵成长。 具体方面的个人修养： A. 礼仪与礼貌： 礼仪和礼貌在社交中起着重要作用。它们涵盖了如何尊重他人、如何表达感谢、如何处理冲突等方面。通过展现良好的礼仪和礼貌，我们能够建立互信关系，改善人际关系，营造和谐的社交环境。 B. 自律与责任感： 自律是追求目标、保持计划和控制冲动的关键。责任感涉及履行承诺、对自己的行为负责。这两个品质有助于我们实现个人和职业生涯中的成功。通过培养自律和责任感，我们能够更好地管理时间和资源，取得更大的成就。 C. 沟通与决策能力： 沟通和决策能力是关键的生活技能。良好的沟通能力有助于我们更好地理解他人，有效表达自己的观点，并解决冲突。优秀的决策能力能够帮助我们做出明智的选择，迈向成功的道路。 个人修养的培养：个人修养不是一成不变的，它可以不断提高和培养。为了不断进步，我们可以采取以下步骤： A. 自我提高和反思： 定期反思自己的行为和决策，了解自己的优点和不足，以及如何改进。阅读和学习也是自我提高的重要途径。 B. 实践和坚持： 个人修养需要实践和坚持。尝试新的行为和习惯，然后坚持下去，直到它们变成自然而然的一部分。 个人修养与心灵成长：个人修养与心灵成长有着深刻的关联。通过修炼冥想、宽恕和感恩，我们能够实现内在平静，提高心灵成长。这些实践有助于我们更好地理解自己，提高情感智慧，以及培养更加宽容和慈悲的态度。 结论：个人修养是一个综合性的概念，它涵盖了道德、品质和行为的多个方面。良好的个人修养对个体和社会都至关重要。通过培养礼仪与礼貌、自律与责任感、沟通与决策能力等品质，我们可以实现个人成功和内在平 123456789101112131415谈谈个人修养古人云，“修身、起家、治国、平天下”。个人修养是一个人立身处世的根本，同时对社会的发展、国家的形象也有重要意义。个人修养体现在方方面面。比如说看电影的时候是一边看电影一边和朋友讲话还是安安静静地看电影，有事出去说；比如说出门在没垃圾桶的情况下是随手扔掉还是一直带在身上，等有垃圾桶的时候再扔；再比如说参加某项正式会议时是穿着衬衫短裤还是着正装出席等等；一个人的修养体现在生活当中的各个方面。董卿是我非常尊敬和喜爱的主持人。我喜欢她不仅是因为她长得好看，有学识，还因为她的个人修养。2017年，《朗读者》邀请了我国翻译界泰斗许渊冲老先生，但老先生年事已高，只能坐在凳子上接受采访，为了照顾到凳子上的老人，也为了表达对老先生的尊重，董卿选择跪下采访。这一跪更是显示出了她超高的个人修养。反观先前引起社会热烈讨论的唐山打人事件。男子公然在公共场所对陌生女子实施辱骂、殴打，是一种对女士的侮辱。他的行为不仅触犯了法律，也违反了社会道德，个人修养难以评价。我们都想成成为个人修养高的人。那我们应该怎么办呢？首先，思想影响行动，我们必须提高我们的知识水平，我们必须要了解社会道德、社会价值观，知道什么是对、什么是错，在什么场合做什么事情，而不是随心所欲。其次，我们要践行社会主义核心价值观，把我们认为是对的事情做出来，如果只是脑子里知道而不用行动去践行，那么就不会产生什么实际效果。希望每一个人都能够成为一个道德素质高，个人修养强的人，这样，我们的社会才会和谐、才会进步，我们才不会愧对中国“礼仪之邦”的名誉。 我喜爱的书刊12345678910111213我喜爱的书刊高尔基说，“书籍是人类进步的阶梯”。通过阅读一些书籍，我们可以发现更广阔的世界、体验更多的人生、明白更多的道理。我喜欢的书刊有很多很多，而且不同的年龄阶段，我喜欢的书刊也有所不同 。小学的时候，我最喜欢读《淘气包马小跳》系列的书。它是由杨红樱作家写的，主要围绕着马小跳展开叙述。书里讲了马小跳许多有趣的事情，比如说马小跳去竞选“超级市长”，去熊猫自然保护区拍熊猫，和几个好朋友建立“跳跳电视台”等等。小时候的我被马小跳的生活所深深吸引。直至现在，我也觉得马小跳非常可爱。《淘气包马小跳》非常值得小孩子阅读。等到了初中的时候，我开始喜欢上《读者》。最开始我并不知道这个书刊，还是我和同学去新华书店偶然翻来看看的。《读者》是一个面向社会各界读者的读物，他刊登的文章种类很多，有小说、有散文、有诗歌。而且他还会根据不同的内容划分不同的专栏，方便读者阅读。我最喜欢的是散文期刊，因为里面收录了很多名人作家的散文，比如说汪曾祺。我可以从他们的文章中学习写作的方法。高中的时候，学习任务紧，没有太多的时间看书，看的最多的就是经典名著。小时候一直看西游记，但一直都是断断续续地看。高中的时候，《西游记》是我们的必读书目，这也给了我一个机会完完整整地读一遍这个故事。也正是这一次完整地阅读，让我对每个人物地性格有了更全面的了解。我最喜欢的还是孙悟空，因为他勇敢，敢于斗争。我们每一个人在困难面前都应该充满信心，相信我们能够取得胜利，我们要勇敢地去闯荡世界。“活到老，学到老”，每一种类型的书刊都会给我不同的阅读感受，我爱读书。 学习普通话的体会123456789普通话是指我国各民族之间普遍通用的一种语言，我国更是通过法律确定了“国家通用语言”的法定地位。我国历史悠久、幅员辽阔、民族多样，每个地区和民族由于地理隔阂和历史等，形成了各具特色的交流语言。但不同的语言会造成叫交流上的隔阂，进而组织文化传播及各民族的团结合作，因此，学好普通话具有重要意义。教师作为传播知识的使者，拥有一口流利的普通话是十分必要的。为了顺利获得教师资格证，我努力练习了普通话近一个月。刚开始，我自认为自己普通话非常不错，应该随便讲讲就可以顺利通过，结果通过相关软件进行测试，发现我仍然存在一些问题。在第一项当中，我有一些不认识的字，甚至有一些字很熟悉但也会读错；在第二项中，我的轻声和儿化音也有一些问题。第三项朗读短文中也存在一些陌生字词，读的也不是特别流利。在这种情况下，我摆正态度，开始认真练习普通话。首先，我准备了一个笔记本将不认识的字词记录下来，然后查字典，标记好他们的正确读音，最后在跟着软件进行练习；第二，每天花一个小时练习短文。我采取的方法是听一篇读一篇，这样我能及时掌握文章读起来的节奏。当我慢慢熟悉起来后，我就会注重每一个字词的发音，使发音尽量饱满，准确。与此同时，我会通过普通话测试软件来检验我的练习成果。不过，为了保证我的发音准确，我也会请已经顺利通过普通话测试的舍友帮助我，纠正我错误的发音，提供一些意见给我。我相信，在我的努力下，我一定会顺利通过普通话测试并取得不错的成绩。 谈谈服饰当然，让我们开始写关于服饰的500字文章。 引言：在我们的日常生活中，服饰不仅仅是一种简单的覆盖身体的物品，它们更是一种表达、文化和社会认同的方式。本文将探讨服饰在我们生活中的重要性，以及它们如何影响个体和社会。 服饰与个人表达：服饰是个人表达的一种有力方式。它们可以反映个体的品味、风格和个性。不同的服饰选择可以传达出各种信息，从职业身份到个人兴趣。例如，一位音乐家的舞台服饰通常会反映出其音乐风格，而一位职业人士的正式服饰则可能传达出专业性和可信度。 服饰与文化和时尚：服饰与文化密切相关。不同文化背景的人们可能有不同的传统服饰，这些服饰反映了他们的价值观和历史。此外，时尚行业不断塑造着服饰趋势，影响了人们的购物和着装选择。时尚不仅仅是外表，它也是一种文化和艺术的表达方式。 服饰与社会认同：服饰可以在社会中发挥重要作用，塑造社会认同和群体归属感。一些群体可能通过共同的服饰选择来表达他们的身份和价值观，这有助于建立联系和凝聚力。在职业场合，适当的着装也可以提高职业认同感，表明专业性和尊重。 可持续时尚：然而，我们也需要关注服饰的可持续性。快时尚和过度消费对环境和社会都带来了负面影响。可持续时尚强调了制造和购买服饰的负责任方式，包括选择环保材料、减少浪费和支持公平劳工条件。我们可以通过购买耐用的服饰、重视品质而非数量，以及选择可持续品牌来积极参与可持续时尚。 结论：服饰在我们生活中扮演着多重角色，既是个体表达的工具，又是文化和社会认同的体现。时尚和服饰趋势不断变化，但我们也需要关注它们的可持续性，以便在追求个性和风格的同时，更好地保护我们的地球和社会。选择服饰时，我们可以思考它们的背后故事，以实现个体表达和可持续性之间的平衡。服饰不仅改变了我们的外貌，还影响了我们的生活方式和社会互动，因此我们应该以明智的方式选择穿着。 12345饰是一个人的穿着，包括衣服、裤子、写字、帽子等等。小时候，爸爸妈妈给我们买服饰的出发点主要是保暖。穿的干净会被别人夸讲卫生。后来，慢慢长大发现服饰还有很多作用。服饰可以提现一个人的社会身份。在中国古代王朝，文官的衣服上印着的是鹤，武官的衣服上则大多是麒麟、老虎。现代社会也是一样，就拿本科生毕业来说，学士帽上不同的流苏颜色也代表着不同的学位级别，黑色代表学士学位，深蓝色代表硕士学位，红色代表博士学位。与此同时，我们要分清场合，选择合适的服饰。大学里有很多答辩。每次答辩的时候，选手和老师都会穿正装出席，不会出现短袖短裤、牛仔裤这种穿搭。再比如说，女生在重要场合穿裙子时要以深色为主，裙子要过膝。合适的服饰不仅表现了自身的形象，也是表达对他人的尊重。除此以外，我还想讲一讲当今大学生追去品牌潮流、互相攀比的社会现象。随着社会的发展，服饰产业发展越来越好。一些学生进入大学后，越来越重视自己的穿衣，看到同学身上穿着乔丹、耐克等名牌衣服，就会把父母给的生活费拿去买跟同学一样的品牌衣服，有些同学甚至因此被诈骗、去借贷。在我看来，这是不对的。人们追求美、追求品质是没有错的，但一些品牌衣服价格高并不是品质比便宜的好，而是一种品牌效应。我们买衣服应该量力而行，只要自己穿着舒服，觉得好看就行，不必特别在意别人的眼光。 谈谈对环境保护的认识引言：环境保护是一个备受关注的全球性话题，它关乎我们的生活质量、未来的可持续性和地球的健康。本文将探讨环境保护的概念，讨论它的重要性以及我们每个人在保护环境方面的责任。 环境保护的定义和范围：环境保护不仅仅是保护大自然的美丽景观，它更是维护地球生态系统的完整性和人类社会的健康。它包括减少污染、保护生物多样性、节约资源和应对气候变化等一系列努力。我们面临的挑战包括气候变化、水资源匮乏、森林砍伐和海洋污染等问题，这些问题需要全球共同应对。 个体责任与集体行动：环境保护不仅是政府和国际组织的责任，每个人也有责任。我们每个人的日常行为和消费习惯都对环境产生影响。因此，个体责任至关重要。但仅靠个体的努力是不够的，集体行动也是必要的。国际合作和全球行动是解决环境问题的关键。 生活方式与环保：我们可以通过调整生活方式来减少对环境的负面影响。例如，减少塑料使用、节约能源、支持可持续食品生产和选择公共交通工具等行为都有助于降低碳足迹。这些小举措可以在个体层面积累起来，产生积极的环境影响。 教育与宣传：教育是提高环保意识的关键。通过教育，我们可以了解环境问题的复杂性，认识到我们的行为如何影响地球，并激发积极的行动。同时，宣传和社会媒体在传播环保信息和鼓励人们采取行动方面发挥着重要作用。 政策与法律：政府和国际组织在环境保护方面起着关键作用。环保法律和政策的制定和实施有助于规范企业行为、减少污染和保护自然资源。这些法律和政策为环保提供了法律依据和框架。 全球挑战与解决方案：我们面临的环境挑战日益严峻，如气候危机、生物多样性丧失和水资源短缺等。解决这些挑战需要全球合作和创新解决方案。国际倡议和可持续发展目标是实现环保的关键工具。 结论：环境保护是我们每个人的责任，也是全球社会的责任。它不仅关乎我们的生活质量，还关系到未来世代的生存。通过个体责任、集体行动、调整生活方式、教育和政策制定，我们可以共同致力于保护地球，创造一个更加可持续和美好的未来。环境保护不仅是一项任务，更是一种道德和伦理责任，我们每个人都应积极参与其中。 12345678910111213141516谈谈对环境保护的认识1. 环境保护的重要性2. 环境保护的措施走在路边，时常能看到公交站台的宣传栏、商场的大屏幕上滚动播放着保护环境的公益广告，呼吁大家保护环境。曾经的地球是银河系中最为美丽的一颗蓝色星球，但如今地球母亲已经千疮百孔。冬季的天空蒙上了厚重的雾霾，路上的行人只能戴着口罩快步前进；海洋河流不再清澈，垃圾横生，鱼儿逃窜，有时甚至会发出一点臭味儿。与此同时，走在路上，仍会在草坪上看到几个白色塑料。不论是工业发展，还是人们随手扔的垃圾都在一点点破坏我们赖以生存的环境。如果一直放任环境恶化下去，我们人类的生活也会受到影响。比如全球气候变暖造成冰山融化，空气污染导致人们患有呼吸疾病，河流污染导致水产品不够新鲜对身体健康造成威胁。我们国家很早就认识到了环境的重要性，先后提出“科学发展观”“绿水金山就是金山银山”等理论理念，呼吁所有人保护环境。目前，国际上已基本达成共识，中国更是提出“双碳”目标，并积极采取措施。那在个人层面上，我们能做那些事情呢？首先，在交通出行方面，我们可以选择购买新能源汽车，与此同时，我们应该坚持绿色出行，尽量乘坐公交车、地铁等公共交通工具；其次我们可以减少一次性物品和塑料产品的使用，每次去超市的时候自己带一个布袋子；如果有机会的话，我们还可以和自己的亲戚朋友一起去种植树木，一起去参加环境保护的宣传志愿等，将“保护环境、人人有责”的理念传播到每个人的耳中。真心希望我们的环境能够变得越来越好。 谈谈科技发展与社会生活123456721世纪以来，科技发展速度越来越快，尤其是计算机、大数据、人工智能等领域创造了许多令人惊喜的高科技产品。科技发展影响社会生活，它渗透在我们的吃穿住行各个方面，使我们的生活更加便利。最常见的就是我们的手机。手机最开始出现就引起了社会的轰动，因为它能使远在天边的人相互联系，克服了地理上的距离，使人们的沟通交流越来越便捷。之后，手机不断更新迭代，目前，我们的生活几乎离不开手机，手机上有许许多多的软件。当你饿了的时候，你可以打开美团寻找想吃的东西，然后一件下单，外卖到家；当你想逛街的时候，你可以打开淘宝、京东，浏览者琳琅满目的商品；当你想和远方的朋友聊天时，你可以打开微信，进行视频通话，更进一步拉近两者直接的距离。除了手机，还有一些别的科技产品。比如说扫地机器人、智能冰箱，减少了我们一些家务方面的压力；比如说点读机、翻译笔，帮助小孩子自我学习；比如说最近很火的人工智能，它们自己作诗、作画，给艺术家提供创作的灵感。然而，科技是一把双刃剑，他在给我们带来便利的同时也给我们造成了一些麻烦。智能家电的存在让人类越来越懒，不爱干家务；电子产品使小孩子沉迷游戏，危害健康；讨论最为多的便是人工智能是否会取代人类的一些低级工作，进而造成多数人失业，进而引发更大的社会问题。 我知道的风俗引言：春节，又称农历新年或中国新年，是中国传统文化中最重要的节日之一。它标志着农历年的开始，是家庭团聚、庆祝和传统仪式的时刻。在本文中，我们将探讨春节的背后故事、庆祝活动和其在社会中的重要性。 春节的背后故事：春节的历史可以追溯到数千年前，它源于中国古代农耕社会的农历。传说中，这个节日的起源与击退怪兽「年兽」的故事有关，而红色的装饰和鞭炮则被认为是用来吓走年兽的。此外，春节也是在寒冷的冬季结束后迎来温暖的春季，因此它也象征着新的开始和希望。 春节的庆祝活动：春节期间，中国人民举行各种各样的庆祝活动，包括家庭团聚、宴会、赏花灯、舞龙舞狮和焰火表演。此外，红包是春节庆祝中的一项重要传统，家长通常会给孩子们压岁钱以带来好运和祝福。 春节在社会中的重要性：春节不仅是家庭的庆祝活动，也是社会中的大事。它为人们提供了一个团结和共享的机会，人们在这个时刻可以忘却烦恼，享受亲情和友情。此外，春节也承载着文化传承的责任，通过庆祝活动和仪式，将传统价值观和历史故事传递给下一代。 春节的变迁：尽管春节保留了许多传统元素，但它也在现代社会中发生了变化。人们现在可以利用科技手段如视频通话来远程团聚，而一些现代庆祝活动也已经融入到春节庆祝中，如春节晚会和电子红包。 结论：春节是中国文化的精髓，它代表着团结、希望和传统的价值。这个节日不仅让人们庆祝新的开始，还强调了家庭、友情和文化传承的重要性。无论在哪里庆祝，春节都是一个欢乐和意义深远的时刻，它将继续在中国和全球范围内传承下去，传播着友好与祝福。这个节日的故事和庆祝活动充分展示了风俗的力量，它们连接着人们的心灵，共同创造出美好的回忆和未来。 12345678 风俗是一个社会在一定时期内形成的风尚喝、习俗等。中华文化源远流长，博大精深。传统节日就蕴含着许多风俗。春节的习俗很多。比如除夕夜，大家会坐在一起吃年夜饭。年夜饭非常丰富，而且会将年夜饭留到第二天，意味着“年年有余”。春节的时候，一家人还要围坐在一起吃热腾腾的饺子，希望一家人能够团团圆圆。春节最令小孩子开心的便是拜年收红包了。大年初一早上醒来，就会发现床头有长辈放的一块糕点，旁边放着红包，寓意着“步步高升”。收红包是小孩子的特权，但拜年是每个人都会做的事情。我的爸爸妈妈也会给爷爷奶奶、外公外婆拜年，我和朋友之间也会相互拜年。春节拜年是为了表达祝福，希望自己的亲戚朋友能够身体健康，生活开心。端午节又是我国的另一个传统文化。端午节的时候大家要挂艾草戴香包，吃咸鸭蛋、喝雄黄酒、吃粽子、赛龙舟。端午节吃粽子还有一个传说呢。相传古时候，爱国诗人屈原因为不能忍受亡国之痛，在五月初五这一天跳入汨罗江。当地的百姓为了保护屈原的躯体不被鱼虾损害，纷纷向河里投粽子。所以每当端午节的时候，人们就会吃粽子纪念屈原。赛龙舟也是端午节的一大风俗。每到端午的时候，就会举行热闹非凡的龙舟比赛。大家齐心协力共同划向终点。除了春节、端午节，我还知道很多传统节日的风俗。比如说中秋节，一家人围坐在一起吃月饼赏月；重阳节，大家去登山、吃重阳糕等等。每个风俗都有自己的意义，我们应该更多地去学习和了解。 姚我的愿望（理想） 1. 理想是什么（理想的定义＋我的理想＋我的理想的意义） 2. 理想产生的原因（一般原因＋个人经历） 3. 我想成为什么样的老师 4. 我为理想做了哪些努力 （现在的努力和未来的努力） 5. 希望我的理想能够实现 我选择的题目是我的理想。理想是一个人为自己设定的目标，是需要通过一系列的努力才能最终达成的抱负。我的理想是成为一名小学老师。在我心里，小学老师对孩子的成长教育具有不可言说的重要意义。 一方面，小学老师能够为孩子传授最基本知识，帮助孩子认识世界，奠定知识基础，从而更好地帮助他们进入中高级教育，最终成为社会和国家的栋梁之材；另一方面，小学老师对于孩子性格品质、自信心的形成具有重要意义。小时候，我性格孤僻，做事畏手畏脚，经常躲在人群后面，想要当宣传委员画黑板报也不敢竞选。后来，我的小学班主任张老师悉心鼓励我，将我画的展示给同学们看，受到了大家的一致好评，最终我也是鼓起勇气竞选了宣传委员。也是通过这一次，我的信心有所增加，也收获了很多友谊。学校是孩子除了家庭待的时间最长的场所，在小孩懵懂的阶段，老师的指引和鼓励是至关重要的，因此，我也想成为一名小学老师，帮助更多的小孩健康成长。 我希望我能成为一名优秀的人民教师，在学习上，我能够让学生们肆意地吮吸知识的甘霖；在生活上，我能够打开学生的心扉，与他们成为朋友，帮助他们解决生活上的困难。我希望，能够通过自己的努力为他们系好人生的第一个纽扣。 目前，我已经是教育专业的一名师范生。进入大学后，我不仅认真学习，期望掌握教师的一般技能，还经常参加一些志愿活动来锻炼我的表达与沟通能力。例如，这个暑假，我也在自己的社区报名了暑托班志愿，教孩子语文、数学、画画。实现理想的过程并不是一帆风顺的，所谓“有志者事竟成”，未来，我仍会不骄不躁，脚踏实地，一步一个脚印去实现我的理想。 我的学习生活 1. 介绍我的大学 2. 两个目标 3. 我的努力（学习图书馆＋团支部主席＋竞赛党员） 4. 总而言之，收获＋回忆 所谓“活到老，学到老”，人的一生都处于不断的学习中，而我这次想讲一讲我的大学学习生活。我就读于江苏省南京市一所211高校，它被誉为“东方最美校园”，教学质量也非常高，是许多人梦寐以求的大学。我热爱我的大学，也珍惜我在这所大学学习生活的机会。 刚进入大学，我就为自己设定了科学的目标。一方面，我的主要任务是认真学习，也好本专业知识，将平均学分绩点维持在较高的水平；另一方面则努力尝试一些学科竞赛并参与一些集体活动，提高自身的综合素质。 而为了完成这些目标，我也做了很多努力，并取得了不错的成果。在学习方面，我仍然保持良好的学习习惯，做到课前预习，课后复习，不懂就问。与此同时，我清晰地认识到大学学习讲究的是一种自主性，我们必须合理安排自己的时间。因此，我经常和同学相约去图书馆学习，一学就是一下午，图书馆可谓是我的第二宿舍。在我日复一日的学习下，我也取得了不错的成绩，专业排名位列第一；在综合素质方面，我积极参与学院学校活动，担任班级团支书，举办各种具有特色的主题团日活动，带领团支部获得了“”“暖心团支部”和“特色团支部”称号；担任学生会主席，带领院学生会获得“四星级学生会”称号；此外，为了将所学运用到实践中，提高自身能力，我和同学组队参加了大学生创新创业计划及公共管理案例分析比赛并获得佳绩；同时，经过我的不断努力我也成为了一名中共预备党员，和党支部一起参与志愿活动，助力乡村振兴。 总而言之，我的大学生活十分丰富。我不仅获得了专业知识，提高了自身的实践能力和综合素质，也收获了一份份纯真的友谊。我相信不论多久，这段大学学习生活都会成为我一段宝贵的回忆。 我尊敬的人 1. 引子 2. 长什么样子 3. 为什么尊敬 4. 对我的触动 人的一生会遇到很多人，他们身上总会有令人钦佩的闪光点，例如诚实守信、乐于助人、无私奉献等等，而令我最为尊敬的便是张桂梅老师。她皮肤黝黑，皱纹爬满了沧桑的脸庞，走路也慢悠悠慢悠悠的，但谁能想到正是这么一个弱不禁风的人帮助了一千八百多名孩子走出大山，奔赴属于自己的美好未来，而她也获评了包括感动中国年度人物在内的多项荣誉。 张桂梅老师教会我做人要知恩图报、要懂得感恩。张桂梅在丈夫去世后来到华坪任教，谁想到第二年就查出子宫肌瘤，当地人为了帮她继续治疗，一起募捐来凑手术费和医药费，张桂梅感动不已，日后创立了儿童福利院和女子高级中学，用自己的绵薄之力回馈大家的善意；张桂梅老师教会我做事要持之以恒，不畏艰辛。女子高级中学的创立需要很多钱，张桂梅老师去政府企业筹款，五年仅仅筹到一万元期间甚至被误认为骗子，然而她坚持不懈，最终在全社会的帮助下成功创办免费的女子高中；除此以为，张桂梅老师的无私奉献精神令我钦佩。张桂梅老师将自己的一生都奉献给了大山里的孩子，教学之路崎岖坎坷，以至于他患上心脏病、肺气肿等多种疾病，行走困难，但她仍然坚持每天第一个出现在学校里，监督大家学习，也正是她的努力，大山里的孩子慢慢拥有自己的未来和人生。 张桂梅老师令我尊敬，也值得每一个人尊敬，正是她的坚持、她的奉献照亮了贫苦孩子的生活，也照亮了孩子背后的一个个家庭，也正是有像张桂梅老师这样的人的存在，我们的人民才会生活的越来越好。未来，我要向张桂梅老师学习，用自己的绵薄之力为社会做出一份贡献。 我喜欢的动物 1. 引子 2. 外形外貌、生活习性 3. 喜欢的缘由 动物是人类的好朋友，有些人喜欢百兽之王老虎，有人喜欢忠心耿耿的小狗，有人喜欢憨态可掬的大熊猫…….那么多动物之中，我最喜欢的是活泼可爱的小白兔。 小白兔长着两只长长的耳朵，能够听到四面八方的声音，遇到危险时候，总能很迅速地躲藏起来；她类似红宝石一样的眼睛，闪闪发光，令人新奇。同时，小兔子拥有独特的三瓣嘴，吃起东西来特别可爱。他那雪白的毛发软软的，像披着一件大衣一样。屁股后面的尾巴像一个毛球，小小的，可爱极了。 那我为什么会喜欢小白兔呢？一方面，小白兔非常可爱，每次看见它就会心情愉悦；尤其是和小白兔相处一段时间后，它就会非常听话，不会打扰人们的休息，和它相处，心情会得到治愈；另一方面，小白兔圈养起来非常简单，每天准备一小碗蔬菜就可以满足它的味蕾，还可以准备一根胡萝卜，这样有利于帮助小白兔磨牙；此外，兔窝清理起来也非常方便，它的粪便小小的呈球状，只要在笼子下面放上一层纸板，每天清理一下即可。 我曾经养过一只小白兔，发现它的胆子特别小，喜欢生活在安静的地方，突然发出一些声响便会受惊，到处乱跑；与此同时，小白兔喜欢夜间活动，白天总是一副没精打采的样子，趴在窝里睡觉，当时还以为它生病了，一直给它喝水，结果由于饮水过多最终死掉了。事后，我查阅资料发现小白兔不能过度饮水，不然就会引起腹泻，严重的话还会死亡。这件事后我十分愧疚，再也没有养过小白兔了，但我仍然喜欢小白兔，每次看见它，都会露出微笑，下次如果有机会再次饲养的话，我一定会好好查阅相关资料，争取把它养的白白胖胖的。 童年的记忆 时光流转，白驹过隙，一转眼，我已经二十多岁了。但每当我翻阅童年时的相册时，一个个美好的记忆就像一群蝴蝶向我飞来，将我的思绪带回那快乐而难忘的童年时光。我的童年有欢声笑语，也有伤心难过，其中，最令我记忆犹新的还是小学时期参加足球队的事情。 那是小学三年级的一节体育课上，老师为了选拔田径运动员，在我们班上进行了体育测试。我从小身体素质好，跑步特别快，因此，不出意外地我跑了全班第一。可是没想到的是，体育老师并没有招收我进田径队，我只能一个人暗暗伤心，甚至回到家还哭着鼻子和爸爸妈妈抱怨。然而第二天，体育老师就问我有没有兴趣参加足球队，说我运动天赋很好，足球队教练很看好我。我听后喜上眉梢，开心极了，最后进入到学校足球队。 进入足球队后，我刻苦训练，球技有很大的提升，很快就成为了主力队员。但小时候认为自己很厉害，容易骄傲，每次分组踢球时，我都不愿意和球技不好的同学组队，比赛时也经常自己一个人往前冲，不爱传球。后来有一次踢球输了，我心情很不好，抱头痛哭，但队友们都跑过来安慰我。待我心情好转后，教练也找我进行谈话，指出了团队合作的重要性，告诉我眼里不仅要有球，也要有队友。在日后的训练和比赛中，我也慢慢发现了队友的优点，学会传球、学会配合，最终我们取得了许多优异的成绩。 这件事让我明白了团结合作是一个团队最重要的东西，是取得最终胜利的关键。我们每个人都有属于自己的闪光点，我们要善于发现别人的优点，学会和队友配合，只有这样，团队效益才能发挥到最大。 现在，足球队的小伙伴们也都见不着了，但和他们共同拥有的这段美好记忆永远都会存在我的脑海之中。 我喜爱的职业 职业有很多种，有人喜欢能够救死扶伤的白衣天使，有人喜欢能够建高楼大厦的建筑师，有人喜欢能够在舞台上释放光芒的模特，而我最喜欢的职业是教书育人的老师。 小时候，喜欢老师这个职业是因为觉得老师很厉害，能够管住很多学生。后来慢慢长大，心智逐渐成熟，开始认识到教师传递知识、教书育人的重要功能。但“教书育人”这四个字对我来说过于抽象，我并不能真正感受到。直至看到感动中国人物张桂梅老师的事迹。 作为一名人民教师，张桂梅老师不仅四处筹钱，免费创立华坪女子高级中心，更是将自己的一生都奉献给了教育事业，奉献给了大山里的孩子。她每天起早贪黑，监督孩子们学习，即使身患多种疾病，也不曾离开岗位，最终帮助一千八百多名孩子考上大学，从此改变他们以及他们背后家庭的命运。正是张桂梅老师的事迹让我认识到了教师这份职业更深层次的意义。教师的本职工作是 所谓“春蚕到死丝方尽，蜡炬成灰泪始干”。老师是无私奉献的，他将自己的所学传授给孩子们，帮助学生认识世界，最终成为社会和国家的栋梁之才 我选择的题目是我的理想。理想是一个人为自己设定的目标，是需要通过一系列的努力才能最终达成的抱负。我的理想是成为一名小学老师。在我心里，小学老师对孩子的成长教育具有不可言说的重要意义。 一方面，老师拥有渊博的学识，能够“传业授道解惑”，帮助孩子认识世界，改造世界，从而帮助他们最终成为社会和国家的栋梁之材；另一方面，学校是孩子除了家庭待的时间最长的场所，老师的指引和鼓励是至关重要的，老师对于孩子性格品质、心理健康的形成具有重要意义。 而我喜欢教师这个职业跟两个人有密切的关系。一个是我的小学班主任张老师， 难忘的旅行 我们的国家地大物博，有很多有特色的城市。北京是我国的首都，是中国文化的典型代表，是对外进行文化交流的重要城市。高考结束的那个暑假我去了北京旅行。那次旅行也成为了我最难忘的一次。 北京有很多标志性建筑。第一天，我们就去了被誉为“世界第八大奇迹”的万里长城。万里长城东起山海关，西至嘉峪关，全场约6700千米，是中国古代一代伟大的防御工程，是中国人民用汗水和智慧建筑而成的。俗话说，“不到长城非好汉”，虽然爬长城的过程很累，但我都没有放弃，终于爬了上去。成为一个名副其实的好汉。 第二天我们就去了天安门广场。天安门坐落在北京的市中心，是明清时期留下的辉煌建筑。天安门内的建筑都呈对称排列，从天下看，非常美。1949年10月1日，中华人民共和国在这里举行了开国大典，代表着新中国的成立。因此，一大早我们全家就动身，前往天安门广场去看升旗仪式。当朝阳升起的时候，五星红旗异常闪耀，我的民族自豪感油然而生。北京不仅有许多古代建筑，也有现代化建筑。下午我们就去了国家体育馆鸟巢。远远看去真的就像小鸟的窝一样。作为国家体育馆，鸟巢也承办了2008年北京奥运会，那是我们中国最为荣耀的时刻之一。北京奥运会也收获了世界各国的一致好评。 除了建筑以外，北京的美食也数不胜数。令我印象最为深刻的就是豆汁。“豆汁”是北京的一种传统美食。豆汁以绿豆为原料，具有养胃、解读、清火的功效，不过它长得不算好看，灰白灰白的，像一团浆糊，而且闻起来有一股酸臭味，有些外地人根本接受不了，但我喝起来还蛮好喝的。 我的朋友 人的一生会遇到很多人，并且和他们产生联系，其中一些人就成为了自己的朋友。朋友是什么呢？朋友是可以一起玩一起疯、一起睡，甚至可以穿一件衣服的人。大家空闲的时候，可以约上几个朋友出去玩；当自己不开心的时候，也可以找朋友倾诉。如果没有朋友，快乐喜悦和痛苦烦恼都无人分享，心里就会感到有些孤独。 我有一个朋友，她叫小汪。我们从小学四年级相识，到现在已经认识十二年了。小汪是一个很好的朋友，她热情开朗，也爱鼓励人。小汪唱歌很好听，小学就被选进合唱团，代表学校出去参加比赛，并取得了很不错的成绩。当学校里有活动需要节目表演时，老师都会找到小汪，希望她为大家演唱一首歌曲，小汪总是兴高采烈地答应下来；而我从小五音不全，心里难免有些自卑，上音乐课的时候，还被同学嘲笑过，这让我更不愿意开口唱歌了。可是，小汪并没有嘲笑过我，音乐课下课后她还安慰我，说唱歌自己开心就好，也不是表演给别人看的。日后，小汪在我们出去玩的时候总是哼一些简单的歌曲，我也慢慢跟着哼唱，再也没有那么抗拒开口唱歌了。 与此同时，小汪内心强大，是一个非常有毅力的人。小汪学习成绩没有那么优秀，高考的时候没有考好，没有达到一本分数线。当我问她志愿怎么填报的时候，她却表现地很平静，也没有跟我进行哭诉。过了好几天，他跟我说她思考了很久，决定要复读。我听到很震惊。在我眼里，复读是很痛苦的，你要承受双倍的压力。如果是我，我肯定不会选择复读。但她跟我说她真的已经想好了，她接下来一年也会好好努力。事实上的确如此，她最终圆梦，考上了一本，还超出了不少。直到现在，我都很佩服她，佩服他有这么强的意志力。 我喜爱的文学或其他艺术形式 文学是一种语言艺术，它包含很多种形式，比说诗歌、散文、小说、戏剧等。高尔基说，“书籍是人类进步的阶梯”。通过阅读一些文学作品，我们可以发现更广阔的世界、体验更多的人生、明白更多的道理。我比较喜欢诗歌和小说这两种文学形式。 诗歌的字数比较少，但作者正是能通过简单的几个字词来表达出他内心最真实的感受。我特别喜欢诗人李白，他被誉为“诗仙”，他的诗歌风格非常豪放洒脱，是一位杰出的浪漫主义诗人。诗歌的用词十分讲究。大家应该都知道贾岛推敲的故事。贾岛在写一首故事的时候，不知道用“推”这个字好，还是“敲”这个字好，反复琢磨，甚至闯进了韩愈的仪仗队，最终在韩愈的帮助下，确定了诗歌的用词，由此可见，诗歌用词十分谨慎。不仅如此，诗歌还讲究音律的美感。我特别喜欢朗读诗歌，因为它们读起来朗朗上口，十分好听。 除了诗歌，我还喜欢小说。小说就是讲故事，一般包含人物、情节、环境三个要素。情节又一般遵循开端发展高潮结局的脉络。我喜欢小说，是因为情节吸引人，而且有的时候能蕴含一些深刻的道理。我最喜欢的是欧亨利的小说。欧亨利的小说特点是结尾总是“意料之外，又在情理之中”，我有的时候看欧亨利的小说的时候，我喜欢把结尾遮住，然后自己去猜一猜小说的结尾。而且，每次他的小说我都喜欢重复的读，去寻找一下他为结尾埋下的伏笔，这让我感觉非常有乐趣。 我的朋友也都非常喜欢诗歌和小说，我经常和他们在一起交流讨论，感受文学的魅力。 谈谈卫生和健康 卫生与健康是息息相关的，通常情况下，不讲卫生会对身体健康产生一些危害。人们常说“病从口入”便是这样一个道理。 当我们逛街的时候，各种小吃琳琅满目，让我们忍不住直流口水。但事实上，它们并不非常干净。比如说炸串烧烤，它们的菜品放在车上，也没有遮掩物，风一吹，地上的灰尘就会飞到食物上，污染食物。同时，它们用来炸串的油都反复利用，不知道用过多少次了，，我们吃了很容易拉肚子，严重的甚至可能会食物中毒。因此，为了保证我们的健康，拥有一个好身体，我们必须重视卫生。 从小我的爸爸妈妈就教导我讲卫生。比如说吃饭前后要洗手，而且现在吃饭提倡使用公筷，这样能够更好地避免细菌交叉感染；同时，我们要经常打扫卫生，勤剪指甲勤洗澡。这些都是一些小事，但总有人忽视，以至于自己的健康受到危害。 与此同时，我们要注意食物的清洗和烹饪。当我们没有清洗干净食物时我们很容易拉肚子。在炒菜的时候要把食物炒熟，这样可以起到杀菌的效果。尤其是禽流感盛行的时候，尽量少吃鸡肉，就算吃也要处理干净，保证高温烹饪；此外，我们必须注意公共场所卫生。公共场所是人员聚集的重要场所，如果不注重卫生，很有可能滋生细菌，进一步传播疾病。我们可以看到，公共厕所就是重灾区，很多人不讲究卫生，烟头纸巾乱扔，非常不卫生。再比如说公共浴场，很多人不讲究卫生，随意使用别人的毛巾，最后感染上传播性疾病。 健康是我们最宝贵的财富，只有身体健康，才能去完成更多事情。我们不仅要讲究个人卫生，也要讲究公共卫生，这样技能保护自己，也能保护大家。 我的业余生活 一周七天，五天工作日，两天放假日。放假是大部分学生和打工人的最爱了。因为可以睡懒觉，好好休息一下，也可以继续学习工作，或者是出去玩，放松心情。总之，放假的时候，大家可以按照自己的规划和心情安排时间。 我的假日生活主要分为两部分。第一部分就是去搜索一些学习网站，学习一些新的知识和技能。我假日里面学习的东西十分广泛，可以是专业学习方面的，比如说学习一些定量研究方法的软件操作，更好地提升我的专业能力；也可以看一些做饭炒菜的视频，跟着学习学习。因为我特别喜欢研究美食，也喜欢做菜给自己和家人吃，我觉得自己动手做的饭菜是最美味的；除此以外，我还会学习一些视频剪辑的技能。因为，我喜欢记录一些生活中的小事，我认为通过摄影摄像把自己的生活记录下来是一件很棒的事情，以后看到这些视频一定会有很多快乐。 我的另一部分假日生活主要是运动。运动能够增强人的体质，也能放松人的心情，从而能够更好地去迎接学习和工作任务。我从小热爱体育，爱跑爱跳，因此我喜欢很多体育运动，比如说羽毛球、足球、游泳等。我最喜欢的就是羽毛球。每次休息的时候，我就会叫上我的好朋友去羽毛球馆打羽毛球。我们打羽毛球还不是随便打打，有单打、双打。每次运动完之后都是一身汗，但我们都很开心，也很放松。运动完后回到家洗个澡躺在沙发上玩玩手机或者看看电视，非常舒服。 我觉得我的假日生活充满意义，既有学习、又有运动，每次放假我都觉得像是在给自己充电一样，回到学校又是精力满满。 我喜欢的季节（或天气） 一年有四季，春夏秋冬，它们来回更替，共同展现了世界的美丽。春天百花盛开，鸟语花香；夏天绿树葱葱，荷花摇曳；秋天凉风习习，落叶纷飞；冬天银装素裹、安静肃穆。每一个季节都有不同的特点，而我最喜欢的便是夏季。 有人说夏天艳阳高照，紫外线强，出门就容易晒黑，精心打扮的妆容也把持不了多久。然而，在夏天我可以做很多我喜欢的事情。外面烈日炎炎，那我就待在家里，开着空调，从冰箱拿出我最爱的冰镇西瓜，一边看电视一边吃西瓜，特别舒服，这是夏天最享受的事情；晚饭之后，太阳落山，天气没有那么热了，我就和同学或者家人去公园散散步，欣赏美丽的晚霞，夏天的晚霞五颜六色的，特别漂亮。我最喜欢的运动是游泳，夏天的时候，我可以和好朋友一起去游泳馆游泳，或者是水上乐园玩耍，清凉极了。除此以外，夏天可以吃到各种各样的水果，比如葡萄、桃子、哈密瓜，而且我喜欢果园采摘，吃自己亲手采摘的水果，心里美滋滋的。每个女孩子都有个公主梦，在夏天，可以穿很多漂亮的裙子。 我喜欢夏天，还有一个原因就是可以放暑假，不光是我，我的兄弟姐妹都会放假，而且假期很长，我可以回老家去看我的爷爷奶奶、外公外婆。 学习普通话的体会 普通话是指我国各民族之间普遍通用的一种语言，我国更是通过法律确定了“国家通用语言”的法定地位。我国历史悠久、幅员辽阔、民族多样，每个地区和民族由于地理隔阂和历史等，形成了各具特色的交流语言。但不同的语言会造成叫交流上的隔阂，进而组织文化传播及各民族的团结合作，因此，学好普通话具有重要意义。 教师作为传播知识的使者，拥有一口流利的普通话是十分必要的。为了顺利获得教师资格证，我努力练习了普通话近一个月。刚开始，我自认为自己普通话非常不错，应该随便讲讲就可以顺利通过，结果通过相关软件进行测试，发现我仍然存在一些问题。在第一项当中，我有一些不认识的字，甚至有一些字很熟悉但也会读错；在第二项中，我的轻声和儿化音也有一些问题。第三项朗读短文中也存在一些陌生字词，读的也不是特别流利。 在这种情况下，我摆正态度，开始认真练习普通话。首先，我准备了一个笔记本将不认识的字词记录下来，然后查字典，标记好他们的正确读音，最后在跟着软件进行练习；第二，每天花一个小时练习短文。我采取的方法是听一篇读一篇，这样我能及时掌握文章读起来的节奏。当我慢慢熟悉起来后，我就会注重每一个字词的发音，使发音尽量饱满，准确。与此同时，我会通过普通话测试软件来检验我的练习成果。不过，为了保证我的发音准确，我也会请已经顺利通过普通话测试的舍友帮助我，纠正我错误的发音，提供一些意见给我。 我相信，在我的努力下，我一定会顺利通过普通话测试并取得不错的成绩。 谈谈服饰 服饰的重要性 体现个人品味社会地位卫生习惯 与服饰相关的社会现象：追求名牌 服饰是一个人的穿着，包括衣服、裤子、写字、帽子等等。小时候，爸爸妈妈给我们买服饰的出发点主要是保暖。穿的干净会被别人夸讲卫生。后来，慢慢长大发现服饰还有很多作用。服饰可以提现一个人的社会身份。在中国古代王朝，文官的衣服上印着的是鹤，武官的衣服上则大多是麒麟、老虎。现代社会也是一样，就拿本科生毕业来说，学士帽上不同的流苏颜色也代表着不同的学位级别，黑色代表学士学位，深蓝色代表硕士学位，红色代表博士学位。 与此同时，我们要分清场合，选择合适的服饰。大学里有很多答辩。每次答辩的时候，选手和老师都会穿正装出席，不会出现短袖短裤、牛仔裤这种穿搭。再比如说，女生在重要场合穿裙子时要以深色为主，裙子要过膝。合适的服饰不仅表现了自身的形象，也是表达对他人的尊重。 除此以外，我还想讲一讲当今大学生追去品牌潮流、互相攀比的社会现象。随着社会的发展，服饰产业发展越来越好。一些学生进入大学后，越来越重视自己的穿衣，看到同学身上穿着乔丹、耐克等名牌衣服，就会把父母给的生活费拿去买跟同学一样的品牌衣服，有些同学甚至因此被诈骗、去借贷。在我看来，这是不对的。人们追求美、追求品质是没有错的，但一些品牌衣服价格高并不是品质比便宜的好，而是一种品牌效应。我们买衣服应该量力而行，只要自己穿着舒服，觉得好看就行，不必特别在意别人的眼光。 我的假日生活 一周七天，五天工作日，两天放假日。放假是大部分学生和打工人的最爱了。因为可以睡懒觉，好好休息一下，也可以继续学习工作，或者是出去玩，放松心情。总之，放假的时候，大家可以按照自己的规划和心情安排时间。 我的假日生活主要分为两部分。第一部分就是去搜索一些学习网站，学习一些新的知识和技能。我假日里面学习的东西十分广泛，可以是专业学习方面的，比如说学习一些定量研究方法的软件操作，更好地提升我的专业能力；也可以看一些做饭炒菜的视频，跟着学习学习。因为我特别喜欢研究美食，也喜欢做菜给自己和家人吃，我觉得自己动手做的饭菜是最美味的；除此以外，我还会学习一些视频剪辑的技能。因为，我喜欢记录一些生活中的小事，我认为通过摄影摄像把自己的生活记录下来是一件很棒的事情，以后看到这些视频一定会有很多快乐。 我的另一部分假日生活主要是运动。运动能够增强人的体质，也能放松人的心情，从而能够更好地去迎接学习和工作任务。我从小热爱体育，爱跑爱跳，因此我喜欢很多体育运动，比如说羽毛球、足球、游泳等。我最喜欢的就是羽毛球。每次休息的时候，我就会叫上我的好朋友去羽毛球馆打羽毛球。我们打羽毛球还不是随便打打，有单打、双打。每次运动完之后都是一身汗，但我们都很开心，也很放松。运动完后回到家洗个澡躺在沙发上玩玩手机或者看看电视，非常舒服。 我觉得我的假日生活充满意义，既有学习、又有运动，每次放假我都觉得像是在给自己充电一样，回到学校又是精力满满。 我的成长之路 每个人出生的时候都是一张白纸，我们不断学习，不断成长，最终才变成了现在的自己。每个人都有属于自己的成长之路，也正是因为这丰富多彩的成长之路让我们每个人都独一无二。在我二十多年的成长路程中，我经历了很多事情，这些事教会了我很多道理。 我从小热爱运动，小学时期还进入了校足球队。进入足球队后，我刻苦训练，球技有很大的提升，很快就成为了主力队员。但小时候认为自己很厉害，容易骄傲，每次分组踢球时，我都不愿意和球技不好的同学组队，比赛时也经常自己一个人往前冲，不爱传球。后来有一次踢球输了，我心情很不好，抱头痛哭，但队友们都跑过来安慰我。待我心情好转后，教练也找我进行谈话，指出了团队合作的重要性，告诉我眼里不仅要有球，也要有队友。在日后的训练和比赛中，我也慢慢发现了队友的优点，学会传球、学会配合，最终我们取得了许多优异的成绩。 体育中有许多团体运动，这件事让我明白了团结合作是一个团队最重要的东西，是取得最终胜利的关键。我们每个人都有属于自己的闪光点，我们要善于发现别人的优点，学会和队友配合，只有这样，团队效益才能发挥到最大。后来，不光是体育活动中，在其他团体合作项目中，我也愈发重视团队精神。 除此以外，我还有很多令我印象深刻的成长经历，比如说小时候偷爸爸妈妈的钱去买零食，被发现后爸爸教育我要通过自己的努力去获得自己想要的东西，不可以随便拿不是自己的东西；再比如高中备考时日日挑灯的奋斗经历教会我坚持不懈；在我的成长道路上，有很多人都给予了我帮助，家人、朋友、老师等等，感谢他们一路陪伴。 谈谈科技发展与社会生活 吃、穿、住、行、联络 21世纪以来，科技发展速度越来越快，尤其是计算机、大数据、人工智能等领域创造了许多令人惊喜的高科技产品。科技发展影响社会生活，它渗透在我们的吃穿住行各个方面，使我们的生活更加便利。 最常见的就是我们的手机。手机最开始出现就引起了社会的轰动，因为它能使远在天边的人相互联系，克服了地理上的距离，使人们的沟通交流越来越便捷。之后，手机不断更新迭代，目前，我们的生活几乎离不开手机，手机上有许许多多的软件。当你饿了的时候，你可以打开美团寻找想吃的东西，然后一件下单，外卖到家；当你想逛街的时候，你可以打开淘宝、京东，浏览者琳琅满目的商品；当你想和远方的朋友聊天时，你可以打开微信，进行视频通话，更进一步拉近两者直接的距离。 除了手机，还有一些别的科技产品。比如说扫地机器人、智能冰箱，减少了我们一些家务方面的压力；比如说点读机、翻译笔，帮助小孩子自我学习；比如说最近很火的人工智能，它们自己作诗、作画，给艺术家提供创作的灵感。 然而，科技是一把双刃剑，他在给我们带来便利的同时也给我们造成了一些麻烦。智能家电的存在让人类越来越懒，不爱干家务；电子产品使小孩子沉迷游戏，危害健康；讨论最为多的便是人工智能是否会取代人类的一些低级工作，进而造成多数人失业，进而引发更大的社会问题。 拥有这些担忧是正常的，但科技本身并没有好与坏，关键在于人类怎么去使用。因此，我们必须正确对待和使用科技，让科技服务我们的社会生活。 我知道的风俗 风俗是一个社会在一定时期内形成的风尚喝、习俗等。中华文化源远流长，博大精深。传统节日就蕴含着许多风俗。 春节的习俗很多。比如除夕夜，大家会坐在一起吃年夜饭。年夜饭非常丰富，而且会将年夜饭留到第二天，意味着“年年有余”。春节的时候，一家人还要围坐在一起吃热腾腾的饺子，希望一家人能够团团圆圆。春节最令小孩子开心的便是拜年收红包了。大年初一早上醒来，就会发现床头有长辈放的一块糕点，旁边放着红包，寓意着“步步高升”。收红包是小孩子的特权，但拜年是每个人都会做的事情。我的爸爸妈妈也会给爷爷奶奶、外公外婆拜年，我和朋友之间也会相互拜年。春节拜年是为了表达祝福，希望自己的亲戚朋友能够身体健康，生活开心。 端午节又是我国的另一个传统文化。端午节的时候大家要挂艾草戴香包，吃咸鸭蛋、喝雄黄酒、吃粽子、赛龙舟。端午节吃粽子还有一个传说呢。相传古时候，爱国诗人屈原因为不能忍受亡国之痛，在五月初五这一天跳入汨罗江。当地的百姓为了保护屈原的躯体不被鱼虾损害，纷纷向河里投粽子。所以每当端午节的时候，人们就会吃粽子纪念屈原。赛龙舟也是端午节的一大风俗。每到端午的时候，就会举行热闹非凡的龙舟比赛。大家齐心协力共同划向终点。 除了春节、端午节，我还知道很多传统节日的风俗。比如说中秋节，一家人围坐在一起吃月饼赏月；重阳节，大家去登山、吃重阳糕等等。每个风俗都有自己的意义，我们应该更多地去学习和了解。 我和体育 从小我们就有体育课，那体育究竟是什么，又有什么作用呢？在我看来，体育是一种在大脑的指挥下来有序调动四肢的一种活动。 经常进行体育锻炼对我们的身心都有很大的好处。一方面，经常进行体育锻炼能够使我们的肌肉得到锻炼，增强我们的心肺功能和体质，减少脂肪，提高身体免疫能力，降低患病风险；另一方面，进行体育锻炼能够调节我们的心理，使我们摆脱负面情绪，同时能够磨炼我们的意志，使我们能够更好地面对生活中的困难。 体育活动不仅包括跑步、跳远、武术等个人项目，也包括了很多团体项目，如篮球、接力游泳等。在五花八门的体育活动中，我最喜欢的是踢足球。小学时期还进入了校足球队。进入足球队后，我刻苦训练，球技有很大的提升，很快就成为了主力队员。但小时候认为自己很厉害，容易骄傲，每次分组踢球时，我都不愿意和球技不好的同学组队，比赛时也经常自己一个人往前冲，不爱传球。后来有一次踢球输了，我心情很不好，抱头痛哭，但队友们都跑过来安慰我。待我心情好转后，教练也找我进行谈话，指出了团队合作的重要性，告诉我眼里不仅要有球，也要有队友。在日后的训练和比赛中，我也慢慢发现了队友的优点，学会传球、学会配合，最终我们取得了许多优异的成绩。 体育中有许多团体运动，这件事让我明白了团结合作是一个团队最重要的东西，是取得最终胜利的关键。我们每个人都有属于自己的闪光点，我们要善于发现别人的优点，学会和队友配合，只有这样，团队效益才能发挥到最大。 后来，不光是体育活动中，在其他团体合作项目中，我也愈发重视团队精神。 我的家乡（或熟悉的地方） 我们的国家地大物博，有很多有特色的城市。北京是我国的首都，是中国文化的典型代表，是对外进行文化交流的重要城市。他也是我的家乡，作为一个北京人，我想给大家介绍介绍北京的建筑和美食 北京有很多标志性建筑。比如说被誉为“世界第八大奇迹”的万里长城。万里长城东起山海关，西至嘉峪关，全场约6700千米，是中国古代一代伟大的防御工程，是中国人民用汗水和智慧建筑而成的。俗话说，“不到长城非好汉”，大家可以去爬爬那万里长城，成为一个名副其实的好汉。再比如说天安门广场。天安门坐落在北京的市中心，是明清时期留下的辉煌建筑。天安门内的建筑都呈对称排列，从天下看，非常美。1949年10月1日，中华人民共和国在这里举行了开国大典，代表着新中国的成立。现在，很多游客去到北京，最想做的事情就是迎着朝阳，观看升旗仪式，我想那是每个中国人最自豪的时刻吧。北京不仅有许多古代建筑，也有现代化建筑。比如说国家体育馆鸟巢。鸟巢的形态像孕育生命的摇篮，远远看去就像小鸟的窝一样，因此命名为鸟巢，这个名字也寄托了人们对生命和未来的希望。作为国家体育馆，鸟巢也承办了2008年北京奥运会，那是我们中国最为荣耀的时刻之一。北京奥运会也收获了世界各国的一致好评。 除了建筑以外，北京的美食也数不胜数。“豆汁”是北京的一种传统美食。豆汁以绿豆为原料，具有养胃、解读、清火的功效，不过它长得不算好看，灰白灰白的，像一团浆糊，而且闻起来有一股酸臭味，听说只有北京人才能接受豆汁，外地人都喝了一口就想吐，不知道是不是真的。 希望大家有空的时候能来我的家乡北京，体验一下北京的魅力。 谈谈美食 俗话说，“民以食为天”，吃饭是最重要的事情。由于文化习俗不同，每个国家、每个地区或者每个民族都有一些具有独特魅力的美食。中国文化博大精深，美食文化便是其中的代表之一，我最喜欢的中华美食就是粽子。 粽子呈三角锥的形状，外面包裹着一层绿色的箬叶，并且散发着淡淡的清香。剥开粽子里面是香甜香甜的糯米，有些地区里面喜欢包着红枣，甜甜的；有的地方喜欢包着咸肉，也很好吃。我喜欢吃红枣粽子，它沾上白糖特别好吃，每次我都能吃好几个。 粽子一般是在端午节的时候吃。相传古时候，爱国诗人屈原因为不能忍受亡国之痛，在五月初五这一天跳入汨罗江。当地的百姓为了保护屈原的躯体不被鱼虾损害，纷纷向河里投粽子。所以每当端午节的时候，人们就会吃粽子纪念屈原。 我不仅喜欢吃粽子，也爱包粽子。首先，要准备好粽叶和糯米馅，粽叶要先放在热水里泡一会，这样的粽叶比较软，包粽子的时候不容易皱，好包一点。等粽叶泡好后，就要把粽叶折叠起来，做成一个窝，然后用糯米填满它，这样就包出了粽子的一个棱角。紧接着用别的粽叶将它包裹起来，最后用绳子把粽子紧紧绑住，如果没绑住，总在放在锅里煮的时候容易露出来。 除了粽子，中国还有很多有特色的美食，比如说饺子、春卷、月饼等等，这些美食都反映出了中国的特色与魅力。 我喜欢的节日 中华文化源远流长，博大精深，节日文化便是其中之一。我最喜欢的节日是春节。春节是我国的传统节日，它标志着一年的结束和开始，寄托了大家对新一年的美好祝愿。 中国的传统节日通常都会有一段故事。春节也不例外，小时候我便被春节的故事深深吸引了。在很久以前，有一个怪兽叫“年”，每到腊月三十，就到村庄里抓人，残害生灵，有一次几个小孩刷鞭子，噼里啪啦的，怪兽就被吓跑了而且，怪兽看到大红纸和火花也十分害怕，后来人们每到春节就会贴大红春联，放鞭炮。 春节的习俗还有很多。比如除夕夜，大家会坐在一起吃年夜饭。年夜饭非常丰富，而且会将年夜饭留到第二天，意味着“年年有余”。春节的时候，一家人还要围坐在一起吃热腾腾的饺子，希望一家人能够团团圆圆。妈妈包的饺子特别好看，我包的就只能凑合着吃。而且，除了包肉饺子和菜饺子，妈妈还会包白糖饺子，每人几个，这是妈妈对我们甜甜的爱，她希望未来我们一家人的日子能够过得甜甜美美。 春节最令小孩子开心的便是拜年收红包了。大年初一早上醒来，就会发现床头有长辈放的一块糕点，旁边放着红包，这在妈妈的老家寓意着“步步高升”。收红包是小孩子的特权，但拜年是每个人都会做的事情。我的爸爸妈妈也会给爷爷奶奶、外公外婆拜年，我和朋友之间也会相互拜年。春节拜年是为了表达祝福，希望自己的亲戚朋友能够身体健康，生活开心。 我喜欢春节，不仅是喜欢春节的故事、习俗，更是喜欢春节热闹的氛围。同时，每到春节，远在四方的亲戚朋友都会相聚一堂，而团圆是春节最大的魅力。 我所在的集体（学校、机关、公司） 个人组成集体，集体成就个人。我们生活在这个世界上总会和别人发生某种联系，进而成为一个集体。我就读于江苏省南京市一所211高校，它被誉为“东方最美校园”，教学质量也非常高，是许多人梦寐以求的大学。与此同时，我所在的班级也非常好，是一个能够让我成就自我的集体。 我们班的人来自五湖四海，甚至有好几个新疆的同学，大家都相处的非常融洽。最开始的时候，我们班开展了一个守护天使的活动，就是大家每个人都有一个自己需要守护的对象，自己也有一个守护自己的人，大家默默地为自己的守护对象送上一些自己的心意，最终大家也通过这个活动熟络起来。新疆同学由于汉语不是特别好，学习上有些吃力，我们班也发起了学习互动小组的活动，一起帮助新疆同学学习。 我是一个组织能力很强的人。当班级里需要搞活动的时候，我就非常积极的组织大家参与。比如说寒假社会实践，由于很多同学没有相关经验，因此我特地开展了一个探索中国春节文化的一个活动，请班上同学将自己家乡的春节文化记录成日记、视频、手帐等等，最后再借助微博、抖音腾讯会议等像更多人传播中国春节的文化。此次活动，大家十分配合，积极参与，活动效果很好。最终，我们也凭借此次活动获得了“暖心团支部”的荣誉称号。后来，在大家的不懈努力下，我们还获评了“特色团支部”的荣誉称号。其实我们班的团结体现在多个方面，每次学校或者学院有活动，大家都会积极参加，并且会带上一些经验不太多的同学，大家最后一起进步。 我非常热爱我们这个班集体，很荣幸能成为其中的一员。我相信，未来，我们班会越来越棒。 谈谈社会公德（或职业道德） 职业道德是一个人从事某种职业的时候，要履行自己的基本职责，遵守相关的要求和规定。遵守职业道德是一个人从事某项职业的基本义务，也反映了这个人的道德素质水平。但在现在社会中仍然出现了一些未能遵守职业道德的事情。 现代社会，竞争越来越激烈，很多家庭都希望自己的小孩能够出人头地，因此有些人就抓住家长望子成龙、望女成凤的心理，做出了一些超越职业道德底线的事情。比如说有些老师上课的时候不给同学讲明白，等到课后就跟家长说小孩子学习能力有待提高，需要报一些补习班，于是老师就可以通过办补习班挣一些外快。现在国家已经在严厉打击这种行为，但仍然有一些人在顶风作案。教师是一个光荣的职业，他应该是无私奉献的，应该毫无保留地将自己地知识教授给同学，而不是有所保留去开一些补习班，这严重违反了职业道德。 不仅老师，其他领域也存在一些违反职业道德的人。比如说前端时间曝光的医院腐败事件，有些医院领导在购买医疗器材吃回扣。医生在我们心中是形象是白衣天使，他的职责是治病救人，就算有些人当上了领导，承担了一定的管理职责，也应该时刻记住他是一名医生，要以病人的利益为重，那些腐败的人忘记了他们成为医生时所宣读的誓言，突破了职业道德的底线，抹黑了医生的形象。 诸如此类的现象会扰乱社会秩序、会侵害人民利益，我们希望这些事情不再发生。一方面，国家要加大惩处力度，打击一些严重违反职业道德，甚至触犯法律的行为；一些行业协会也可以加大监管力度，协助政府；另一方面，我们自己要树立正确的职业观、遵守职业道德。 谈谈个人修养 古人云，“修身、起家、治国、平天下”。个人修养是一个人立身处世的根本，同时对社会的发展、国家的形象也有重要意义。 个人修养体现在方方面面。比如说看电影的时候是一边看电影一边和朋友讲话还是安安静静地看电影，有事出去说；比如说出门在没垃圾桶的情况下是随手扔掉还是一直带在身上，等有垃圾桶的时候再扔；再比如说参加某项正式会议时是穿着衬衫短裤还是着正装出席等等；一个人的修养体现在生活当中的各个方面。 董卿是我非常尊敬和喜爱的主持人。我喜欢她不仅是因为她长得好看，有学识，还因为她的个人修养。2017年，《朗读者》邀请了我国翻译界泰斗许渊冲老先生，但老先生年事已高，只能坐在凳子上接受采访，为了照顾到凳子上的老人，也为了表达对老先生的尊重，董卿选择跪下采访。这一跪更是显示出了她超高的个人修养。 反观先前引起社会热烈讨论的唐山打人事件。男子公然在公共场所对陌生女子实施辱骂、殴打，是一种对女士的侮辱。他的行为不仅触犯了法律，也违反了社会道德，个人修养难以评价。 我们都想成成为个人修养高的人。那我们应该怎么办呢？首先，思想影响行动，我们必须提高我们的知识水平，我们必须要了解社会道德、社会价值观，知道什么是对、什么是错，在什么场合做什么事情，而不是随心所欲。其次，我们要践行社会主义核心价值观，把我们认为是对的事情做出来，如果只是脑子里知道而不用行动去践行，那么就不会产生什么实际效果。 希望每一个人都能够成为一个道德素质高，个人修养强的人，这样，我们的社会才会和谐、才会进步，我们才不会愧对中国“礼仪之邦”的名誉。 我喜欢的明星（或其他知名人士） “春蚕到死丝方尽，蜡炬成灰泪始干”这是描写老师无私奉献的千古名句，而我今天想讲的一名我喜欢的知名人士就是感动中国人物张桂梅老师。 2021年，我在电视上第一次见到张桂梅老师，那时候她被评为感动中国年度人物，需要上台领奖。你别看她皮肤黝黑，皱纹爬满了沧桑的脸庞，走路也慢悠悠慢悠悠的，但谁能想到正是这么一个弱不禁风的人帮助了一千八百多名孩子走出大山，奔赴属于自己的美好未来。颁奖典礼结束后，我查阅相关资料，了解到了张桂梅老师更多的事迹，这也让我深深的喜欢上了她。 张桂梅老师原先在大理一所中学任教，后来丈夫去世后才来到华坪任教，谁想到第二年就查出子宫肌瘤，当地人为了帮她继续治疗，一起募捐来凑手术费和医药费，张桂梅感动不已，创立了儿童福利院，希望用自己的绵薄之力回馈大家的善意；同时，看到大山里的女孩整日在家做苦力，为了让他们走出大山，她希望创办一所免费的女子高级中学。但学校的创立需要很多钱，张桂梅老师去政府企业筹款，五年仅仅筹到一万元期间甚至被误认为骗子，然而她坚持不懈，最终在全社会的帮助下成功创办免费的女子高中；张桂梅老师将自己的一生都奉献给了大山里的孩子，教学之路崎岖坎坷，以至于他患上心脏病、肺气肿等多种疾病，行走困难，但她仍然坚持每天第一个出现在学校里，监督大家学习，也正是她的努力，大山里的孩子慢慢拥有自己的未来和人生。 我喜欢张桂梅老师的知恩图报、喜欢她做事不畏艰辛、喜欢她对大山孩子里的无私 奉献。她的事迹深深感动着我，也鼓励着我成为像她一样优秀的人。 我喜爱的书刊 高尔基说，“书籍是人类进步的阶梯”。通过阅读一些书籍，我们可以发现更广阔的世界、体验更多的人生、明白更多的道理。我喜欢的书刊有很多很多，而且不同的年龄阶段，我喜欢的书刊也有所不同 。 小学的时候，我最喜欢读《淘气包马小跳》系列的书。它是由杨红樱作家写的，主要围绕着马小跳展开叙述。书里讲了马小跳许多有趣的事情，比如说马小跳去竞选“超级市长”，去熊猫自然保护区拍熊猫，和几个好朋友建立“跳跳电视台”等等。小时候的我被马小跳的生活所深深吸引。直至现在，我也觉得马小跳非常可爱。《淘气包马小跳》非常值得小孩子阅读。 等到了初中的时候，我开始喜欢上《读者》。最开始我并不知道这个书刊，还是我和同学去新华书店偶然翻来看看的。《读者》是一个面向社会各界读者的读物，他刊登的文章种类很多，有小说、有散文、有诗歌。而且他还会根据不同的内容划分不同的专栏，方便读者阅读。我最喜欢的是散文期刊，因为里面收录了很多名人作家的散文，比如说汪曾祺。我可以从他们的文章中学习写作的方法。 高中的时候，学习任务紧，没有太多的时间看书，看的最多的就是经典名著。小时候一直看西游记，但一直都是断断续续地看。高中的时候，《西游记》是我们的必读书目，这也给了我一个机会完完整整地读一遍这个故事。也正是这一次完整地阅读，让我对每个人物地性格有了更全面的了解。我最喜欢的还是孙悟空，因为他勇敢，敢于斗争。我们每一个人在困难面前都应该充满信心，相信我们能够取得胜利，我们要勇敢地去闯荡世界。 “活到老，学到老”，每一种类型的书刊都会给我不同的阅读感受，我爱读书。 谈谈对环境保护的认识 1. 环境保护的重要性 2. 环境保护的措施 走在路边，时常能看到公交站台的宣传栏、商场的大屏幕上滚动播放着保护环境的公益广告，呼吁大家保护环境。 曾经的地球是银河系中最为美丽的一颗蓝色星球，但如今地球母亲已经千疮百孔。冬季的天空蒙上了厚重的雾霾，路上的行人只能戴着口罩快步前进；海洋河流不再清澈，垃圾横生，鱼儿逃窜，有时甚至会发出一点臭味儿。与此同时，走在路上，仍会在草坪上看到几个白色塑料。不论是工业发展，还是人们随手扔的垃圾都在一点点破坏我们赖以生存的环境。 如果一直放任环境恶化下去，我们人类的生活也会受到影响。比如全球气候变暖造成冰山融化，空气污染导致人们患有呼吸疾病，河流污染导致水产品不够新鲜对身体健康造成威胁。 我们国家很早就认识到了环境的重要性，先后提出“科学发展观”“绿水金山就是金山银山”等理论理念，呼吁所有人保护环境。目前，国际上已基本达成共识，中国更是提出“双碳”目标，并积极采取措施。那在个人层面上，我们能做那些事情呢？首先，在交通出行方面，我们可以选择购买新能源汽车，与此同时，我们应该坚持绿色出行，尽量乘坐公交车、地铁等公共交通工具；其次我们可以减少一次性物品和塑料产品的使用，每次去超市的时候自己带一个布袋子；如果有机会的话，我们还可以和自己的亲戚朋友一起去种植树木，一起去参加环境保护的宣传志愿等，将“保护环境、人人有责”的理念传播到每个人的耳中。 真心希望我们的环境能够变得越来越好。 我向往的地方 我们的国家地大物博，有很多有特色的城市。北京是我国的首都，是中国文化的典型代表，是对外进行文化交流的重要城市。它是我最向往的地方。 北京有很多标志性建筑。比如说被誉为“世界第八大奇迹”的万里长城。万里长城东起山海关，西至嘉峪关，全场约6700千米，是中国古代一代伟大的防御工程，是中国人民用汗水和智慧建筑而成的。俗话说，“不到长城非好汉”，我就想去爬爬那万里长城，成为一个名副其实的好汉。再比如说天安门广场。天安门坐落在北京的市中心，是明清时期留下的辉煌建筑。天安门内的建筑都呈对称排列，从天下看，非常美。1949年10月1日，中华人民共和国在这里举行了开国大典，代表着新中国的成立。现在，很多游客去到北京，最想做的事情就是迎着朝阳，观看升旗仪式，我想那是每个中国人最自豪的时刻吧。北京不仅有许多古代建筑，也有现代化建筑。比如说国家体育馆鸟巢。鸟巢的形态像孕育生命的摇篮，远远看去就像小鸟的窝一样，因此命名为鸟巢，这个名字也寄托了人们对生命和未来的希望。作为国家体育馆，鸟巢也承办了2008年北京奥运会，那是我们中国最为荣耀的时刻之一。北京奥运会也收获了世界各国的一致好评。我也想去鸟巢看看，去体验体验国家运动员奋斗过的场地。 除了建筑以外，北京的美食也数不胜数。“豆汁”是北京的一种传统美食。豆汁以绿豆为原料，具有养胃、解读、清火的功效，不过它长得不算好看，灰白灰白的，像一团浆糊，而且闻起来有一股酸臭味，听说只有北京人才能接受豆汁，外地人都喝了一口就想吐，我也想尝试尝试豆汁的魅力。 不仅如此，北京人也非常地热情好客，他们展现了中国人的特质，真希望有一天能去北京逛逛。 购物（消费）的感受 人的衣食住行，处处都要花钱，购物自然而然成为了我们生活当中不可缺少的一部分。随着社会的进步和互联网的发展人们的购物方式已经从传统单一的线下购物变成了“线上线下”并行的购物方式。有些人倾向于线下购物，有些人倾向于线上购物。实际上，两种购物方式各有优点和缺点，同时也有需要注意的地方。 线下购物最大的优势就是消费者可以看得见摸得着商品，他们可以亲自试穿衣服，看看这件衣服到底适不适合自己。而且还可以当场检查一下质量问题，检查线头、拉链等等，保证自己购买的商品是完好无损的。在线下购物的时候，消费者可以和店家进行讨价还价，以此减少自己的购物成本。与此同时，线下购物的时候可以和朋友一起，通过逛街购物来增加彼此之间的情谊。而线下购物的缺点就在于消耗的金钱和时间成本大。因为线下购物活动区域小，且商家门店费用贵，因此线下商品一般价格更贵一点。 线上购物的最大优势就是消费者尅跨越时空的限制，随时随地浏览淘宝、京东等，进行线上购物。网上的商品琳琅满目，可选择的空间很大，而且价格低，一般不会出现断货的情况。而且目前物流发展的越来越快，购买的东西很快就能到手。然而，网上容易出现盗版东西，甚至会出现抄袭现象。与此同时，在大数据的帮助下，一些商家可以长时间占领消费者的浏览界面。 总而言之，线上购物和线下购物各有优缺点，而消费者购物时必须要树立理性概念选择适合自己的，也不要被一些广告所蒙蔽。","categories":[{"name":"工具记录","slug":"工具记录","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7%E8%AE%B0%E5%BD%95/"},{"name":"普通话","slug":"工具记录/普通话","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7%E8%AE%B0%E5%BD%95/%E6%99%AE%E9%80%9A%E8%AF%9D/"}],"tags":[]},{"title":"","slug":"culitivate/java技术栈/vue/vue","date":"2023-09-11T07:42:58.420Z","updated":"2023-09-20T08:42:18.846Z","comments":true,"path":"2023/09/46a431ea89f8.html","link":"","permalink":"http://example.com/2023/09/46a431ea89f8.html","excerpt":"","text":"https://www.runoob.com/vue3/vue3-intro.html","categories":[{"name":"culitivate","slug":"culitivate","permalink":"http://example.com/categories/culitivate/"},{"name":"java技术栈","slug":"culitivate/java技术栈","permalink":"http://example.com/categories/culitivate/java%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"vue","slug":"culitivate/java技术栈/vue","permalink":"http://example.com/categories/culitivate/java%E6%8A%80%E6%9C%AF%E6%A0%88/vue/"}],"tags":[]},{"title":"","slug":"plan/jl","date":"2023-09-11T06:50:27.706Z","updated":"2023-09-20T08:42:18.828Z","comments":true,"path":"2023/09/b11122a58045.html","link":"","permalink":"http://example.com/2023/09/b11122a58045.html","excerpt":"","text":"基本信息 教育经历 实习经历 项目经历 掌握能力 Java后台开发简历制作_简历本 (jianliben.com)","categories":[{"name":"plan","slug":"plan","permalink":"http://example.com/categories/plan/"}],"tags":[]},{"title":"","slug":"课程笔记/软件工程基础/软件工程基础","date":"2023-09-11T04:14:42.099Z","updated":"2023-09-20T08:42:18.829Z","comments":true,"path":"2023/09/a304d705bde4.html","link":"","permalink":"http://example.com/2023/09/a304d705bde4.html","excerpt":"","text":"第一章 软件工程概述1.1软件工程的发展历程1.1.1软件危机软件危机指在计算机软件的开发和维护工程中所遇到的一系列严重问题严重问题表现方面: 软件开发进度和成本难以控制 软件产品难以满足用户需求 软件质量难以得到保证 软件产品难以进行维护 软件的文档资料难以管理 软件产品的生产效率难以得到提高 1.1.2软件危机原因 对软件开发缺乏正确的理论指导 软件人员与用户缺乏充分的交流 对软件开发过程缺乏整体认识 对软件产品缺乏有效一致的质量评价 1.1.3 软件的本质特性 复杂性 一致性 可变性 不可见性 1.2 软件工程的概念1.2.1 软件工程的定义专注于规划、设计、开发、测试、维护和管理软件系统的过程实现满足用户要求的软件产品的定义、开发、发布和维护的过程或进行研究的学科 1.2.2 软件工程的目标 降低开发成本 完成需求中各项功能与性能指标 软件易于修改，软件机构易于理解 降低维护费用 按时完成开发与交付 1.2.4 软件工程的基本原理 用分阶段的生命周期计划严格管理 坚持进行阶段评审 执行严格的产品质量控制 采用现代化程序设计技术 结果应能清楚地审查 开发人员应少而精 承认不断改进软件工程的必要性 1.3 软件与软件过程1.3.1 软件的概念软件的定义:程序，数据和文档的有机组合软件的实现是一个从现实问题域（输入）到信息域（输出）的过程，此过程包括程序、数据、文档以及他们之间的联系。 软件的特点: 软件是逻辑实体而非物理实体 软件是智力产品，生产的过程主要集中在研发上 软件永不磨损，但它会退化，直至被弃用 软件开发远未达到软件工程目标提及的产业化生产 软件越来越复杂，今后将会更加复杂 1.3.3 软件生命周期 可行性分析与计划阶段 需求分析阶段 设计阶段 实现阶段 测试阶段 运行和维护阶段 1.4软件过程模型1.4.1瀑布模型瀑布模型，也称软件生存周期模型。优点：（1）在软件工程中占有重要地位，它提供了软件开发的基本框架，这比依靠“个人技艺”开发软件好得多。（2）有利于大型软件开发过程中人员的组织、管理，有利于软件开发方法和工具的研究与使用，从而提高了大型软件项目开发的质量和效率。缺点：（1）阶段的划分完全固定，阶段之间产生大量的文档，极大地增加了工作量；（2）由于开发模型是线性的用户只有等到整个过程的末期才能见到开发成果，从而增加了开发的风险；（3）早期的错误可能要等到开发后期的测试阶段才能发现，进而带来严重后果。适用：（1）在开发时间内需求没有或很少变化；（2）分析设计人员应对应用领域很熟悉；（3）低风险项目（对目标、环境很熟悉）；（4）用户使用环境很稳定；用户除提出需求以外，很少参与开发工作。 1.4.2原型模型优点：（1）可以得到比较良好的需求定义，容易适应需求的变化；（2）有利于开发与培训的同步；（3）开发费用低、开发周期短且对用户更友好。缺点：（1）客户与开发者对原型理解不同；（2） 准确的原型设计比较困难；（3） 不利于开发人员的创新。适用：（1）对所开发的领域比较熟悉而且有快速的原型开发工具；（2）项目招投标时，可以以原型模型作为软件的开发模型；（3）进行产品移植或升级时，或对已有产品原型进行客户化工作时，原型模型是非常适合的。 1.4.3增量模型优点：（1）采用增量模型的优点是人员分配灵活，刚开始不用投入大量人力资源；（2）如果核心产品很受欢迎，则可增加人力实现下一个增量；（3）可先发布部分功能给客户，对客户起到镇静剂的作用。缺点：（1）并行开发构件有可能遇到不能集成的风险，软件必须具备开放式的体系结构；（2）增量模型的灵活性可以使其适应这种变化的能力大大优于瀑布模型和快速原型模型，但也很容易退化为边做边改模型，从而是软件过程的控制失去整体性。适用：（1）进行已有产品升级或新版本开发，增量模型是非常适合的；（2）对完成期限严格要求的产品，可以使用增量模型；（3）对所开发的领域比较熟悉而且已有原型系统，增量模型也是非常适合的。 1.4.4螺旋模型优点：（1）设计上的灵活性,可以在项目的各个阶段进行变更；（2）以小的分段来构建大型系统,使成本计算变得简单容易；（3）客户始终参与每个阶段的开发,保证了项目不偏离正确方向以及项目的可控性；（4） 随着项目推进,客户始终掌握项目的最新信息 , 从而他或她能够和管理层有效地交互。缺点：（1）采用螺旋模型需要具有相当丰富的风险评估经验和专门知识，在风险较大的项目开发中，如果未能够及时标识风险，势必造成重大损失；（2）过多的迭代次数会增加开发成本，延迟提交时间。 适用： 只适合于大规模的软件项目 1.4.5喷泉模型优点： 喷泉模型允许灵活的人员分配，起初不需要投入大量人力资源。 如果核心产品概念受欢迎，可以增加人力资源以实现下一个喷泉。 具有开放式的体系结构，允许并行开发构件。缺点： 并行开发构件可能面临无法集成的风险，需要具备开放式体系结构。 喷泉模型的灵活性可能导致软件过程的控制失去整体性，可能退化为边做边改模型。适用： 适用于已有产品的升级或新版本开发。 对于有严格完成期限要求的产品，可以采用喷泉模型。 在开发领域相对熟悉且已有原型系统的情况下，也适用于喷泉模型。 1.4.6敏捷过程模型优点： 敏捷过程模型强调快速交付和响应变化，适应性强。 可以根据需求不断迭代和改进产品，满足客户的实际需求。 高度合作和沟通，促进团队协作和客户参与。缺点： 对于某些大型项目或要求高度规范的项目，敏捷过程可能不够适用。 需要客户积极参与和不断提供反馈，否则可能导致项目进展不稳定。 需要团队具备高度的自组织和自管理能力。适用： 适用于需要快速交付和频繁变更的项目。 对于客户需求不断演化的项目，敏捷过程模型是非常适合的选择。 需要高度合作和团队协作的项目也适合采用敏捷过程模型。 1.4.7 渐进交付迭代模型优点： 分阶段交付： 渐进交付迭代模型允许将软件系统分成多个可交付的阶段，每个阶段都能够产生部分可用的系统，从而满足客户部分需求。 逐步完善： 通过迭代的方式，每个迭代周期都可以改进和完善之前版本的软件，使其更符合用户需求和质量标准。 风险管理： 通过将项目分成多个迭代，可以更好地管理和控制项目风险，及早发现和解决问题。 客户参与： 客户可以在每个迭代周期中查看和评估部分可用的系统，提供反馈，确保最终的软件产品符合其期望。缺点： 增加复杂性： 管理多个迭代周期和交付阶段可能增加了项目的管理和协调复杂性。 时间和成本： 如果不恰当地规划迭代周期，可能会导致项目超出预算或超过时间表。 需求变化： 随着迭代的进行，客户需求可能会发生变化，需要灵活应对变更，否则可能导致范围膨胀。适用： 大型项目： 渐进交付迭代模型适用于大型和复杂的项目，可以将项目分成多个管理和开发容易控制的部分。 客户需求不确定： 当客户需求不够清晰或可能会变化时，采用迭代方式可以更好地适应变化。 风险管理重要： 当项目中存在重要的风险，需要及早发现和解决时，渐进交付迭代模型是一种合适的选择。 需要快速交付部分功能： 如果需要在项目的早期阶段交付部分功能以满足紧急需求，这种模型也很有用。 1.4.10 软件过程模型的比较 1.5 软件开发方法1.5.1 结构化开发方法首先提出用结构化分析（SA）对软件进行需求分析之后用结构化设计（SD）方法进行系统设计最后用结构化编程（SP）实现软件 提高了软件开发的效率和质量，降低了错误率 1.5.2 面对对象开发方法面对对象&#x3D;对象+类+继承+消息 1.6 案例描述基本 书上基本功能 提高 自动匹配自动筛选自动调剂 另选难度更大的 基本 书本基本功能 提高 考试过程 提交答卷 改卷 手动 自动 分配试卷 成绩分析 平均分统计 分数段统计 知识点掌握分析 考试 选择考试学员 题库选择 配置试卷 组卷 图表 自动链接相关知识点 试题库 判断 单选 多选 按章节 按难度 学员管理 注册 主动导入 同义词近义词反义词数据库","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"软件工程基础","slug":"课程笔记/软件工程基础","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"","slug":"课程笔记/复杂网络/小实验1/task","date":"2023-09-09T02:51:21.450Z","updated":"2023-09-20T08:42:18.847Z","comments":true,"path":"2023/09/68d61741a7b3.html","link":"","permalink":"http://example.com/2023/09/68d61741a7b3.html","excerpt":"","text":"1.networkx+gephi安装2.snap数据集网站，收集数据 3.用networkx构建网络，并且计算 n节点数 m边数 m占最大可能边数的比例 Diameter: 17 average path length k:度 &lt;\\k&gt;:平均度 clustering4.导入gephi，实现可视化 ppt10页 word实验报告networkx和gephi相互验证networkx度分布曲线，python画出与gephi对比gephi官方文档，filter优化显示部分节点，导出svg,布局算法介绍选择一共有多少科学家，连边是什么样的任意两个科学家最短最大值，直径平均路径长度每个科学家平均邻居即平均度科学家的聚集情况，聚集系数，宏观微观某个科学家的度max clique入度出度相关性 数据集介绍【复杂网络系列】SNAP（Stanford Large Network Dataset Collection）实验数据集_snap数据集_sina微博_SNS程飞的博客-CSDN博客选择了ca-GrQc数据集，是一个Collaboration network of Arxiv General Relativity（Arxiv文献中广义相对论的合作网络），无向图 数据处理流程 使用pandas库将网络中边数据的txt格式文件，读取为dataFrame格式 使用networkx库中的Graph()方法初始化网络 使用networkx库中的add_edges_from()初始化图的边信息 降低数据量12345678910111213141516171819202122232425262728import pandas as pdimport networkx as nxfrom pylab import show# 读取 txt 文件txt_path = &quot;E:/blog/first/source/_posts/课程笔记/复杂网络/小实验1/data/CA-GrQc.txt&quot;# csv_path = &quot;E:/blog/first/source/_posts/课程笔记/复杂网络/小实验1/CA-GrQc.csv&quot;# sep 利用正则表达式，以空白符进行分隔df = pd.read_csv(txt_path,sep=&#x27;\\s+&#x27;)# encoding 为 uft_8_sig，防止某些情况下，中文出现乱码# 讲txt转为csv# df.to_csv(csv_path, encoding=&#x27;utf_8_sig&#x27;, index=False)# 初始化图的边G=nx.Graph()edges = [edge for edge in zip(df[&#x27;source&#x27;], df[&#x27;target&#x27;])]G.add_edges_from(edges)# 统计图相关信息print(&quot;该图的相关信息:&quot;,G,len(G),len(G.nodes),len(G.edges))# 计算最大可能边nodescnt=len(G.nodes)maxmcnt=nodescnt*(nodescnt-1)/2re=len(G.edges)/maxmcntprint(&quot;m占最大可能边数的比例:&quot;,re*100,&quot;%&quot;)# 图的可视化nx.draw(G)# show()该图的相关信息: Graph with 5242 nodes and 14496 edges 5242 5242 14496m占最大可能边数的比例: 0.10552782805079051 % 网络统计属性基于networkx： 节点数：len(G.nodes)&#x3D;5242 边数：len(G.edges)&#x3D;14496 就算m占最大可能边数的比例 最大可能边数max&#x3D;len(G.nodes)*(len(G.nodes)-1)&#x2F;2 re&#x3D;len(G.edges)&#x2F;max&#x3D; 0.0010552782805079051 基于gephi的统计： Diameter: 17 （最大直径） average path length 6.049 （平均路径长度） k:度 &lt;\\k&gt;:平均度 5.531 clustering （聚集）：0.687 平均聚集系数 最大团 最大独立集图论学习——最大团与最大独立集 - wsl_lld - 博客园 (cnblogs.com) 可视化结果可视乎结果采用的布局算法介绍Gephi教程——外观和布局 (rstk.cn)Force Atlas布局Force Atlas布局使图更紧凑、可读性强，Force Atlas布局部分参数的作用如下： 惯性：值愈大，图的摇摆幅度越大。 斥力强度：每个节点排斥其他节点的强度，值越大，节点的距离越大。 吸引强度：连接节点之间的吸引力的强度，值越大，有连接的节点越被拉近。 重力：值越小，图越分散；值越大，图越压缩。 速度：布局运动的速度，值越大，图的布局速度越快。 Force Atlas 2布局Force Atlas 2是改进的Force Atlas算法，速度更快。Force Atlas 2布局部分参数的作用如下。 缩放：节点的斥力强度，值越大，斥力越大，图越稀疏。 更强的重力：一个已经定义好的较强的重力。 重力：自定义的重力值，可以比“更强的重力”更强。 劝阻Hubs：只有输入的边会被推到边缘。 LinLog模式：线性和对数模式的切换。 防止重叠：可以把重叠的节点展开。 容差（速度）：布局速度的选取，较小的数值速度较慢，但精度更高。 Fruchterman Reingold布局Fruchterman Reingold布局简称FR布局，FR布局基于再次改进的弹性模型，该布局算法遵循两个简单的原则，即有连接的节点互相靠近和无连接的节点互相排斥。Fruchterman Reingold布局部分参数的作用如下： 区：定义图形的幅度，值越大图越大，也越稀疏。 重力：定义重力值，值越大重力越强，节点越被中心吸引。 速度：定义布局的速度，值越大布局速度越快，但也越不精确。 Yifan Hu布局Yifan Hu布局也是力引导布局的改进版，由胡一凡在2005年提出，在多层级力引导算法中引入了超节点的概念。在这个布局算法中，将一个节点与它远处一簇节点之间的斥力当作此节点与一个超节点间的斥力来计算，从而大大减少了计算量，使得总计算复杂度下降。该布局可以处理几十万个节点规模的图。Yifan Hu布局部分参数的作用如下。 最佳距离：值越大，整个图的尺寸越大。 相对强度：值越大，节点越稀疏；值越小，节点越紧密。 Yifan Hu比例布局Yifan Hu比例布局的参数与Yifan Hu布局的参数相同，实际上这两个布局所起到的作用是相同的，扩展&#x2F;收缩布局的参数只有比例因子，比例因子的设置方法如下。 如果比例因子为1，那么图不会放大也不会缩小。 如果比例因子大于1，那么图会放大，且值越大，放大的比例越大。 如果比例因子小于1，那么图会缩小，且值越小，缩小的比例越大。 如果比例因子为负数，那么在放大或缩小的同时，也会从上下、左右两个方面颠倒图形。","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"复杂网络","slug":"课程笔记/复杂网络","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E5%A4%8D%E6%9D%82%E7%BD%91%E7%BB%9C/"},{"name":"小实验1","slug":"课程笔记/复杂网络/小实验1","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E5%A4%8D%E6%9D%82%E7%BD%91%E7%BB%9C/%E5%B0%8F%E5%AE%9E%E9%AA%8C1/"}],"tags":[]},{"title":"","slug":"culitivate/java技术栈/java/newjava","date":"2023-09-08T06:26:42.573Z","updated":"2023-09-20T08:42:18.829Z","comments":true,"path":"2023/09/d9e801080cc4.html","link":"","permalink":"http://example.com/2023/09/d9e801080cc4.html","excerpt":"","text":"类和对象 对象：属性（静态部分）行为（动态部分） 类实际就是封装对象属性和行为的载体，对象是类抽象出的一个实例 类中对象的属性以成员变量的形式定义；行为以方法的形式定义 封装性 保证类内部数据结构的完整性 继承性多态性 由抽象方法组成的集合就是接口 类成员变量 成员方法外定义的变量 成员方法 权限修饰符 返回值类型 方法名（参数类型 参数名）{ ​ …&#x2F;&#x2F;方法体 return 返回值； } 权限修饰符 访问包位置 private protected public 本类 可见 可见 可见 同包其他类或子类 不可见 可见 可见 其他包的类或子类 不可见 不可见 可见 类的权限会约束成员的权限 https://blog.csdn.net/weixin_34856035/article/details/114793364 局部变量 局部变量是在方法被执行时被创建，在方法执行结束时被销毁。使用时必须赋值或初始化。 this关键字 成员变量与形参相同时，this.变量名指代成员变量 this引用的是本类的一个对象，所以可以作为类的返回值 类的构造方法1234567public class awd&#123; awd(int a)&#123; &#125;&#125;awd a1=new awd(4); this可调用有参构造方法 静态变量、常量和方法 静态方法中不能使用this关键字 静态方法中不可以直接调用非静态方法 类的主方法123public static void main(String[] args)&#123; &#125; 对象 使用new操作符创建对象的同时，将自动调用该类的构造方法 成员变量被声明为static时，本类对象共用此内存 对象的比较 ”&#x3D;&#x3D;“比较对象引用的地址是否相同 (a.equals(b))比较a，b对象引用所指的内容是否相等 对象的销毁 对象超过作用范围或对象被置null值 ScannerJava中在Scanner类里有两种方法可以使用户通过键盘输入字符串 I.next()方法 使用方法是如下： 使用Scanner类创建一个对象，System.in待变系统输入，Scanner代表扫描仪的意思，大概就是通过扫描仪扫描系统输入，然后我们定义一个String字符串类型变量用于存储我们要输入的字符串，next（）方法就是输入字符串。 II.nextLine()方法 使用方法如下： 操作方法也是如上。 那么，这两个方法有什么区别呢？乍一看，nextLine（）方法比next（）方法长一个Line单词，是不是更牛一点呢我们来分析一下长一点的字符串 next（） nextLine（） 通过对比，果然满是伤痕。 next（）方法只输出了字符串中的第一个字母I，因为接下来的空格它识别不了。 而nextLine（）方法输出了整个字符串，因为该方法可以识别字符串中的空格以及回车，是不是很强大。 那么，怎么通过键盘完成一个字符的输入，当然在next（）方法和nextLine（）方法下还有一个方法叫做charAt（args【0】），顾名思义，我们可以看出charAt是字符在什么。。。看一下代码展示吧： next().charAt() 因为charAt(0)这个方法中的参数表示取出字符串中的第几个字符，因为是字符，所以之打印该方法下指定的参数所对应的字符 比如换一个参数： 注意：charAt()这个方法中的参数是args[]一个数组，所以0为下标指向第一个数。 那么我么来看next（）的一个弊端： 可以看出当字符是空格时，next（）方法下的charAt（）无法执行，当然nextLine（）这个方法就可以了，之前字符串的输入也说过，nextLine（）这个方法可以识别空格和回车。 ———————————————— String一、String类String类在java.lang包中，java使用String类创建一个字符串变量，字符串变量属于对象。java把String类声明的final类，不能有类。String类对象创建后不能修改，由0或多个字符组成，包含在一对双引号之间。 二、String类对象的创建字符串声明：String stringName;字符串创建：stringName &#x3D; new String(字符串常量);或stringName &#x3D; 字符串常量; 三、String类构造方法1、public String()无参构造方法，用来创建空字符串的String对象。 1 String str1 &#x3D; new String(); 2、public String(String value)用已知的字符串value创建一个String对象。 1 String str2 &#x3D; new String(“asdf”); 2 String str3 &#x3D; new String(str2); 3、public String(char[] value)用字符数组value创建一个String对象。 121 char[] value = &#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;&#125;;2 String str4 = new String(value);//相当于String str4 = new String(&quot;abcd&quot;); 4、public String(char chars[], int startIndex, int numChars)用字符数组chars的startIndex开始的numChars个字符创建一个String对象。 121 char[] value = &#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;&#125;;2 String str5 = new String(value, 1, 2);//相当于String str5 = new String(&quot;bc&quot;); 5、public String(byte[] values)用比特数组values创建一个String对象。 121 byte[] strb = new byte[]&#123;65,66&#125;;2 String str6 = new String(strb);//相当于String str6 = new String(&quot;AB&quot;); 四、String类常用方法1、求字符串长度public int length()&#x2F;&#x2F;返回该字符串的长度 121 String str = new String(&quot;asdfzxc&quot;);2 int strlength = str.length();//strlength = 7 2、求字符串某一位置字符public char charAt(int index)&#x2F;&#x2F;返回字符串中指定位置的字符；注意字符串中第一个字符索引是0，最后一个是length()-1。 121 String str = new String(&quot;asdfzxc&quot;);2 char ch = str.charAt(4);//ch = z 3、提取子串用String类的substring方法可以提取字符串中的子串，该方法有两种常用参数:1)public String substring(int beginIndex)&#x2F;&#x2F;该方法从beginIndex位置起，从当前字符串中取出剩余的字符作为一个新的字符串返回。2)public String substring(int beginIndex, int endIndex)&#x2F;&#x2F;该方法从beginIndex位置起，从当前字符串中取出到endIndex-1位置的字符作为一个新的字符串返回。 1231 String str1 = new String(&quot;asdfzxc&quot;);2 String str2 = str1.substring(2);//str2 = &quot;dfzxc&quot;3 String str3 = str1.substring(2,5);//str3 = &quot;dfz&quot; 4、字符串比较1)public int compareTo(String anotherString)&#x2F;&#x2F;该方法是对字符串内容按字典顺序进行大小比较，通过返回的整数值指明当前字符串与参数字符串的大小关系。若当前对象比参数大则返回正整数，反之返回负整数，相等返回0。2)public int compareToIgnore(String anotherString)&#x2F;&#x2F;与compareTo方法相似，但忽略大小写。3)public boolean equals(Object anotherObject)&#x2F;&#x2F;比较当前字符串和参数字符串，在两个字符串相等的时候返回true，否则返回false。4)public boolean equalsIgnoreCase(String anotherString)&#x2F;&#x2F;与equals方法相似，但忽略大小写。 1234561 String str1 = new String(&quot;abc&quot;);2 String str2 = new String(&quot;ABC&quot;);3 int a = str1.compareTo(str2);//a&gt;04 int b = str1.compareToIgnoreCase(str2);//b=05 boolean c = str1.equals(str2);//c=false6 boolean d = str1.equalsIgnoreCase(str2);//d=true 5、字符串连接public String concat(String str)&#x2F;&#x2F;将参数中的字符串str连接到当前字符串的后面，效果等价于”+”。 121 String str = &quot;aa&quot;.concat(&quot;bb&quot;).concat(&quot;cc&quot;);2 相当于String str = &quot;aa&quot;+&quot;bb&quot;+&quot;cc&quot;; 6、字符串中单个字符查找1)public int indexOf(int ch&#x2F;String str)&#x2F;&#x2F;用于查找当前字符串中字符或子串，返回字符或子串在当前字符串中从左边起首次出现的位置，若没有出现则返回-1。2)public int indexOf(int ch&#x2F;String str, int fromIndex)&#x2F;&#x2F;改方法与第一种类似，区别在于该方法从fromIndex位置向后查找。3)public int lastIndexOf(int ch&#x2F;String str)&#x2F;&#x2F;该方法与第一种类似，区别在于该方法从字符串的末尾位置向前查找。4)public int lastIndexOf(int ch&#x2F;String str, int fromIndex)&#x2F;&#x2F;该方法与第二种方法类似，区别于该方法从fromIndex位置向前查找。 1234561 String str = &quot;I am a good student&quot;;2 int a = str.indexOf(&#x27;a&#x27;);//a = 23 int b = str.indexOf(&quot;good&quot;);//b = 74 int c = str.indexOf(&quot;w&quot;,2);//c = -15 int d = str.lastIndexOf(&quot;a&quot;);//d = 56 int e = str.lastIndexOf(&quot;a&quot;,3);//e = 2 7、字符串中字符的大小写转换1)public String toLowerCase()&#x2F;&#x2F;返回将当前字符串中所有字符转换成小写后的新串2)public String toUpperCase()&#x2F;&#x2F;返回将当前字符串中所有字符转换成大写后的新串 1231 String str = new String(&quot;asDF&quot;);2 String str1 = str.toLowerCase();//str1 = &quot;asdf&quot;3 String str2 = str.toUpperCase();//str2 = &quot;ASDF&quot; 8、字符串中字符的替换1)public String replace(char oldChar, char newChar)&#x2F;&#x2F;用字符newChar替换当前字符串中所有的oldChar字符，并返回一个新的字符串。2)public String replaceFirst(String regex, String replacement)&#x2F;&#x2F;该方法用字符replacement的内容替换当前字符串中遇到的第一个和字符串regex相匹配的子串，应将新的字符串返回。3)public String replaceAll(String regex, String replacement)&#x2F;&#x2F;该方法用字符replacement的内容替换当前字符串中遇到的所有和字符串regex相匹配的子串，应将新的字符串返回。 123451 String str = &quot;asdzxcasd&quot;;2 String str1 = str.replace(&#x27;a&#x27;,&#x27;g&#x27;);//str1 = &quot;gsdzxcgsd&quot;3 String str2 = str.replace(&quot;asd&quot;,&quot;fgh&quot;);//str2 = &quot;fghzxcfgh&quot;4 String str3 = str.replaceFirst(&quot;asd&quot;,&quot;fgh&quot;);//str3 = &quot;fghzxcasd&quot;5 String str4 = str.replaceAll(&quot;asd&quot;,&quot;fgh&quot;);//str4 = &quot;fghzxcfgh&quot; 9、其他类方法1)String trim()&#x2F;&#x2F;截去字符串两端的空格，但对于中间的空格不处理。 12341 String str = &quot; a sd &quot;;2 String str1 = str.trim();3 int a = str.length();//a = 64 int b = str1.length();//b = 4 2)boolean startsWith(String prefix)或boolean endWith(String suffix)&#x2F;&#x2F;用来比较当前字符串的起始字符或子字符串prefix和终止字符或子字符串suffix是否和当前字符串相同，重载方法中同时还可以指定比较的开始位置offset。 1231 String str = &quot;asdfgh&quot;;2 boolean a = str.startsWith(&quot;as&quot;);//a = true3 boolean b = str.endWith(&quot;gh&quot;);//b = true 3)regionMatches(boolean b, int firstStart, String other, int otherStart, int length)&#x2F;&#x2F;从当前字符串的firstStart位置开始比较，取长度为length的一个子字符串，other字符串从otherStart位置开始，指定另外一个长度为length的字符串，两字符串比较，当b为true时字符串不区分大小写。4)contains(String str)&#x2F;&#x2F;判断参数s是否被包含在字符串中，并返回一个布尔类型的值。 1231 String str = &quot;student&quot;;2 str.contains(&quot;stu&quot;);//true3 str.contains(&quot;ok&quot;);//false 5)String[] split(String str)&#x2F;&#x2F;将str作为分隔符进行字符串分解，分解后的字字符串在字符串数组中返回。 121 String str = &quot;asd!qwe|zxc#&quot;;2 String[] str1 = str.split(&quot;!|#&quot;);//str1[0] = &quot;asd&quot;;str1[1] = &quot;qwe&quot;;str1[2] = &quot;zxc&quot;; 五、字符串与基本类型的转换1、字符串转换为基本类型java.lang包中有Byte、Short、Integer、Float、Double类的调用方法：1)public static byte parseByte(String s)2)public static short parseShort(String s)3)public static short parseInt(String s)4)public static long parseLong(String s)5)public static float parseFloat(String s)6)public static double parseDouble(String s)例如： 1231 int n = Integer.parseInt(&quot;12&quot;);2 float f = Float.parseFloat(&quot;12.34&quot;);3 double d = Double.parseDouble(&quot;1.124&quot;); 2、基本类型转换为字符串类型String类中提供了String valueOf()放法，用作基本类型转换为字符串类型。1)static String valueOf(char data[])2)static String valueOf(char data[], int offset, int count)3)static String valueOf(boolean b)4)static String valueOf(char c)5)static String valueOf(int i)6)static String valueOf(long l)7)static String valueOf(float f)8)static String valueOf(double d)例如： 121 String s1 = String.valueOf(12);2 String s1 = String.valueOf(12.34); 3、进制转换使用Long类中的方法得到整数之间的各种进制转换的方法：Long.toBinaryString(long l)Long.toOctalString(long l)Long.toHexString(long l)Long.toString(long l, int p)&#x2F;&#x2F;p作为任意进制 StringBuffer StringBuffer和StringBuilder类的对象能被多次修改且不产生新的对象 StringBuffer 方法以下是 StringBuffer 类支持的主要方法： 序号 方法描述 1 public StringBuffer append(String s) 将指定的字符串追加到此字符序列。 2 public StringBuffer reverse() 将此字符序列用其反转形式取代。 3 public delete(int start, int end) 移除此序列的子字符串中的字符。 4 public insert(int offset, int i) 将 int 参数的字符串表示形式插入此序列中。 5 insert(int offset, String str) 将 str 参数的字符串插入此序列中。 6 replace(int start, int end, String str) 使用给定 String 中的字符替换此序列的子字符串中的字符。 以下列表列出了 StringBuffer 类的其他常用方法： 序号 方法描述 1 int capacity() 返回当前容量。 2 char charAt(int index) 返回此序列中指定索引处的 char 值。 3 void ensureCapacity(int minimumCapacity) 确保容量至少等于指定的最小值。 4 void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) 将字符从此序列复制到目标字符数组 dst。 5 int indexOf(String str) 返回第一次出现的指定子字符串在该字符串中的索引。 6 int indexOf(String str, int fromIndex) 从指定的索引处开始，返回第一次出现的指定子字符串在该字符串中的索引。 7 int lastIndexOf(String str) 返回最右边出现的指定子字符串在此字符串中的索引。 8 int lastIndexOf(String str, int fromIndex) 返回 String 对象中子字符串最后出现的位置。 9 int length() 返回长度（字符数）。 10 void setCharAt(int index, char ch) 将给定索引处的字符设置为 ch。 11 void setLength(int newLength) 设置字符序列的长度。 12 CharSequence subSequence(int start, int end) 返回一个新的字符序列，该字符序列是此序列的子序列。 13 String substring(int start) 返回一个新的 String，它包含此字符序列当前所包含的字符子序列。 14 String substring(int start, int end) 返回一个新的 String，它包含此序列当前所包含的字符子序列。 15 String toString() 返回此序列中数据的字符串表示形式。 包装类https://blog.csdn.net/geekmubai/article/details/82024483 Integer.valueof()和Integer.parseInt()的区别https://blog.csdn.net/jdsjlzx/article/details/106352216 数组(引用数据类型) 一维数组初始化 123int a[]=new int[]&#123;4,5,9&#125;;int a[]=&#123;5，5，5&#125;；int a[]=new int[12]; 二维数组初始化 123int a[][]=new int[3][4];int a[][]=&#123;&#123;3,4&#125;,&#123;5,6&#125;&#125;;int a[][]=new int[][]&#123;&#123;1,2&#125;,&#123;3,4&#125;&#125;; 遍历数组 1234567891011121314151617181920基础方法for(int k = 0;k&lt;a.length;k++) for(int c = 0;c&lt;a[k].length;c++&#123; System.out.println(b[k][c]); &#125; foreach语句int arr2[][]=&#123;&#123;1,2&#125;,&#123;3,4&#125;&#125;;int i = 0;for(int x[]:arr2)&#123; i++; int j = 0; for(int e:x)&#123; j++; if(i==arr2.length&amp;&amp;j=x.length)&#123; System.out.println(e); &#125;else System.out.println(e+&quot;,&quot;); &#125;&#125; foreach语句 1234567891011121314151617for(元素变量x:遍历对象obj)&#123; 引用了x的java语句；&#125;一维数组int arr[]=&#123;1,2,3&#125;;for(int x:arr)&#123; System.out.println(x);&#125;二维数组int arr2[][]=&#123;&#123;1,2&#125;,&#123;3,4&#125;&#125;;for(int x[]:arr2)&#123; for(int e:x)&#123; System.out.println(e); &#125;&#125; Ayyays类填充替换数组元素fill123456import java.util.Arrays; //导入java.util.Arrays类int arr[]=new int[5];Arrays.fill(arr,8);//&#123;8,8,8,8,8&#125;int arr2[]=new int[]&#123;1,2,3,4&#125;Arrays.fill(arr2,1,2,8)//&#123;1,8,3,4&#125;//(数组,fromIndex(包括),toIndex(不包括)，替换数) 数组排序(升序)大写字母在小写字母前面sort12345678910import java.util.Arrays;public class paixu&#123; public static void main(String []args)&#123; int arr[]=new int[]&#123;3,2,1&#125;; Arrays.sort(arr); for(int x:arr)&#123; System.out.println(x);//1，2，3 &#125; &#125;&#125; 复制数组(新数组长度大于旧数组:整型用0，char型用null)copyOf,copyOfRange1234567891011121314import java.util.Arrays;public class copy&#123; public static void main(String []args)&#123; int arr[]=new int[]&#123;3,2,1&#125;; int arr2[]=Arrays.copyOf(arr,5);//5为新数组长度 int arr3[]=Arrays.copyOfRange(arr,0,2); for(int x:arr2)&#123; System.out.println(x);//3,2,1,0,0 &#125; for(int y:arr3)&#123; System.out.println(y);//3,2 &#125; &#125;&#125; 数组查询binarySearch1234567891011121314import java.util.Arrays;public class Search&#123; public static void main(String []args)&#123; int arr[]=new int[]&#123;5,3,1&#125;; Arrays.sort(arr); int index=Arrays.binarySearch(arr,3);//2 int index2=Arrays.binarySearch(arr,4);//-3 int index3=Arrays.binarySearch(arr,0,1,2);//-2 System.out.println(index); System.out.println(index2); System.out.println(index3); &#125;&#125; 数字处理类https://blog.csdn.net/qq_42182367/article/details/82018861 继承、多态、抽象类、接口继承1234class Text2 extends Text&#123; &#125; 细节 子类继承了所有的属性和方法，非私有的属性和方法可以在子类直接访问，但是私有属性和方法不能在子类直接访问，要通过父类提供公共（非私有即可）的方法去访问 子类必须调用父类的构造器，完成父类初始化(默认调用super()) 当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中使用super指定使用父类的哪个构造器 要指定父类构造器，使用super(参数) super()使用时必须放在子类构造器的第一条（super()只能在构造器中使用，super.***不是） super()和this()都只能放在第一条，因此在构造器中不能共存。 java所有类都是Object类的子类，Object时是所有类的基类 父类构造器的调用不限于直接父类，将一直往上追溯直到Object类（顶级父类） 重写时不能降低方法的修饰权限范围 内存布局 重名时的查找规则：首先看子类是否有该属性，有且可以访问则返回信息，如果子类没有则看父类，以此向上类推 super关键字 可以访问父类的属性方法，但不能访问私有 调用父类构造器的好处:分工明确 当子类中有和父类重名的成员时，味蕾访问父类成员必须通过super。如果没有重名，使用super、this、直接访问效果是一样的 super查找规则和继承一样 重载以及重写&#x2F;覆盖 方法重载的主要特点有以下几点：第一个特点是方法名是相同的;第二个特点是方法的个数、顺序、参数类型至少有一项是不相同的;第三个特点是方法的返回类型不一定要是相同的;第四个特点是方法的修饰符也可以是不相同的 方法覆盖&#x2F;重写的特点主要有以下几点：第一个特点是方法覆盖只存在于子类和父类之间，在同一个类中的方法不能被覆盖;第二个特点是父类方法抛出的异常可以比子类方法更多; 第三个特点是父类方法的名称、参数签名和返回类型与子类方法的是一致的; 第四个特点是子类是不允许将父类的静态方法覆盖为非静态方法，父类的非静态方法也不能被子类覆盖为静态方法;第五个特点是子类方法不能缩小父类方法的访问权限;第六个特点是子类不能覆盖父类的私有方法;第七个特点是子类可以通过两种途径覆盖父类的抽象方法：一种是子类实现父类的抽象方法，另一种是子类重新声明父类的抽象方法;第八个特点是父类的.非抽象方法可以被覆盖为抽象方法。 多态 介绍：方法或对象具有多种形态 方法的多态 重写和重载体现多态 对象的多态（核心） 一个对象的编译类型和运行类型可以不一样eg.Animal animal &#x3D; new Dog();&#x2F;&#x2F;子类，Animal是编译类型，Dog是运行类型 编译类型在定义对象时，就确定了，不能改变 运行类型可以改变 animal &#x3D; new Cat(); 多态机制合理运用编译类型为父类可以简化代码 向上转型 本质：父类的引用指向了子类的对象 语法： 父类类型 引用名 &#x3D; new 子类类型(); 特点：编译类型在左，运行类型在右,可以调用父类所有成员，但不能调用子类特有成员，因为编译阶段有编译类型决定 向下转型 语法：子类类型 引用名 &#x3D; （子类类型）父类引用 只能强转父类引用，不能强转父类的对象 要求父类的引用必须指向的是当前目标类型的对象Dog dog &#x3D; (Dog) animal; 当向下转型后，可以调用子类类型中所有的成员 多态绑定机制 当调用对象方法时，方法会和对象的内存地址&#x2F;运行类型绑定 当调用对象属性时，无动态绑定机制，哪里声明，哪里使用 123456789101112131415161718192021222324252627282930313233343536373839package extend;public class test &#123; public static void main(String[] args)&#123; A a=new B(); System.out.println(a.sum());//32 &#125;&#125;class A &#123; int i=10; public int getI()&#123; return i; &#125; public int sum()&#123; return getI()+11; &#125; public int sum1()&#123; return i+10; &#125;&#125;class B extends A&#123; int i=21; public int getI()&#123; return i; &#125;// public int sum()&#123;// return getI()+20;// &#125; public int sum1()&#123; return i+20; &#125;&#125; 多态数组 利用多态以及动态绑定 实现子类特有方法：向下转型 抽象类（Static）一、介绍 Abstract，即抽象。笼统的描述一类东西。 打个比方： 我们说车子都可以跑(run)。但有几个轮子，怎么跑，对于不同的车有不同的结果。自行车2个轮子需要人踩着跑，三轮车有3个轮子可以人踩、也能电动，汽车发动机推动跑等等，那么“车”的表达为抽象的。 特点： abstract可以修饰类，也可以修饰方法；abstract修饰的类可以被继承和实现，但是这个类本身不能被实例化；抽象方法必须在抽象类中，抽象类中可以有非抽象的方法；抽象类中可以没有抽象方法，这样做的作用是这个类不可以被实例化；抽象类的子类在继承抽象类后，必须把父类中的抽象方法重写，否则子类也会自动变为抽象类；抽象方法用于被子类继承后重写。即是父类的抽象方法是空的，必须由子类继承之后在子类中由子类实现，这可以达到不同子类可以根据自己的特性来定义自己从父类继承过来的抽象方法；abstract不能与final关键字共存，因为final关键字修饰的类是不能被继承的；abstract不能与private关键字共存，因为私有的东西不能继承；abstract不能与static关键字共存，当static修饰方法时，该方法可以通过类名直接调用，而abstract修饰的抽象方法是不能被调用的；abstract修饰的类中的普通方法可以通过该抽象类的子类直接调用。抽象类与interface关键字： 当一个抽象类中的所有成员只有抽象方法时，便是一个接口，可以用关键字interface表示；接口中的成员有两种：1.全局常量 2.抽象方法 ；接口中的权限必须是public，若没写public，会自动加上public；接口中有抽象方法，因此接口也是抽象类，不可以实例化。所以其子类也必须覆盖了接口中所有的抽象方法后，才能实例化，否则他也是一个抽象类。 二、优缺点 抽象类有什么好处呢？1、由于抽象类不能被实例化，最大的好处就是通过方法的覆盖来实现多态的属性。也就是运行期绑定2、抽象类将事物的共性的东西提取出来，由子类继承去实现，代码易扩展、易维护。 三、不能和下列关键字共存 abstract是抽象类的关键字，也是抽象方法声明上必须加的修饰符，在定义方法上它一般不能与以下几个关键字共存： 1、和static:abstract class A {undefinedpublic abtract static void method();}static修饰后可以直接类名调用方法，但是抽象方法没有实现体，调用无意义； 2、和final:final修饰的类不能被继承，修饰的方法不能被重写，修饰的成员变量只能为常量；但是继承的子类要重写这个抽象方法，所以会出现矛盾； 3、和private:抽象方法是为了让子类重写并给定实现体，但是private修饰的方法只能本类访问，所以矛盾。 接口12345678public interface b1&#123; (public static final)int a; （public abstract） void draw();&#125;public a extends b implements b1&#123; &#125; 接口中方法必须被定义为public abstract 接口中定义的如何字段都是public static final的 类的高级特性 package 包名 import static 静态成员&#x2F;&#x2F;后可直接使用该成员方法 final常量需用大写字母并且加下划线进行连接 VALUE_1 定义为final的数据无论是常量，对象引用还是数组在主函数中都不能被改变 static final可以做到引用对象也不改变 123456789public class finaldatatest&#123; final int A_1=6; final int B_1; public finaldatatest()&#123; B_1=5; &#125;&#125; final方法不能被子类覆盖 final类不能被继承，类中的方法被隐式定义为final,但类中的成员变量可以被定义为final或非final 内部类 内部类可以访问外部类成员，外部不可直接访问内部 主方法中实例化内部类对象 外部类中可直接实例化内部对象引用 12345public static void main(String[] args)&#123; Outercalss out = new Outerclass(); Outerclass.innerclass in = out.new innercalss(); Outerclass.innercalss in = out.doit();//doit是返回类型为innerclass的外部类的非静态方法return new innerclass&#125; 局部内部类：在类的方法或任意作用域中定义内部类，该内部类可以访问外部类成员 匿名内部类: 123return new 类或接口名()&#123; //内部类体&#125; 静态内部类P207 内部类的继承P208 异常处理12345678910111213141516171819202122232425262728try&#123; //程序代码块 &#125;catch(Exception e)&#123; //异常处理&#125;finally&#123; //程序块不论是否异常都被执行 //finally代码块的职责不在于对变量进行赋值等操作，而是清理资源、释放连接、关闭管道流等操作&#125;//例子public class wa &#123; public static void main(String[] args) &#123; TEst t = null; try &#123; t.cc = 10 / 0; &#125; catch (NullPointerException ne) &#123; System.out.println(&quot;--------&quot;); &#125; catch (ArithmeticException ae) &#123; System.out.println(&quot;+++++++&quot;); &#125; System.out.println(&quot;===&quot;); &#125;&#125;//out+++++++=== 自定义异常12345public calss MyException extends Exception&#123; public MyException(String ExceptionName)&#123; super(ExceptionName); &#125;&#125; throw1234567891011public void method()thorws Exception&#123; &#125;public static void main(String[] args)&#123; try &#123; method(); &#125; catch (Exception ne) &#123; System.out.println(&quot;--------&quot;); &#125; &#125; Swing程序设计（见书）集合类(数据结构)（见书）list123456789101112131415161718192021222324252627282930313233343536List&lt;String&gt; list =new LinkedList&lt;String&gt;();list.add(&quot;zstr1&quot;);list.add(&quot;astr2&quot;);list.add(&quot;cstr3&quot;);list.add(&quot;bstr4&quot;);//列表的排序 //1 list.sort(new Comparator&lt;String&gt;() &#123; @Override public int compare(String o1, String o2) &#123; // TODO Auto-generated method stub return o2.compareTo(o1); &#125; &#125;); //2 Collections.sort(list, new Comparator&lt;String&gt;() &#123; @Override public int compare(String o1, String o2) &#123; // TODO Auto-generated method stub return o2.compareTo(o1); &#125; &#125;); //列表的遍历 //1 for(String st:list) &#123; System.out.println(st); &#125; //2 Iterator&lt;String&gt; itlist=list.iterator(); while(itlist.hasNext()) &#123; String str=itlist.next(); System.out.println(str); &#125; set1234567891011121314151617181920212223Set&lt;String&gt; set =new TreeSet&lt;String&gt;(new Comparator&lt;String&gt;() &#123; @Override public int compare(String o1, String o2) &#123; // TODO Auto-generated method stub return o2.compareTo(o1); &#125; &#125;);set.add(&quot;zstr1&quot;); set.add(&quot;astr2&quot;); set.add(&quot;cstr3&quot;); set.add(&quot;bstr4&quot;);//set的遍历 //1 for(String s:set) &#123; System.out.println(s); &#125; //2 Iterator&lt;String&gt; itset=set.iterator(); while(itset.hasNext()) &#123; String sttString = itset.next(); System.out.println(sttString); &#125; map1234567891011121314151617181920212223242526272829303132//map的排序 Map&lt;Integer,String&gt; map =new TreeMap&lt;Integer,String&gt;(new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; // TODO Auto-generated method stub return o2 - o1; &#125; &#125;); map.put(1, &quot;zstr1&quot;); map.put(2, &quot;astr2&quot;); map.put(3, &quot;cstr3&quot;); map.put(4, &quot;bstr4&quot;); //map的遍历 //1 for(Map.Entry&lt;Integer, String&gt; entry:map.entrySet()) &#123; System.out.print(entry.getKey()+&quot; ：&quot;); System.out.println(entry.getValue()); &#125; //2 Iterator&lt;Map.Entry&lt;Integer,String&gt;&gt; iterator=map.entrySet().iterator(); while(iterator.hasNext()) &#123; Map.Entry&lt;Integer,String&gt; entry=iterator.next(); System.out.print(entry.getKey()+&quot; ：&quot;); System.out.println(entry.getValue()); &#125; for(int i=65;i&lt;=122;i++) &#123; System.out.print((char)i+&quot;&quot;); &#125; CollectionsListList里存放的对象是有序的，同时也是可以重复的，List关注的是索引，拥有一系列和索引相关的方法，查询速度快。因为往list集合里插入或删除数据时，会伴随着后面数据的移动，所有插入删除数据速度慢。 ArrayListArrayList 是一个可改变大小的数组.当更多的元素加入到ArrayList中时,其大小将会动态地增长.内部的元素可以直接通过get与set方法进行访问,因为ArrayList本质上就是一个数组. 在初始化ArrayList时，会构建空数组（Object[] elementData&#x3D;{}）。ArrayList是一个无序的，它是按照添加的先后顺序排列，当然，他也提供了sort方法，如果需要对ArrayList进行排序，只需要调用这个方法，提供Comparator比较器即可. LinkedListLinkedList是基于链表的，它是一个双向链表，每个节点维护了一个prev和next指针。同时对于这个链表，维护了first和last指针，first指向第一个元素，last指向最后一个元素。LinkedList是一个无序的链表，按照插入的先后顺序排序，不提供sort方法对内部元素排序。 在添加和删除元素时具有比ArrayList更好的性能.但在get与set方面弱于ArrayList.当然,这些对比都是指数据量很大或者操作很频繁的情况下的对比,如果数据和运算量很小,那么对比将失去意义. Map遍历方法IteratorI&#x2F;OFlie类文件的创建与删除1File file = new File(&quot;E:/word.txt&quot;); 1File file = new File(&quot;E:/&quot;,&quot;word.txt&quot;); 1File f = new File(file,&quot;ww.txt&quot;);//未解决 123456try &#123; file.createNewFile(); System.out.println(&quot;created&quot;);&#125; catch (IOException e) &#123; throw new RuntimeException(e);&#125; 常用方法 创建：createNewFile()在指定位置创建⼀个空⽂件，成功就返回true，如果已存在就不创建，然后返回false。mkdir() 在指定位置创建⼀个单级⽂件夹。mkdirs() 在指定位置创建⼀个多级⽂件夹。renameTo(File dest)如果⽬标⽂件与源⽂件是在同⼀个路径下，那么renameTo的作⽤是重命名， 如果⽬标⽂件与源⽂件不是在同⼀个路径下，那么renameTo的作⽤就是剪切，⽽且还不能操作⽂件夹。 删除：delete() 删除⽂件或者⼀个空⽂件夹，不能删除⾮空⽂件夹，马上删除⽂件，返回⼀个布尔值。deleteOnExit()jvm退出时删除⽂件或者⽂件夹，⽤于删除临时⽂件，⽆返回值。 判断：exists() ⽂件或⽂件夹是否存在。isFile() 是否是⼀个⽂件，如果不存在，则始终为false。isDirectory() 是否是⼀个⽬录，如果不存在，则始终为false。isHidden() 是否是⼀个隐藏的⽂件或是否是隐藏的⽬录。isAbsolute() 测试此抽象路径名是否为绝对路径名。 获取：getName() 获取⽂件或⽂件夹的名称，不包含上级路径。getAbsolutePath()获取⽂件的绝对路径，与⽂件是否存在没关系length() 获取⽂件的⼤⼩（字节数），如果⽂件不存在则返回0L，如果是⽂件夹也返回0L。getParent() 返回此抽象路径名⽗⽬录的路径名字符串；如果此路径名没有指定⽗⽬录，则返回null。lastModified()获取最后⼀次被修改的时间。 ⽂件夹相关：static File[] listRoots()列出所有的根⽬录（Window中就是所有系统的盘符）list() 返回⽬录下的⽂件或者⽬录名，包含隐藏⽂件。对于⽂件这样操作会返回null。listFiles() 返回⽬录下的⽂件或者⽬录对象（File类实例），包含隐藏⽂件。对于⽂件这样操作会返回null。list(FilenameFilter filter)返回指定当前⽬录中符合过滤条件的⼦⽂件或⼦⽬录。对于⽂件这样操作会返回null。listFiles(FilenameFilter filter)返回指定当前⽬录中符合过滤条件的⼦⽂件或⼦⽬录。对于⽂件这样操作会返回null FileInputStream与FileOutputStream类（字节流英文）写入12345678910try &#123; FileOutputStream out = new FileOutputStream(file); byte[] buy = &quot;abc&quot;.getBytes(); out.write(buy); out.close();&#125; catch (FileNotFoundException e) &#123; throw new RuntimeException(e);&#125; catch (IOException e) &#123; throw new RuntimeException(e);&#125; 读取12345678910try &#123; FileInputStream in =new FileInputStream(file); byte[] byt= new byte[1024]; int len = in.read(byt); System.out.println(&quot;content:&quot;+new String(byt,0,len));&#125; catch (FileNotFoundException e) &#123; throw new RuntimeException(e);&#125; catch (IOException e) &#123; throw new RuntimeException(e);&#125; FileWtiter与FileReader(字符流)写入123456789File file = new File(&quot;E:/word.txt&quot;);try&#123; FileWriter out = new FileWriter(file); String s=jTextArea.getText(); out.write(s); out.close();;&#125; catch (IOException e) &#123; throw new RuntimeException(e);&#125; 读取12345678910File file = new File(&quot;E:/word.txt&quot;);try&#123; FileReader in = new FileReader(file); char[] byt=new char[1024]; int len=in.read(byt); jTextArea.setText(new String(byt,0,len)); in.close();;&#125; catch (IOException e) &#123; throw new RuntimeException(e);&#125; 带缓存的输入输出流BufferedInputStream与BufferedOutputStream类 两个构造方法BufferedInputStream(InputStream in)创建带有32个字节的缓存流、BufferedInputStream(InputStream in,int size)指定大小创建缓存区，BufferedOutputStream相同 BufferedOutputStream有一个flush()方法强制将缓存区的数据输出完 BufferedReader与BuferedWriter类 BufferedReader常用方法 read()：读取单个字符 readLine()：读取文本行 BufferedWriter常用方法 write(String s,int off,int len)：写入字符串的每一部分 flush()：刷新该流的缓存强制将缓存区的数据输出完 newLine()：写入一个行分隔符 123456789101112131415161718192021222324252627282930String[] content = &#123;&quot;好久不见&quot;, &quot;你还好吗&quot;, &quot;常联系&quot;&#125;;File file = new File(&quot;E:/word.txt&quot;);//写入try &#123; FileWriter fw = new FileWriter(file); BufferedWriter bufw = new BufferedWriter(fw); for (int k = 0; k &lt; content.length; k++) &#123; bufw.write(content[k]); bufw.newLine(); ; &#125; bufw.close(); ; fw.close();&#125; catch (IOException e) &#123; throw new RuntimeException(e);&#125;//读取try &#123; FileReader fr = new FileReader(file); BufferedReader bufr = new BufferedReader(fr); String s = null; int i = 0; while ((s = bufr.readLine()) != null) &#123; i++; / System.out.println(&quot;第&quot; + i + &quot;行：&quot; + s); &#125;&#125; catch (Exception e) &#123; e.printStackTrace();&#125; 数据输入输出流（等会学）DataInputStream与DataOutputStream，类ZIP压缩输入输出流（等会学）反射（见书）枚举类型与泛型枚举类型1234enum cons&#123; cons_A, consww_B;&#125; 泛型 为防止向下转型时抛出ClassCastException异常 123456789101112131415161718public class fanxincalss&lt;T&gt;&#123; private T over; public T get()&#123; return over;&#125; public void set(T over)&#123; this.over=over; &#125; public static void main(String[] args)&#123; fanxinclass&lt;Boolean&gt; over1 = new fanxinclass&lt;Boolean&gt;(); fanxinclass&lt;Float&gt; over2 = new fanxinclass&lt;Float&gt;(); over1.set(true);//无需类型转换 over2.set(12.3); Blooean b = over1.get();//无需向下转型 Float f = over2.get(); &#125;&#125; 常规用法 定义泛型类时声明多个类型 1Class&lt;T1,T2&gt; 定义泛型类时声明数组类型 123Class&lt;T&gt;&#123; T[] array; &#125; 集合类声明容器的元素（Map&lt;K,V&gt;） 高级用法 限制泛型可用类型 1class 类名称&lt;T extends anyClass&gt;//T必须实现或继承anyClass接口/类 使用类型通配符 123A&lt;? extends List&gt;a=null;a=new A&lt;ArrayList&gt;();a=new A&lt;LinkedList&gt;(); 使用通配符创建的对象不能改变集合中的值，只能获取和删除 定义为泛型的类和接口也可以被继承或实现 多线程继承Thread类12345678public calss ThreadTest extends Thread&#123; public void run()&#123; //do something &#125; public static void main(String[] args)&#123; new ThreadTest().start(); &#125;&#125; 实现Runnable接口123456789101112131415161718192021222324252627282930//直接在类中使用public class A &#123; public A()&#123; Thread t; t= new Thread(new Runnable()&#123; //匿名内部类 实现接口 public void run()&#123; //重写方法 //do something &#125; &#125;); t.start(); &#125; public static void main(String[] args)&#123; new A(); &#125;&#125;//实现接口public class A implements Runnable&#123; public void run()&#123; //do something &#125; public static void main(String[] args)&#123; A a = new A(); Thread t=new Thread(a); t.start(); //new Thread(new A()).start(); &#125;&#125; 线程的生命周期 操作线程线程的休眠12345try&#123;Thread.sleep(1000);&#125;catch(InterruptedExpection e)&#123;e.printStackTrace();&#125; 线程的加入123456try &#123; Thread.sleep(1000); t2.join(); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; 线程的中断121.使用while循环终止2.thread.interrupt(); 线程的优先级1t.setPriority();//54321依次降低 线程的同步12345678public void run()&#123; while(true)&#123; synchronized()&#123; //do something &#125; &#125;&#125; 同步方法 当对象调用了同步方法时，该对象上的其他同步方法必须等待该同步方法执行完毕后才能被执行。将每个能访问共享资源的方法修饰为synchronized 12345678public synchronized void doit()&#123; //do smoething&#125;public void run()&#123; while(true)&#123; doit(); &#125;&#125; 网络通信（见书）数据库操作（见书）swing高级（见书）单例设计模式饿汉式（容易浪费资源）123456789101112131415161718192021package example;public class TestE &#123; public static void main(String[] args)&#123; Girl instance = Girl.getInstance(); System.out.println(&quot;instance = &quot; + instance); &#125;&#125;class Girl&#123; private String name; private static Girl gf = new Girl(&quot;xhh&quot;); private Girl(String name)&#123; this.name=name; &#125; public static Girl getInstance()&#123; return gf; &#125;&#125; 懒汉式123456789101112131415161718192021222324package example;public class TestE &#123; public static void main(String[] args)&#123; Girl instance = Girl.getInstance(); System.out.println(&quot;instance = &quot; + instance); &#125;&#125;class Girl&#123; private String name; private static Girl gf ; private Girl(String name)&#123; this.name=name; &#125; public static Girl getInstance()&#123; if(gf==null)&#123; gf=new Girl(&quot;xhh&quot;); &#125; return gf; &#125;&#125; statichttps://blog.csdn.net/qq_28761767/article/details/80994445 https://blog.csdn.net/LIAO_7053/article/details/81408139 final 静态代码块，代码块，构造方法执行顺序1、一个类先后执行顺序：静态代码块 → 普通代码块 → 子类构造方法 2、子父类当比较子父类执行顺序时：父类静态代码块 → 子类静态代码块 → 父类普通代码块 → 父类构造方法 → 子类普通代码块 → 子类构造方法 1、静态与非静态静态的是随着类的加载而执行，普通的则是实例化的时候执行：静态早于普通 2、变量与代码块的执行顺序谁先声明谁先执行：静态变量与静态代码块谁先声明谁先执行；普通变量与普通代码块谁先声明谁先执行； lang包https://blog.csdn.net/u012834750/article/details/79361552 String txt &#x3D; “&quot;The economic reality is, we have to manage the relationship. This type of realism has to guide our thinking on trade,&quot; Dade said at the forum on Canada-China trade relations that was co-organized by the Optical Valley Institute for Free Trade and the Jack Austin Centre for Asia Pacific Business Studies.”; String str[] &#x3D; txt.split(“&quot;| |\\.|\\,”); word[] words &#x3D; new word[51]; for (int i &#x3D; 0; i &lt;&#x3D; 50; i++) { words[i] &#x3D; new word(); } int j = 0; for (int k = 0; k &lt;= 55; k++) &#123; if (str[k].isEmpty()) &#123; &#125; else &#123; words[j].word = str[k]; j++; &#125; &#125; for (int i = 0; i &lt;= 50; i++) &#123; System.out.println(words[i].word + &quot;:&quot; + words[i].count); &#125; System.out.println(&quot; &quot;); System.out.println(&quot; &quot;); for (int i = 0; i &lt;= 50; i++) &#123; for (int n = i + 1; n &lt;= 50; n++) &#123; boolean b = words[i].word.equalsIgnoreCase(words[n].word); // System.out.println(b); if (b == true) &#123; // System.out.println(i); //System.out.println(n); //System.out.println(&quot;del&quot;); words[i].add(); words[n].word = &quot;del&quot;; &#125; &#125; &#125; for (int i = 0; i &lt;= 50; i++) &#123; if (!words[i].word.equals(&quot;del&quot;) ) &#123; System.out.println(words[i].word + &quot;:&quot; + words[i].count); &#125; &#125; JVM规范内存模型https://blog.csdn.net/qq_36704549/article/details/109390566 值传递&#x2F;引用传递（内存理解）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package javasuanfa;public class Main &#123; public static void main(String[] args) &#123; circle circle1 = new circle(1); circle circle2 = new circle(2); swap1(circle1, circle2); System.out.println(circle1.radius + &quot;\\n&quot; + circle2.radius); swap2(circle1, circle2); System.out.println(circle1.radius + &quot;\\n&quot; + circle2.radius); int[] a = &#123;1, 2&#125;; swap3(a[0], a[1]); System.out.println(&quot;a[0]=&quot; + a[0] + &quot;a[1]=&quot; + a[1]); int[] b = &#123;1, 2&#125;; swap4(b); System.out.println(&quot;b[0]=&quot; + b[0] + &quot;b[1]=&quot; + b[1]); T t1=new T(); T t2=new T(); System.out.println(&quot;t1.i=&quot;+t1.i); System.out.println(&quot;t2.i=&quot;+t2.i); int[] list= &#123;1,2,3,4,5&#125;; reverse(list); for(int i = 0;i&lt;list.length;i++ )&#123; System.out.println(list[i]+&quot; &quot;); &#125; swarp(list); for(int i = 0;i&lt;list.length;i++ )&#123; System.out.println(list[i]+&quot; &quot;); &#125; &#125; public static void reverse(int[] list)&#123; int[] newlist = new int [list.length]; for(int i = 0;i&lt;list.length;i++)&#123; newlist[i]=list[list.length-1-i]; &#125; list=newlist; &#125; public static void swarp(int[] a)&#123; int temp=a[0]; a[0]=a[1]; a[1]=temp; &#125; public static void swap1(circle x, circle y) &#123; circle temp = x; x = y; y = temp; &#125; public static void swap2(circle x, circle y) &#123; double temp = x.radius; x.radius = y.radius; y.radius = temp; &#125; public static void swap3(int n1, int n2) &#123; int temp = n1; n1 = n2; n2 = temp; &#125; public static void swap4(int[] a) &#123; int temp = a[0]; a[0] = a[1]; a[1] = temp; &#125; &#125;class circle &#123; double radius; circle(double i) &#123; radius = i; &#125; &#125;class T&#123; static int i=0; T()&#123; i++; &#125;&#125; out: 1234567891.02.02.01.0a[0]=1a[1]=2b[0]=2b[1]=1t1.i=2t2.i=2 https://blog.csdn.net/xiaojinlai123/article/details/88678367?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&amp;utm_relevant_index=2","categories":[{"name":"culitivate","slug":"culitivate","permalink":"http://example.com/categories/culitivate/"},{"name":"java技术栈","slug":"culitivate/java技术栈","permalink":"http://example.com/categories/culitivate/java%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"java","slug":"culitivate/java技术栈/java","permalink":"http://example.com/categories/culitivate/java%E6%8A%80%E6%9C%AF%E6%A0%88/java/"}],"tags":[]},{"title":"","slug":"课程笔记/复杂网络/复杂网络笔记","date":"2023-09-08T04:12:34.871Z","updated":"2023-09-20T08:42:18.828Z","comments":true,"path":"2023/09/8905fbaaf641.html","link":"","permalink":"http://example.com/2023/09/8905fbaaf641.html","excerpt":"","text":"python基础 - networkx 绘图总结_networkx画图_Rnan-prince的博客-CSDN博客","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"复杂网络","slug":"课程笔记/复杂网络","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E5%A4%8D%E6%9D%82%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"","slug":"工具记录/gephi","date":"2023-09-08T03:03:35.774Z","updated":"2023-09-20T08:42:18.828Z","comments":true,"path":"2023/09/95f55e481b72.html","link":"","permalink":"http://example.com/2023/09/95f55e481b72.html","excerpt":"","text":"Gephi 官方手册：一款关系可视化网络图工具的简明教程 - 简书 (jianshu.com)","categories":[{"name":"工具记录","slug":"工具记录","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7%E8%AE%B0%E5%BD%95/"}],"tags":[]},{"title":"","slug":"culitivate/java技术栈/mysql/mysqlnote","date":"2023-09-07T00:44:24.048Z","updated":"2023-09-20T08:42:18.846Z","comments":true,"path":"2023/09/d5b4b5bd3a9b.html","link":"","permalink":"http://example.com/2023/09/d5b4b5bd3a9b.html","excerpt":"","text":"basis:MySQL 插入数据 | 菜鸟教程 (runoob.com)limit 1,1 ：第二行数据between:包括开始结束值空值检查：where sth is nullnull与不匹配：当返回行中查询列包含null,数据库不知道是否匹配，需要加上 is null额外列出通配符（like % _）：%任意字符任意长度；_匹配单字符;ps.通配符搜索慢，少用且不放开头；正则表达式：ltrim()：删除左侧trim():两侧Rtrim()：删除数据右侧多余空格concat：拼接字段 如果删除所以行，使用TRUNCATE TABLE更加快速实质：删除原来的表并且创建一个新表 p120索引以下是关于如何创建和使用普通索引和唯一索引的示例代码： 1. 创建和使用普通索引： 假设有一个名为 products 的表，你想在该表的 product_name 列上创建普通索引，然后执行一个基于该列的查询。以下是示例代码： 123456-- 创建一个普通索引在 &#x27;product_name&#x27; 列上CREATE INDEX idx_product_nameON products (product_name);-- 执行基于普通索引的查询SELECT * FROM products WHERE product_name = &#x27;手机&#x27;; 上述示例首先创建了一个名为 idx_product_name 的普通索引，该索引应用于 products 表的 product_name 列。然后，通过 SELECT 查询来查找产品名称为 “手机” 的产品记录。普通索引可以加速这个查询，因为它可以更快地定位匹配条件的记录。 2. 创建和使用唯一索引： 假设有一个名为 users 的表，你想在该表的 email 列上创建唯一索引，以确保每个用户的电子邮件地址是唯一的。以下是示例代码： 123456-- 创建一个唯一索引在 &#x27;email&#x27; 列上CREATE UNIQUE INDEX idx_emailON users (email);-- 尝试插入重复的电子邮件地址，将引发唯一性约束错误INSERT INTO users (username, email) VALUES (&#x27;user1&#x27;, &#x27;user1@example.com&#x27;); 上述示例首先创建了一个名为 idx_email 的唯一索引，该索引应用于 users 表的 email 列。然后，通过 INSERT 语句尝试插入一个带有重复电子邮件地址的用户记录，这将引发唯一性约束错误，因为唯一索引确保了 email 列中的值是唯一的。 唯一索引通常用于确保某一列或一组列中的值是唯一的，例如，用户的用户名或身份证号码等。这可以帮助维护数据的完整性，并防止重复值的出现。 2. 创建和使用全文索引： 创建表时，fulltext() 12CREATE FULLTEXT INDEX idx_searchON articles (title, content); 123SELECT * FROM articlesWHERE MATCH (title, content) AGAINST (&#x27;关键词&#x27;); 存储过程创建create procedure vvname( IN pid int, OUT pname char(50))begin select name from user where id &#x3D; pid into pname ;end;MySQL支持IN（传递给存储过程）、OUT（从存储过程传出）和INOUT（对存储过程传入和传出）类型的参数使用call vvname(1,@name);select @name;","categories":[{"name":"culitivate","slug":"culitivate","permalink":"http://example.com/categories/culitivate/"},{"name":"java技术栈","slug":"culitivate/java技术栈","permalink":"http://example.com/categories/culitivate/java%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"mysql","slug":"culitivate/java技术栈/mysql","permalink":"http://example.com/categories/culitivate/java%E6%8A%80%E6%9C%AF%E6%A0%88/mysql/"}],"tags":[]},{"title":"","slug":"culitivate/java技术栈/java/JAVA笔记","date":"2023-09-06T03:06:08.976Z","updated":"2023-09-20T08:42:18.829Z","comments":true,"path":"2023/09/e099a43e4353.html","link":"","permalink":"http://example.com/2023/09/e099a43e4353.html","excerpt":"","text":"数据类型枚举类型1public enum Size&#123;SMALL,MEDIUM,LAGE,EXRA_LAGE&#125; 枚举类的声明定义的类型是一个类，有四个实例，不可能构造新的对象，所有比较两个枚举类型的值时可以用=&#x3D; 枚举的构造器总是私有的，可以省略 valueOf(class,String)1Size s=Enum.szie.valueOf(Size.calss,&quot;SMALL&quot;) toString()1Size.SMALL.toString() :&quot;SMALL&quot; ordinal()返回枚举常量的位置，从0 compareTo(E other)如果枚举常量出现在other之前，返回负整数this=&#x3D;other，返回0否则返回正整数 values()1Size[] values=Size.values(); 返回包含Size.SMALL等的数组 位运算符【Java基础】符号位、原码、补码、反码、位逻辑运算符、位移运算符、复合位赋值运算符_java符号位_墩墩分墩的博客-CSDN博客 数组(引用数据类型) 一维数组初始化 123int a[]=new int[]&#123;4,5,9&#125;;int a[]=&#123;5，5，5&#125;；int a[]=new int[12]; 二维数组初始化 123int a[][]=new int[3][4];int a[][]=&#123;&#123;3,4&#125;,&#123;5,6&#125;&#125;;int a[][]=new int[][]&#123;&#123;1,2&#125;,&#123;3,4&#125;&#125;; 遍历数组 1234567891011121314151617181920基础方法for(int k = 0;k&lt;a.length;k++) for(int c = 0;c&lt;a[k].length;c++&#123; System.out.println(b[k][c]); &#125; foreach语句int arr2[][]=&#123;&#123;1,2&#125;,&#123;3,4&#125;&#125;;int i = 0;for(int x[]:arr2)&#123; i++; int j = 0; for(int e:x)&#123; j++; if(i==arr2.length&amp;&amp;j=x.length)&#123; System.out.println(e); &#125;else System.out.println(e+&quot;,&quot;); &#125;&#125; foreach语句 1234567891011121314151617for(元素变量x:遍历对象obj)&#123; 引用了x的java语句；&#125;一维数组int arr[]=&#123;1,2,3&#125;;for(int x:arr)&#123; System.out.println(x);&#125;二维数组int arr2[][]=&#123;&#123;1,2&#125;,&#123;3,4&#125;&#125;;for(int x[]:arr2)&#123; for(int e:x)&#123; System.out.println(e); &#125;&#125; Ayyays类填充替换数组元素fill123456import java.util.Arrays; //导入java.util.Arrays类int arr[]=new int[5];Arrays.fill(arr,8);//&#123;8,8,8,8,8&#125;int arr2[]=new int[]&#123;1,2,3,4&#125;Arrays.fill(arr2,1,2,8)//&#123;1,8,3,4&#125;//(数组,fromIndex(包括),toIndex(不包括)，替换数) 数组排序(升序)大写字母在小写字母前面sort12345678910import java.util.Arrays;public class paixu&#123; public static void main(String []args)&#123; int arr[]=new int[]&#123;3,2,1&#125;; Arrays.sort(arr); for(int x:arr)&#123; System.out.println(x);//1，2，3 &#125; &#125;&#125; 复制数组(新数组长度大于旧数组:整型用0，char型用null)copyOf,copyOfRange1234567891011121314import java.util.Arrays;public class copy&#123; public static void main(String []args)&#123; int arr[]=new int[]&#123;3,2,1&#125;; int arr2[]=Arrays.copyOf(arr,5);//5为新数组长度 int arr3[]=Arrays.copyOfRange(arr,0,2); for(int x:arr2)&#123; System.out.println(x);//3,2,1,0,0 &#125; for(int y:arr3)&#123; System.out.println(y);//3,2 &#125; &#125;&#125; 数组查询binarySearch1234567891011121314import java.util.Arrays;public class Search&#123; public static void main(String []args)&#123; int arr[]=new int[]&#123;5,3,1&#125;; Arrays.sort(arr); int index=Arrays.binarySearch(arr,3);//2 int index2=Arrays.binarySearch(arr,4);//-3 int index3=Arrays.binarySearch(arr,0,1,2);//-2 System.out.println(index); System.out.println(index2); System.out.println(index3); &#125;&#125; toString一维数组：toString多维数组：Arrays.deepToString String码点与代码单元一、String类String类在java.lang包中，java使用String类创建一个字符串变量，字符串变量属于对象。java把String类声明的final类，不能有类。String类对象创建后不能修改，由0或多个字符组成，包含在一对双引号之间。 二、String类对象的创建字符串声明：String stringName;字符串创建：stringName &#x3D; new String(字符串常量);或stringName &#x3D; 字符串常量; 三、String类构造方法1、public String()无参构造方法，用来创建空字符串的String对象。 1 String str1 &#x3D; new String(); 2、public String(String value)用已知的字符串value创建一个String对象。 1 String str2 &#x3D; new String(“asdf”); 2 String str3 &#x3D; new String(str2); 3、public String(char[] value)用字符数组value创建一个String对象。 121 char[] value = &#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;&#125;;2 String str4 = new String(value);//相当于String str4 = new String(&quot;abcd&quot;); 4、public String(char chars[], int startIndex, int numChars)用字符数组chars的startIndex开始的numChars个字符创建一个String对象。 121 char[] value = &#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;&#125;;2 String str5 = new String(value, 1, 2);//相当于String str5 = new String(&quot;bc&quot;); 5、public String(byte[] values)用比特数组values创建一个String对象。 121 byte[] strb = new byte[]&#123;65,66&#125;;2 String str6 = new String(strb);//相当于String str6 = new String(&quot;AB&quot;); 四、String类常用方法1、求字符串长度public int length()&#x2F;&#x2F;返回该字符串的长度 121 String str = new String(&quot;asdfzxc&quot;);2 int strlength = str.length();//strlength = 7 2、求字符串某一位置字符public char charAt(int index)&#x2F;&#x2F;返回字符串中指定位置的字符；注意字符串中第一个字符索引是0，最后一个是length()-1。 121 String str = new String(&quot;asdfzxc&quot;);2 char ch = str.charAt(4);//ch = z 3、提取子串用String类的substring方法可以提取字符串中的子串，该方法有两种常用参数:1)public String substring(int beginIndex)&#x2F;&#x2F;该方法从beginIndex位置起，从当前字符串中取出剩余的字符作为一个新的字符串返回。2)public String substring(int beginIndex, int endIndex)&#x2F;&#x2F;该方法从beginIndex位置起，从当前字符串中取出到endIndex-1位置的字符作为一个新的字符串返回。 1231 String str1 = new String(&quot;asdfzxc&quot;);2 String str2 = str1.substring(2);//str2 = &quot;dfzxc&quot;3 String str3 = str1.substring(2,5);//str3 = &quot;dfz&quot; 4、字符串比较1)public int compareTo(String anotherString)&#x2F;&#x2F;该方法是对字符串内容按字典顺序进行大小比较，通过返回的整数值指明当前字符串与参数字符串的大小关系。若当前对象比参数大则返回正整数，反之返回负整数，相等返回0。2)public int compareToIgnore(String anotherString)&#x2F;&#x2F;与compareTo方法相似，但忽略大小写。3)public boolean equals(Object anotherObject)&#x2F;&#x2F;比较当前字符串和参数字符串，在两个字符串相等的时候返回true，否则返回false。4)public boolean equalsIgnoreCase(String anotherString)&#x2F;&#x2F;与equals方法相似，但忽略大小写。 1234561 String str1 = new String(&quot;abc&quot;);2 String str2 = new String(&quot;ABC&quot;);3 int a = str1.compareTo(str2);//a&gt;04 int b = str1.compareToIgnoreCase(str2);//b=05 boolean c = str1.equals(str2);//c=false6 boolean d = str1.equalsIgnoreCase(str2);//d=true 5、字符串连接public String concat(String str)&#x2F;&#x2F;将参数中的字符串str连接到当前字符串的后面，效果等价于”+”。 121 String str = &quot;aa&quot;.concat(&quot;bb&quot;).concat(&quot;cc&quot;);2 相当于String str = &quot;aa&quot;+&quot;bb&quot;+&quot;cc&quot;; 6、字符串中单个字符查找1)public int indexOf(int ch&#x2F;String str)&#x2F;&#x2F;用于查找当前字符串中字符或子串，返回字符或子串在当前字符串中从左边起首次出现的位置，若没有出现则返回-1。2)public int indexOf(int ch&#x2F;String str, int fromIndex)&#x2F;&#x2F;改方法与第一种类似，区别在于该方法从fromIndex位置向后查找。3)public int lastIndexOf(int ch&#x2F;String str)&#x2F;&#x2F;该方法与第一种类似，区别在于该方法从字符串的末尾位置向前查找。4)public int lastIndexOf(int ch&#x2F;String str, int fromIndex)&#x2F;&#x2F;该方法与第二种方法类似，区别于该方法从fromIndex位置向前查找。 1234561 String str = &quot;I am a good student&quot;;2 int a = str.indexOf(&#x27;a&#x27;);//a = 23 int b = str.indexOf(&quot;good&quot;);//b = 74 int c = str.indexOf(&quot;w&quot;,2);//c = -15 int d = str.lastIndexOf(&quot;a&quot;);//d = 56 int e = str.lastIndexOf(&quot;a&quot;,3);//e = 2 7、字符串中字符的大小写转换1)public String toLowerCase()&#x2F;&#x2F;返回将当前字符串中所有字符转换成小写后的新串2)public String toUpperCase()&#x2F;&#x2F;返回将当前字符串中所有字符转换成大写后的新串 1231 String str = new String(&quot;asDF&quot;);2 String str1 = str.toLowerCase();//str1 = &quot;asdf&quot;3 String str2 = str.toUpperCase();//str2 = &quot;ASDF&quot; 8、字符串中字符的替换1)public String replace(char oldChar, char newChar)&#x2F;&#x2F;用字符newChar替换当前字符串中所有的oldChar字符，并返回一个新的字符串。2)public String replaceFirst(String regex, String replacement)&#x2F;&#x2F;该方法用字符replacement的内容替换当前字符串中遇到的第一个和字符串regex相匹配的子串，应将新的字符串返回。3)public String replaceAll(String regex, String replacement)&#x2F;&#x2F;该方法用字符replacement的内容替换当前字符串中遇到的所有和字符串regex相匹配的子串，应将新的字符串返回。 123451 String str = &quot;asdzxcasd&quot;;2 String str1 = str.replace(&#x27;a&#x27;,&#x27;g&#x27;);//str1 = &quot;gsdzxcgsd&quot;3 String str2 = str.replace(&quot;asd&quot;,&quot;fgh&quot;);//str2 = &quot;fghzxcfgh&quot;4 String str3 = str.replaceFirst(&quot;asd&quot;,&quot;fgh&quot;);//str3 = &quot;fghzxcasd&quot;5 String str4 = str.replaceAll(&quot;asd&quot;,&quot;fgh&quot;);//str4 = &quot;fghzxcfgh&quot; 9、其他类方法1)String trim()&#x2F;&#x2F;截去字符串两端的空格，但对于中间的空格不处理。 12341 String str = &quot; a sd &quot;;2 String str1 = str.trim();3 int a = str.length();//a = 64 int b = str1.length();//b = 4 2)boolean startsWith(String prefix)或boolean endWith(String suffix)&#x2F;&#x2F;用来比较当前字符串的起始字符或子字符串prefix和终止字符或子字符串suffix是否和当前字符串相同，重载方法中同时还可以指定比较的开始位置offset。 1231 String str = &quot;asdfgh&quot;;2 boolean a = str.startsWith(&quot;as&quot;);//a = true3 boolean b = str.endWith(&quot;gh&quot;);//b = true 3)regionMatches(boolean b, int firstStart, String other, int otherStart, int length)&#x2F;&#x2F;从当前字符串的firstStart位置开始比较，取长度为length的一个子字符串，other字符串从otherStart位置开始，指定另外一个长度为length的字符串，两字符串比较，当b为true时字符串不区分大小写。4)contains(String str)&#x2F;&#x2F;判断参数s是否被包含在字符串中，并返回一个布尔类型的值。 1231 String str = &quot;student&quot;;2 str.contains(&quot;stu&quot;);//true3 str.contains(&quot;ok&quot;);//false 5)String[] split(String str)&#x2F;&#x2F;将str作为分隔符进行字符串分解，分解后的字字符串在字符串数组中返回。 121 String str = &quot;asd!qwe|zxc#&quot;;2 String[] str1 = str.split(&quot;!|#&quot;);//str1[0] = &quot;asd&quot;;str1[1] = &quot;qwe&quot;;str1[2] = &quot;zxc&quot;; 五、字符串与基本类型的转换1、字符串转换为基本类型java.lang包中有Byte、Short、Integer、Float、Double类的调用方法：1)public static byte parseByte(String s)2)public static short parseShort(String s)3)public static short parseInt(String s)4)public static long parseLong(String s)5)public static float parseFloat(String s)6)public static double parseDouble(String s)例如： 1231 int n = Integer.parseInt(&quot;12&quot;);2 float f = Float.parseFloat(&quot;12.34&quot;);3 double d = Double.parseDouble(&quot;1.124&quot;); 2、基本类型转换为字符串类型String类中提供了String valueOf()放法，用作基本类型转换为字符串类型。1)static String valueOf(char data[])2)static String valueOf(char data[], int offset, int count)3)static String valueOf(boolean b)4)static String valueOf(char c)5)static String valueOf(int i)6)static String valueOf(long l)7)static String valueOf(float f)8)static String valueOf(double d)例如： 121 String s1 = String.valueOf(12);2 String s1 = String.valueOf(12.34); 3、进制转换使用Long类中的方法得到整数之间的各种进制转换的方法：Long.toBinaryString(long l)Long.toOctalString(long l)Long.toHexString(long l)Long.toString(long l, int p)&#x2F;&#x2F;p作为任意进制 StringBuffer StringBuffer和StringBuilder类的对象能被多次修改且不产生新的对象 StringBuffer 方法以下是 StringBuffer 类支持的主要方法： 序号 方法描述 1 public StringBuffer append(String s) 将指定的字符串追加到此字符序列。 2 public StringBuffer reverse() 将此字符序列用其反转形式取代。 3 public delete(int start, int end) 移除此序列的子字符串中的字符。 4 public insert(int offset, int i) 将 int 参数的字符串表示形式插入此序列中。 5 insert(int offset, String str) 将 str 参数的字符串插入此序列中。 6 replace(int start, int end, String str) 使用给定 String 中的字符替换此序列的子字符串中的字符。 以下列表列出了 StringBuffer 类的其他常用方法： 序号 方法描述 1 int capacity() 返回当前容量。 2 char charAt(int index) 返回此序列中指定索引处的 char 值。 3 void ensureCapacity(int minimumCapacity) 确保容量至少等于指定的最小值。 4 void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) 将字符从此序列复制到目标字符数组 dst。 5 int indexOf(String str) 返回第一次出现的指定子字符串在该字符串中的索引。 6 int indexOf(String str, int fromIndex) 从指定的索引处开始，返回第一次出现的指定子字符串在该字符串中的索引。 7 int lastIndexOf(String str) 返回最右边出现的指定子字符串在此字符串中的索引。 8 int lastIndexOf(String str, int fromIndex) 返回 String 对象中子字符串最后出现的位置。 9 int length() 返回长度（字符数）。 10 void setCharAt(int index, char ch) 将给定索引处的字符设置为 ch。 11 void setLength(int newLength) 设置字符序列的长度。 12 CharSequence subSequence(int start, int end) 返回一个新的字符序列，该字符序列是此序列的子序列。 13 String substring(int start) 返回一个新的 String，它包含此字符序列当前所包含的字符子序列。 14 String substring(int start, int end) 返回一个新的 String，它包含此序列当前所包含的字符子序列。 15 String toString() 返回此序列中数据的字符串表示形式。 包装类https://blog.csdn.net/geekmubai/article/details/82024483 Integer.valueof()和Integer.parseInt()的区别https://blog.csdn.net/jdsjlzx/article/details/106352216 数字处理类https://blog.csdn.net/qq_42182367/article/details/82018861 类和对象 对象：属性（静态部分）行为（动态部分） 类实际就是封装对象属性和行为的载体，对象是类抽象出的一个实例 类中对象的属性以成员变量的形式定义；行为以方法的形式定义 封装性 保证类内部数据结构的完整性 继承性多态性 由抽象方法组成的集合就是接口 类成员变量 成员方法外定义的变量 成员方法 权限修饰符 返回值类型 方法名（参数类型 参数名）{ ​ …&#x2F;&#x2F;方法体 return 返回值； } 权限修饰符 访问包位置 private protected public 本类 可见 可见 可见 同包其他类或子类 不可见 可见 可见 其他包的类或子类 不可见 不可见 可见 类的权限会约束成员的权限 https://blog.csdn.net/weixin_34856035/article/details/114793364 局部变量 局部变量是在方法被执行时被创建，在方法执行结束时被销毁。使用时必须赋值或初始化。 this关键字 成员变量与形参相同时，this.变量名指代成员变量 this引用的是本类的一个对象，所以可以作为类的返回值 类的构造方法1234567public class awd&#123; awd(int a)&#123; &#125;&#125;awd a1=new awd(4); this可调用有参构造方法 静态变量、常量和方法 静态方法中不能使用this关键字 静态方法中不可以直接调用非静态方法 类的主方法123public static void main(String[] args)&#123; &#125; 对象static成员变量 使用new操作符创建对象的同时，将自动调用该类的构造方法 成员变量被声明为static时，本类对象共用此内存 12345678910111213public class main &#123; public static int num=1; public int add()&#123; return ++num; &#125; public static strictfp void main(String[] args) &#123; main m1=new main(); main m2=new main(); System.out.println(m1.add()); //2 System.out.println(m2.add()); //3 &#125; &#125; 对象的比较 ”=&#x3D;“比较对象引用的地址是否相同 (a.equals(b))比较a，b对象引用所指的内容是否相等 对象的销毁 对象超过作用范围或对象被置null值 继承、多态、抽象类、接口继承123class Text2 extends Text&#123; &#125; 细节 子类继承了所有的属性和方法，非私有的属性和方法可以在子类直接访问，但是私有属性和方法不能在子类直接访问，要通过父类提供公共（非私有即可）的方法去访问 子类必须调用父类的构造器，完成父类初始化(默认调用super()) 当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中使用super指定使用父类的哪个构造器 要指定父类构造器，使用super(参数) super()使用时必须放在子类构造器的第一条（super()只能在构造器中使用，super.***不是） super()和this()都只能放在第一条，因此在构造器中不能共存。 java所有类都是Object类的子类，Object时是所有类的基类 父类构造器的调用不限于直接父类，将一直往上追溯直到Object类（顶级父类） 重写时不能降低方法的修饰权限范围 内存布局 重名时的查找规则：首先看子类是否有该属性，有且可以访问则返回信息，如果子类没有则看父类，以此向上类推 super关键字 可以访问父类的属性方法，但不能访问私有 调用父类构造器的好处:分工明确 当子类中有和父类重名的成员时，味蕾访问父类成员必须通过super。如果没有重名，使用super、this、直接访问效果是一样的 super查找规则和继承一样 重载以及重写&#x2F;覆盖 方法重载的主要特点有以下几点： 第一个特点是方法名是相同的; 第二个特点是方法的个数、顺序、参数类型至少有一项是不相同的; 第三个特点是方法的返回类型不一定要是相同的; 第四个特点是方法的修饰符也可以是不相同的 第五：发生在本类中，如构造方法的重载 方法覆盖&#x2F;重写的特点主要有以下几点： 第一个特点是方法覆盖只存在于子类和父类之间，在同一个类中的方法不能被覆盖; 第二个特点是父类方法抛出的异常可以比子类方法更多; 第三个特点是父类方法的名称、参数签名和返回类型与子类方法的是一致的; 第四个特点是子类是不允许将父类的静态方法覆盖为非静态方法，父类的非静态方法也不能被子类覆盖为静态方法; 第五个特点是子类方法不能缩小父类方法的访问权限; 第六个特点是子类不能覆盖父类的私有方法; 第七个特点是子类可以通过两种途径覆盖父类的抽象方法：一种是子类实现父类的抽象方法，另一种是子类重新声明父类的抽象方法; 第八个特点是父类的.非抽象方法可以被覆盖为抽象方法。 多态 介绍：方法或对象具有多种形态 方法的多态 重写和重载体现多态 对象的多态（核心） 一个对象的编译类型和运行类型可以不一样eg.Animal animal &#x3D; new Dog();&#x2F;&#x2F;子类，Animal是编译类型，Dog是运行类型 编译类型在定义对象时，就确定了，不能改变 运行类型可以改变 animal &#x3D; new Cat(); 多态机制合理运用编译类型为父类可以简化代码 向上转型 本质：父类的引用指向了子类的对象 语法： 父类类型 引用名 &#x3D; new 子类类型(); 特点：编译类型在左，运行类型在右,可以调用父类所有成员，但不能调用子类特有成员，因为编译阶段有编译类型决定 向下转型 语法：子类类型 引用名 &#x3D; （子类类型）父类引用 只能强转父类引用，不能强转父类的对象(Animal animal&#x3D;new Dog()) 要求父类的引用必须指向的是当前目标类型的对象Dog dog &#x3D; (Dog) animal; 当向下转型后，可以调用子类类型中所有的成员12345678910111213141516171819202122232425262728B、B2 extends AA a=new A(); B b=(B)a; if(a instanceof B) System.out.println(&quot;转换成功&quot;);out:Exception in thread &quot;main&quot; java.lang.ClassCastException: A cannot be cast to B at main.main(main.java:18)A a=new B(); B b=(B)a; if(a instanceof B) System.out.println(&quot;转换成功&quot;); out:转换成功A a=new B2(); B b=(B)a; if(a instanceof B) System.out.println(&quot;转换成功&quot;); out:Exception in thread &quot;main&quot; java.lang.ClassCastException: B2 cannot be cast to B at main.main(main.java:18) 多态绑定机制 当调用对象方法时，方法会和对象的内存地址&#x2F;运行类型绑定（声明类型决定） 当调用对象属性时，无动态绑定机制，哪里声明，哪里使用（编译类型决定） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package extend;public class test &#123; public static void main(String[] args)&#123; A a=new B(); System.out.println(a.i);//10 System.out.println(a.getI());//bg 21 System.out.println(a.sum());//as bg 32 &#125;&#125;class A &#123; int i=10; public int getI()&#123; System.out.println(&quot;ag&quot;); return i; &#125; public int sum()&#123; System.out.println(&quot;as&quot;); return getI()+11; &#125; public int sum1()&#123; System.out.println(&quot;as1&quot;); return i+10; &#125;&#125;class B extends A&#123; int i=21; public int getI()&#123; System.out.println(&quot;bg&quot;); return i; &#125;// public int sum()&#123;// return getI()+20;// &#125; public int sum1()&#123; System.out.println(&quot;bs1&quot;); return i+20; &#125;&#125; 多态数组 利用多态以及动态绑定 实现子类特有方法：向下转型 抽象类只能单继承 一、介绍Abstract，即抽象。笼统的描述一类东西。 打个比方：我们说车子都可以跑(run)。但有几个轮子，怎么跑，对于不同的车有不同的结果。自行车2个轮子需要人踩着跑，三轮车有3个轮子可以人踩、也能电动，汽车发动机推动跑等等，那么“车”的表达为抽象的。 特点： abstract可以修饰类，也可以修饰方法； abstract修饰的类可以被继承和实现，但是这个类本身不能被实例化； 抽象方法必须在抽象类中，抽象类中可以有非抽象的方法； 抽象类中可以没有抽象方法，这样做的作用是这个类不可以被实例化； 抽象类的子类在继承抽象类后，&#x3D;&#x3D;必须把父类中的抽象方法重写，否则子类也会自动变为抽象类；&#x3D;&#x3D; 可以重写普通方法 可以有正常字段以及构造类 抽象类可以有静态方法，可直接class.method调用 抽象方法用于被子类继承后重写。即是父类的抽象方法是空的，必须由子类继承之后在子类中由子类实现，这可以达到不同子类可以根据自己的特性来定义自己从父类继承过来的抽象方法； abstract不能与final关键字共存，因为final关键字修饰的类是不能被继承的； abstract不能与private关键字共存，因为私有的东西不能继承； abstract不能与static关键字共存，当static修饰方法时，该方法可以通过类名直接调用，而abstract修饰的抽象方法是不能被调用的； abstract修饰的类中的普通方法可以通过该抽象类的子类直接调用。 应用： 123456抽象超类Person 具体子类Employee、Studentvar people = new Person[2]people[0]=new Employee(...)people[1]=new Student(...)for (Person p:people) System.out.println(p.getName()+&quot;,&quot;+p.getDescription()) 创建对象步骤1、声明对象变量，为变量分配引用空间。2、为对象分配空间，执行student的构造方法完成实例化，并返回对象的引用，即new()方法。创建数组步骤1、声明数组变量，分配引用空间。2、为变量分配数据空间。可以发现创建对象和数组的过程是类似的，但是对象数组是存储对象的地址，不涉及实例化，只是规定了数组类型，所以可以实例化抽象类的子类。 首先我们要了解对象的创建（即为对象分配变量并获得一个引用），系统遇到new+构造方法以后，就会给该对象的变量分配内存并进行初始化，然后再计算出一个引用赋给该对象。 而数组的创建和对象的创建基本上是一样的，只不过数组中存放的是这些元素的首地址，而在这个过程中并没有经过上边的对象创建的步骤，只是给数组的元素指定了数据类型，规定它只能存放该类型的数据或引用。 二、优缺点抽象类有什么好处呢？1、由于抽象类不能被实例化，最大的好处就是通过方法的覆盖来实现多态的属性。也就是运行期绑定2、抽象类将事物的共性的东西提取出来，由子类继承去实现，代码易扩展、易维护。 三、不能和下列关键字共存abstract是抽象类的关键字，也是抽象方法声明上必须加的修饰符，在定义方法上它一般不能与以下几个关键字共存： 1、和static:abstract class A {undefinedpublic abtract static void method();}static修饰后可以直接类名调用方法，但是抽象方法没有实现体，调用无意义； 2、和final:final修饰的类不能被继承，修饰的方法不能被重写，修饰的成员变量只能为常量；但是继承的子类要重写这个抽象方法，所以会出现矛盾； 3、和private:抽象方法是为了让子类重写并给定实现体，但是private修饰的方法只能本类访问，所以矛盾。 接口可以实现多接口 12345678public interface b1&#123; (public static final)int a; （public abstract） void draw();&#125;public a extends b implements b1&#123; &#125; 接口中方法必须被定义为public abstract 接口中定义的如何字段都是public static final的 常量字段public static final 接口的方法 抽象方法 静态方法 默认方法 抽象方法： 接口中的所有方法声明都是隐式抽象和公开的，除非它们声明为static或default。 接口中的抽象方法没有实现。 实现接口的类必须重写以实现接口中声明的所有抽象方法。否则，类必须声明为abstract。 静态方法： 静态方法包含静态修饰符，并且是隐式公开的。 以使用点表示法使用接口的静态方法。1&lt;interface-name&gt;.&lt;static-method&gt; 与类中的静态方法不同，接口中的静态方法不会通过实现类或子接口来继承。 接口中的静态方法不会被实现类继承。 默认方法： 可以将默认方法添加到现有接口，并为该方法提供默认实现。 所有实现该接口的类都将继承默认实现，因此不会破坏它们。类可以选择重写默认实现 默认方法使用关键字 default 声明。默认方法不能声明为abstract或static。它必须提供一个实现。否则，将发生编译时错误。 默认方法冲突，超类优先，如果是接口与接口冲突则必须重写 注意点 接口中的方法声明包括方法的约束。例如，方法声明中的throws子句是​​方法的约束。 1234567891011import java.io.IOException;interface Shape &#123; void draw(double amount) throws IOException;&#125;class Main implements Shape&#123; @Override public void draw(double amount) &#123; // TODO Auto-generated method stub &#125; &#125; Main的代码是有效的，即使它丢弃了throws子句。当类覆盖接口方法时，允许删除约束异常。如果我们使用Shape类型，我们必须处理IOException。 12345678910111213141516171819202122import java.io.IOException;interface Shape &#123; void draw(double amount) throws IOException;&#125;class Main implements Shape&#123; @Override public void draw(double amount) &#123; // TODO Auto-generated method stub &#125; public void anotherMethod()&#123; Shape s = new Main(); try &#123; s.draw(0); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; draw(0); &#125;&#125; 如果一个类不提供接口的完全实现，它必须声明为abstract。 深克隆1234567891011121314151617调用：... public static void main(String[] args) throws CloneNotSupportedException &#123; A aa=new A(); aa.setI(2); A bb=aa.clone(); bb.setI(4); System.out.println(aa.getI()); //2 System.out.println(bb.getI()); //4 &#125;...类实现Cloneable:calss A implements Cloneable&#123; public A conle() throws CloneNotSupportedException&#123; return (A)super.clone(); &#125;&#125; Cloneable是一个标记接口，不包含任何方法，唯一作用是允许在类型查询中使用instanceof,没有实现这个接口，会抛出检查型异常super.clone()继承的是Object中的clone()方法如果被克隆对象除了基本类型有引用类型，则对该字段也应该实现clone 12345public A clone() throws CloneNotSupportedException&#123; A cloned = (A) supe.clone(); cloned.stu=(Student) stu.clone(); return cloned;&#125; 类的高级特性 package 包名 import static 静态成员&#x2F;&#x2F;后可直接使用该成员方法 final常量需用大写字母并且加下划线进行连接 VALUE_1 定义为final的数据无论是常量，对象引用还是数组在主函数中都不能被改变 static final可以做到引用对象也不改变 123456789public class finaldatatest&#123; final int A_1=6; final int B_1; public finaldatatest()&#123; B_1=5; &#125;&#125; final方法不能被子类覆盖 final类不能被继承，类中的方法被隐式定义为final,但类中的成员变量可以被定义为final或非final 内部类“Main.this” cannot be reference from a static context_main.this’ cannot be referenced from a static cont_PostgreSQL运维技术的博客-CSDN博客 内部类可以访问外部类成员，外部不可直接访问内部 主方法中实例化内部类对象 外部类中可直接实例化内部对象引用 12345public static void main(String[] args)&#123; Outercalss out = new Outerclass(); Outerclass.innerclass in = out.new innercalss(); Outerclass.innercalss in = out.doit();//doit是返回类型为innerclass的外部类的非静态方法return new innerclass&#125; 局部内部类：在类的方法或任意作用域中定义内部类，该内部类可以访问外部类成员 匿名内部类: 123return new 类或接口名()&#123; //内部类体&#125; 静态内部类P207 内部类的继承P208 ScannerJava中在Scanner类里有两种方法可以使用户通过键盘输入字符串 I.next()方法 使用方法是如下： 使用Scanner类创建一个对象，System.in待变系统输入，Scanner代表扫描仪的意思，大概就是通过扫描仪扫描系统输入，然后我们定义一个String字符串类型变量用于存储我们要输入的字符串，next（）方法就是输入字符串。 II.nextLine()方法 使用方法如下： 操作方法也是如上。 那么，这两个方法有什么区别呢？乍一看，nextLine（）方法比next（）方法长一个Line单词，是不是更牛一点呢我们来分析一下长一点的字符串 next（） nextLine（） 通过对比，果然满是伤痕。 next（）方法只输出了字符串中的第一个字母I，因为接下来的空格它识别不了。 而nextLine（）方法输出了整个字符串，因为该方法可以识别字符串中的空格以及回车，是不是很强大。 那么，怎么通过键盘完成一个字符的输入，当然在next（）方法和nextLine（）方法下还有一个方法叫做charAt（args【0】），顾名思义，我们可以看出charAt是字符在什么。。。看一下代码展示吧： next().charAt() 因为charAt(0)这个方法中的参数表示取出字符串中的第几个字符，因为是字符，所以之打印该方法下指定的参数所对应的字符 比如换一个参数： 注意：charAt()这个方法中的参数是args[]一个数组，所以0为下标指向第一个数。 那么我么来看next（）的一个弊端： 可以看出当字符是空格时，next（）方法下的charAt（）无法执行，当然nextLine（）这个方法就可以了，之前字符串的输入也说过，nextLine（）这个方法可以识别空格和回车。 ———————————————— I&#x2F;O【Java】文件的操作与输入输出流_Lotto_o的博客-CSDN博客 Flie类文件的创建与删除1File file = new File(&quot;E:/word.txt&quot;); 1File file = new File(&quot;E:/&quot;,&quot;word.txt&quot;); 1File f = new File(file,&quot;ww.txt&quot;);//未解决 123456try &#123; file.createNewFile(); System.out.println(&quot;created&quot;);&#125; catch (IOException e) &#123; throw new RuntimeException(e);&#125; 常用方法ejsiej 瑟夫 创建：createNewFile()在指定位置创建⼀个空⽂件，成功就返回true，如果已存在就不创建，然后返回false。mkdir() 在指定位置创建⼀个单级⽂件夹。mkdirs() 在指定位置创建⼀个多级⽂件夹。renameTo(File dest)如果⽬标⽂件与源⽂件是在同⼀个路径下，那么renameTo的作⽤是重命名， 如果⽬标⽂件与源⽂件不是在同⼀个路径下，那么renameTo的作⽤就是剪切，⽽且还不能操作⽂件夹。 删除：delete() 删除⽂件或者⼀个空⽂件夹，不能删除⾮空⽂件夹，马上删除⽂件，返回⼀个布尔值。deleteOnExit()jvm退出时删除⽂件或者⽂件夹，⽤于删除临时⽂件，⽆返回值。 判断：exists() ⽂件或⽂件夹是否存在。isFile() 是否是⼀个⽂件，如果不存在，则始终为false。isDirectory() 是否是⼀个⽬录，如果不存在，则始终为false。isHidden() 是否是⼀个隐藏的⽂件或是否是隐藏的⽬录。isAbsolute() 测试此抽象路径名是否为绝对路径名。 获取：getName() 获取⽂件或⽂件夹的名称，不包含上级路径。getAbsolutePath()获取⽂件的绝对路径，与⽂件是否存在没关系length() 获取⽂件的⼤⼩（字节数），如果⽂件不存在则返回0L，如果是⽂件夹也返回0L。getParent() 返回此抽象路径名⽗⽬录的路径名字符串；如果此路径名没有指定⽗⽬录，则返回null。lastModified()获取最后⼀次被修改的时间。 ⽂件夹相关：static File[] listRoots()列出所有的根⽬录（Window中就是所有系统的盘符）list() 返回⽬录下的⽂件或者⽬录名，包含隐藏⽂件。对于⽂件这样操作会返回null。listFiles() 返回⽬录下的⽂件或者⽬录对象（File类实例），包含隐藏⽂件。对于⽂件这样操作会返回null。list(FilenameFilter filter)返回指定当前⽬录中符合过滤条件的⼦⽂件或⼦⽬录。对于⽂件这样操作会返回null。listFiles(FilenameFilter filter)返回指定当前⽬录中符合过滤条件的⼦⽂件或⼦⽬录。对于⽂件这样操作会返回null FileInputStream与FileOutputStream类（字节流英文）写入12345678910try &#123; FileOutputStream out = new FileOutputStream(file); byte[] buy = &quot;abc&quot;.getBytes(); out.write(buy); out.close();&#125; catch (FileNotFoundException e) &#123; throw new RuntimeException(e);&#125; catch (IOException e) &#123; throw new RuntimeException(e);&#125; 读取12345678910try &#123; FileInputStream in =new FileInputStream(file); byte[] byt= new byte[1024]; int len = in.read(byt); System.out.println(&quot;content:&quot;+new String(byt,0,len));&#125; catch (FileNotFoundException e) &#123; throw new RuntimeException(e);&#125; catch (IOException e) &#123; throw new RuntimeException(e);&#125; FileWtiter与FileReader(字符流)写入123456789File file = new File(&quot;E:/word.txt&quot;);try&#123; FileWriter out = new FileWriter(file); String s=jTextArea.getText(); out.write(s); out.close();;&#125; catch (IOException e) &#123; throw new RuntimeException(e);&#125; 读取12345678910File file = new File(&quot;E:/word.txt&quot;);try&#123; FileReader in = new FileReader(file); char[] byt=new char[1024]; int len=in.read(byt); jTextArea.setText(new String(byt,0,len)); in.close();;&#125; catch (IOException e) &#123; throw new RuntimeException(e);&#125; 带缓存的输入输出流BufferedInputStream与BufferedOutputStream类 两个构造方法BufferedInputStream(InputStream in)创建带有32个字节的缓存流、BufferedInputStream(InputStream in,int size)指定大小创建缓存区，BufferedOutputStream相同 BufferedOutputStream有一个flush()方法强制将缓存区的数据输出完 BufferedReader与BuferedWriter类 BufferedReader常用方法 read()：读取单个字符 readLine()：读取文本行 BufferedWriter常用方法 write(String s,int off,int len)：写入字符串的每一部分 flush()：刷新该流的缓存强制将缓存区的数据输出完 newLine()：写入一个行分隔符 123456789101112131415161718192021222324252627282930String[] content = &#123;&quot;好久不见&quot;, &quot;你还好吗&quot;, &quot;常联系&quot;&#125;;File file = new File(&quot;E:/word.txt&quot;);//写入try &#123; FileWriter fw = new FileWriter(file); BufferedWriter bufw = new BufferedWriter(fw); for (int k = 0; k &lt; content.length; k++) &#123; bufw.write(content[k]); bufw.newLine(); ; &#125; bufw.close(); ; fw.close();&#125; catch (IOException e) &#123; throw new RuntimeException(e);&#125;//读取try &#123; FileReader fr = new FileReader(file); BufferedReader bufr = new BufferedReader(fr); String s = null; int i = 0; while ((s = bufr.readLine()) != null) &#123; i++; / System.out.println(&quot;第&quot; + i + &quot;行：&quot; + s); &#125;&#125; catch (Exception e) &#123; e.printStackTrace();&#125; 数据输入输出流（等会学）DataInputStream与DataOutputStream，类ZIP压缩输入输出流（等会学）反射长篇图解java反射机制及其应用场景 - 字母哥博客 - 博客园 (cnblogs.com) 应用场景 在程序运行期动态的根据package名.类名实例化类对象 在程序运行期动态获取类对象的信息，包括对象的成本变量和方法 在程序运行期动态使用对象的成员变量属性 在程序运行期动态调用对象的方法（私有方法也可以调用） 例子： 1234567891011121314package com.zimug.java.reflection;public class Student &#123; public String nickName; private Integer age; public void dinner()&#123; System.out.println(&quot;吃晚餐！&quot;); &#125; private void sleep(int minutes)&#123; System.out.println(&quot;睡&quot; + minutes + &quot;分钟&quot;); &#125;&#125; 用反射机制调用dinner() 123456789String SSalss=&quot;com.zimug.java.reflection.Student&quot;;String SMethod=&quot;dinner&quot;;//获取Student类信息Class cls = Class.forName(SSalss);//对象实例化Object obj = cls.getDeclaredConstructor().newInstance();//根据方法名获取并执行方法Method dinnerMethod = cls.getDeclaredMethod(SMethod);dinnerMethod.invoke(obj); //打印：吃晚餐！ 类加载与反射关系（原理部分）具体操作类 java.lang.Class: 代表一个类 java.lang.reflect.Constructor: 代表类的构造方法 java.lang.reflect.Method: 代表类的普通方法 java.lang.reflect.Field: 代表类的成员变量 Java.lang.reflect.Modifier: 修饰符，方法的修饰符，成员变量的修饰符。 java.lang.annotation.Annotation：在类、成员变量、构造方法、普通方法上都可以加注解 获取Class对象Class.forName()方法获取Class对象1234/*** Class.forName方法获取Class对象，这也是反射中最常用的获取对象的方法，因为字符串传参增强了配置实现的灵活性*/Class cls = Class.forName(&quot;com.zimug.java.reflection.Student&quot;); 参数应该是一个类名或者接口名，否则将抛出一个检查型异常（checked exception），应该加一个异常处理器 类名.class获取Class对象12345/*** `类名.class`的方式获取Class对象*/Class clz = User.class; 类对象.getClass()方式获取Class对象123456/*** `类对象.getClass()`方式获取Class对象*/User user = new User();Class clazz = user.getClass(); 获取Class类对象的基本信息12345678910111213Class cls = Class.forName(&quot;com.zimug.java.reflection.Student&quot;);//获取类的包名+类名System.out.println(cls.getName()); //com.zimug.java.reflection.Student//获取类的父类Class cls = Class.forName(&quot;com.zimug.java.reflection.Student&quot;);//这个类型是不是一个注解？System.out.println(cls.isAnnotation()); //false//这个类型是不是一个枚举？System.out.println(cls.isEnum()); //false//这个类型是不是基础数据类型？System.out.println(cls.isPrimitive()); //false Class类对象信息中几乎包括了所有的你想知道的关于这个类型定义的信息，更多的方法就不一一列举了。还可以通过下面的方法 获取Class类对象代表的类实现了哪些接口： getInterfaces() 获取Class类对象代表的类使用了哪些注解： getAnnotations() 获得Class对象的成员变量123456789101112Class cls = Class.forName(&quot;com.zimug.java.reflection.Student&quot;);Field[] fields = cls.getFields();for (Field field : fields) &#123;System.out.println(field.getName()); //nickName&#125;fields = cls.getDeclaredFields();for (Field field : fields) &#123;System.out.println(field.getName()); //nickName 换行 age&#125; getFields()方法获取类的非私有的成员变量，数组，包含从父类继承的成员变量 getDeclaredFields方法获取所有的成员变量，数组，但是不包含从父类继承而来的成员变量 获取Class对象的方法 getMethods() : 获取Class对象代表的类的所有的非私有方法，数组，包含从父类继承而来的方法 getDeclaredMethods() : 获取Class对象代表的类定义的所有的方法，数组，但是不包含从父类继承而来的方法 getMethod(methodName): 获取Class对象代表的类的指定方法名的非私有方法 getDeclaredMethod(methodName): 获取Class对象代表的类的指定方法名的方法 1234567891011121314151617181920212223242526Class cls = Class.forName(&quot;com.zimug.java.reflection.Student&quot;);Method[] methods = cls.getMethods();System.out.println(&quot;Student对象的非私有方法&quot;);for (Method m : methods) &#123; System.out.print(m.getName() + &quot;,&quot;);&#125;System.out.println(&quot; end&quot;);Method[] allMethods = cls.getDeclaredMethods();System.out.println(&quot;Student对象的所有方法&quot;);for (Method m : allMethods) &#123; System.out.print(m.getName() + &quot;,&quot;);&#125;System.out.println(&quot; end&quot;);Method dinnerMethod = cls.getMethod(&quot;dinner&quot;);System.out.println(&quot;dinner方法的参数个数&quot; + dinnerMethod.getParameterCount());Method sleepMethod = cls.getDeclaredMethod(&quot;sleep&quot;,int.class);System.out.println(&quot;sleep方法的参数个数&quot; + sleepMethod.getParameterCount());System.out.println(&quot;sleep方法的参数对象数组&quot; + Arrays.toString(sleepMethod.getParameters()));System.out.println(&quot;sleep方法的参数返回值类型&quot; + sleepMethod.getReturnType()); 执行结果： 1234567891011Student对象的非私有方法dinner,wait,wait,wait,equals,toString,hashCode,getClass,notify,notifyAll, endStudent对象的所有方法dinner,sleep, enddinner方法的参数个数0sleep方法的参数个数1sleep方法的参数对象数组[int arg0]sleep方法的参数返回值类型void 可以看到getMethods获取的方法中包含Object父类中定义的方法，但是不包含本类中定义的私有方法sleep。另外我们还可以获取方法的参数及返回值信息： 获取参数相关的属性： 获取方法参数个数：getParameterCount() 获取方法参数数组对象：getParameters() ，返回值是java.lang.reflect.Parameter数组 获取返回值相关的属性 获取方法返回值的数据类型：getReturnType() 方法的调用无参方法： 12Method dinnerMethod = cls.getDeclaredMethod(&quot;dinner&quot;);dinnerMethod.invoke(obj); //打印：吃晚餐！ 有参方法：看看invoke方法定义，第一个参数是Method对象，无论后面 Object... args有多少参数就按照方法定义依次传参就可以了。 1public Object invoke(Object obj, Object... args) 创建类的对象(实例化对象)1234567//获取Student类信息Class cls = Class.forName(&quot;com.zimug.java.reflection.Student&quot;);//对象实例化Student student = (Student)cls.getDeclaredConstructor().newInstance();//下面的这种方法是已经Deprecated了，不建议使用。但是在比较旧的JDK版本中仍然是唯一的方式。//Student student = (Student)cls.newInstance(); 反射的常用场景 通过配置信息调用类的方法 结合注解实现特殊功能 按需加载jar包或class 通过配置信息调用类的方法1234567891011121314public void invokeClassMethod(String className,String methodName) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123; //获取类信息 Class cls = Class.forName(className); //对象实例化 Object obj = cls.getDeclaredConstructor().newInstance(); //根据方法名获取并执行方法 Method dinnerMethod = cls.getDeclaredMethod(methodName); dinnerMethod.invoke(obj);&#125; 结合注解实现特殊功能大家如果学习过mybatis plus都应该学习过这样的一个注解TableName，这个注解表示当前的实例类Student对应的数据库中的哪一张表。如下问代码所示，Student所示该类对应的是t_student这张表。 12345@TableName(&quot;t_student&quot;)public class Student &#123; public String nickName; private Integer age;&#125; 下面我们自定义TableName这个注解 12345@Target(ElementType.TYPE) //表示TableName可作用于类、接口或enum Class, 或interface@Retention(RetentionPolicy.RUNTIME) //表示运行时由JVM加载public @interface TableName &#123; String value() ; //则使用@TableName注解的时候： @TableName(”t_student”);&#125; 有了这个注解，我们就可以扫描某个路径下的java文件，至于类注解的扫描我们就不用自己开发了，引入下面的maven坐标就可以 12345&lt;dependency&gt; &lt;groupId&gt;org.reflections&lt;/groupId&gt; &lt;artifactId&gt;reflections&lt;/artifactId&gt; &lt;version&gt;0.9.10&lt;/version&gt;&lt;/dependency&gt; 看下面代码：先扫描包，从包中获取标注了TableName注解的类，再对该类打印注解value信息 12345678910// 要扫描的包String packageName = &quot;com.zimug.java.reflection&quot;;Reflections f = new Reflections(packageName);// 获取扫描到的标记注解的集合Set&lt;Class&lt;?&gt;&gt; set = f.getTypesAnnotatedWith(TableName.class);for (Class&lt;?&gt; c : set) &#123;// 循环获取标记的注解TableName annotation = c.getAnnotation(TableName.class);// 打印注解中的内容System.out.println(c.getName() + &quot;类，TableName注解value=&quot; + annotation.value()); 输出结果是： 1com.zimug.java.reflection.Student类，TableName注解value=t_student 有的朋友会问这有什么用？这有大用处了。有了类定义与数据库表的对应关系，你还能通过反射获取类的成员变量，之后你是不是就可以根据表明t_student和字段名nickName，age构建增删改查的SQL了？全都构建完毕，是不是就是一个基础得Mybatis plus了？ 反射和注解结合使用，可以演化出许许多多的应用场景，特别是在架构优化方面，等待你去发觉啊！ 按需加载jar包或class在某些场景下，我们可能不希望JVM的加载器一次性的把所有的jar包装载到JVM虚拟机中，因为这样会影响项目的启动和初始化效率，并且占用较多的内存。我们希望按需加载，需要用到哪些jar，按照程序动态运行的需求取加载这些jar。 1234567//按路径加载jar包File file = new File(&quot;D:/com/zimug/commons-lang3.jar&quot;);URL url = file.toURI().toURL();//创建类加载器ClassLoader classLoader = new URLClassLoader(new URL[]&#123;url&#125;);Class cls = classLoader.loadClass(&quot;org.apache.commons.lang3.StringUtils&quot;); 同样的把.class文件放在一个路径下，我们也是可以动态加载到的 1234567//java的.class文件所在路径File file = new File(&quot;D:/com/zimug&quot;);URL url = file.toURI().toURL();//创建类加载器ClassLoader classLoader = new URLClassLoader(new URL[]&#123;url&#125;);//加载指定类，package全路径Class&lt;?&gt; cls = classLoader.loadClass(&quot;com.zimug.java.reflection.Student&quot;); 类的动态加载能不能让你想到些什么？是不是可以实现代码修改，不需要重新启动容器？对的，就是这个原理，因为一个类的Class对象只有一个，所以不管你重新加载多少次，都是使用最后一次加载的class对象（上文讲过哦）。 反射的优缺点 优点：自由，使用灵活，不受类的访问权限限制。可以根据指定类名、方法名来实现方法调用，非常适合实现业务的灵活配置。 缺点： 也正因为反射不受类的访问权限限制，其安全性低，很大部分的java安全问题都是反射导致的。 相对于正常的对象的访问调用，反射因为存在类和方法的实例化过程，性能也相对较低 破坏java类封装性，类的信息隐藏性和边界被破坏 异常处理12345678910111213141516171819202122232425262728try&#123; //程序代码块 &#125;catch(Exception e)&#123; //异常处理&#125;finally&#123; //程序块不论是否异常都被执行 //finally代码块的职责不在于对变量进行赋值等操作，而是清理资源、释放连接、关闭管道流等操作&#125;//例子public class wa &#123; public static void main(String[] args) &#123; TEst t = null; try &#123; t.cc = 10 / 0; &#125; catch (NullPointerException ne) &#123; System.out.println(&quot;--------&quot;); &#125; catch (ArithmeticException ae) &#123; System.out.println(&quot;+++++++&quot;); &#125; System.out.println(&quot;===&quot;); &#125;&#125;//out+++++++=== 自定义异常12345public calss MyException extends Exception&#123; public MyException(String ExceptionName)&#123; super(ExceptionName); &#125;&#125; throw1234567891011public void method()thorws Exception&#123; &#125;public static void main(String[] args)&#123; try &#123; method(); &#125; catch (Exception ne) &#123; System.out.println(&quot;--------&quot;); &#125; &#125; 泛型 为防止向下转型时抛出ClassCastException异常 123456789101112131415161718public class fanxincalss&lt;T&gt;&#123; private T over; public T get()&#123; return over;&#125; public void set(T over)&#123; this.over=over; &#125; public static void main(String[] args)&#123; fanxinclass&lt;Boolean&gt; over1 = new fanxinclass&lt;Boolean&gt;(); fanxinclass&lt;Float&gt; over2 = new fanxinclass&lt;Float&gt;(); over1.set(true);//无需类型转换 over2.set(12.3); Blooean b = over1.get();//无需向下转型 Float f = over2.get(); &#125;&#125; 常规用法 定义泛型类时声明多个类型 1Class&lt;T1,T2&gt; 定义泛型类时声明数组类型 123Class&lt;T&gt;&#123; T[] array; &#125; 集合类声明容器的元素（Map&lt;K,V&gt;） 高级用法 限制泛型可用类型 1class 类名称&lt;T extends anyClass&gt;//T必须实现或继承anyClass接口/类 使用类型通配符 123A&lt;? extends List&gt;a=null;a=new A&lt;ArrayList&gt;();a=new A&lt;LinkedList&gt;(); 使用通配符创建的对象不能改变集合中的值，只能获取和删除 定义为泛型的类和接口也可以被继承或实现 集合类(数据结构)（见书）list123456789101112131415161718192021222324252627282930313233343536List&lt;String&gt; list =new LinkedList&lt;String&gt;();list.add(&quot;zstr1&quot;);list.add(&quot;astr2&quot;);list.add(&quot;cstr3&quot;);list.add(&quot;bstr4&quot;);//列表的排序 //1 list.sort(new Comparator&lt;String&gt;() &#123; @Override public int compare(String o1, String o2) &#123; // TODO Auto-generated method stub return o2.compareTo(o1); &#125; &#125;); //2 Collections.sort(list, new Comparator&lt;String&gt;() &#123; @Override public int compare(String o1, String o2) &#123; // TODO Auto-generated method stub return o2.compareTo(o1); &#125; &#125;); //列表的遍历 //1 for(String st:list) &#123; System.out.println(st); &#125; //2 Iterator&lt;String&gt; itlist=list.iterator(); while(itlist.hasNext()) &#123; String str=itlist.next(); System.out.println(str); &#125; set1234567891011121314151617181920212223Set&lt;String&gt; set =new TreeSet&lt;String&gt;(new Comparator&lt;String&gt;() &#123; @Override public int compare(String o1, String o2) &#123; // TODO Auto-generated method stub return o2.compareTo(o1); &#125; &#125;);set.add(&quot;zstr1&quot;); set.add(&quot;astr2&quot;); set.add(&quot;cstr3&quot;); set.add(&quot;bstr4&quot;);//set的遍历 //1 for(String s:set) &#123; System.out.println(s); &#125; //2 Iterator&lt;String&gt; itset=set.iterator(); while(itset.hasNext()) &#123; String sttString = itset.next(); System.out.println(sttString); &#125; map1234567891011121314151617181920212223242526272829303132//map的排序 Map&lt;Integer,String&gt; map =new TreeMap&lt;Integer,String&gt;(new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; // TODO Auto-generated method stub return o2 - o1; &#125; &#125;); map.put(1, &quot;zstr1&quot;); map.put(2, &quot;astr2&quot;); map.put(3, &quot;cstr3&quot;); map.put(4, &quot;bstr4&quot;); //map的遍历 //1 for(Map.Entry&lt;Integer, String&gt; entry:map.entrySet()) &#123; System.out.print(entry.getKey()+&quot; ：&quot;); System.out.println(entry.getValue()); &#125; //2 Iterator&lt;Map.Entry&lt;Integer,String&gt;&gt; iterator=map.entrySet().iterator(); while(iterator.hasNext()) &#123; Map.Entry&lt;Integer,String&gt; entry=iterator.next(); System.out.print(entry.getKey()+&quot; ：&quot;); System.out.println(entry.getValue()); &#125; for(int i=65;i&lt;=122;i++) &#123; System.out.print((char)i+&quot;&quot;); &#125; CollectionsListList里存放的对象是有序的，同时也是可以重复的，List关注的是索引，拥有一系列和索引相关的方法，查询速度快。因为往list集合里插入或删除数据时，会伴随着后面数据的移动，所有插入删除数据速度慢。 ArrayListArrayList 是一个可改变大小的数组.当更多的元素加入到ArrayList中时,其大小将会动态地增长.内部的元素可以直接通过get与set方法进行访问,因为ArrayList本质上就是一个数组. 在初始化ArrayList时，会构建空数组（Object[] elementData&#x3D;{}）。ArrayList是一个无序的，它是按照添加的先后顺序排列，当然，他也提供了sort方法，如果需要对ArrayList进行排序，只需要调用这个方法，提供Comparator比较器即可. LinkedListLinkedList是基于链表的，它是一个双向链表，每个节点维护了一个prev和next指针。同时对于这个链表，维护了first和last指针，first指向第一个元素，last指向最后一个元素。LinkedList是一个无序的链表，按照插入的先后顺序排序，不提供sort方法对内部元素排序。 在添加和删除元素时具有比ArrayList更好的性能.但在get与set方面弱于ArrayList.当然,这些对比都是指数据量很大或者操作很频繁的情况下的对比,如果数据和运算量很小,那么对比将失去意义. Map遍历方法Iterator多线程继承Thread类12345678public calss ThreadTest extends Thread&#123; public void run()&#123; //do something &#125; public static void main(String[] args)&#123; new ThreadTest().start(); &#125;&#125; 实现Runnable接口123456789101112131415161718192021222324252627282930//直接在类中使用public class A &#123; public A()&#123; Thread t; t= new Thread(new Runnable()&#123; //匿名内部类 实现接口 public void run()&#123; //重写方法 //do something &#125; &#125;); t.start(); &#125; public static void main(String[] args)&#123; new A(); &#125;&#125;//实现接口public class A implements Runnable&#123; public void run()&#123; //do something &#125; public static void main(String[] args)&#123; A a = new A(); Thread t=new Thread(a); t.start(); //new Thread(new A()).start(); &#125;&#125; 线程的生命周期 操作线程线程的休眠12345try&#123;Thread.sleep(1000);&#125;catch(InterruptedExpection e)&#123;e.printStackTrace();&#125; 线程的加入123456try &#123; Thread.sleep(1000); t2.join(); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; 线程的中断121.使用while循环终止2.thread.interrupt(); 线程的优先级1t.setPriority();//54321依次降低 线程的同步12345678public void run()&#123; while(true)&#123; synchronized()&#123; //do something &#125; &#125;&#125; 同步方法 当对象调用了同步方法时，该对象上的其他同步方法必须等待该同步方法执行完毕后才能被执行。将每个能访问共享资源的方法修饰为synchronized 12345678public synchronized void doit()&#123; //do smoething&#125;public void run()&#123; while(true)&#123; doit(); &#125;&#125; 网络通信（见书）数据库操作（见书）swing高级程序设计（见书）单例设计模式饿汉式（容易浪费资源）123456789101112131415161718192021package example;public class TestE &#123; public static void main(String[] args)&#123; Girl instance = Girl.getInstance(); System.out.println(&quot;instance = &quot; + instance); &#125;&#125;class Girl&#123; private String name; private static Girl gf = new Girl(&quot;xhh&quot;); private Girl(String name)&#123; this.name=name; &#125; public static Girl getInstance()&#123; return gf; &#125;&#125; 懒汉式123456789101112131415161718192021222324package example;public class TestE &#123; public static void main(String[] args)&#123; Girl instance = Girl.getInstance(); System.out.println(&quot;instance = &quot; + instance); &#125;&#125;class Girl&#123; private String name; private static Girl gf ; private Girl(String name)&#123; this.name=name; &#125; public static Girl getInstance()&#123; if(gf==null)&#123; gf=new Girl(&quot;xhh&quot;); &#125; return gf; &#125;&#125; pSstatichttps://blog.csdn.net/qq_28761767/article/details/80994445 https://blog.csdn.net/LIAO_7053/article/details/81408139 final 静态代码块，代码块，构造方法执行顺序1、一个类先后执行顺序：静态代码块 → 普通代码块 → 子类构造方法 2、子父类当比较子父类执行顺序时：父类静态代码块 → 子类静态代码块 → 父类普通代码块 → 父类构造方法 → 子类普通代码块 → 子类构造方法 1、静态与非静态静态的是随着类的加载而执行，普通的则是实例化的时候执行：静态早于普通 2、变量与代码块的执行顺序谁先声明谁先执行：静态变量与静态代码块谁先声明谁先执行；普通变量与普通代码块谁先声明谁先执行； lang包https://blog.csdn.net/u012834750/article/details/79361552 String txt &#x3D; “&quot;The economic reality is, we have to manage the relationship. This type of realism has to guide our thinking on trade,&quot; Dade said at the forum on Canada-China trade relations that was co-organized by the Optical Valley Institute for Free Trade and the Jack Austin Centre for Asia Pacific Business Studies.”; String str[] &#x3D; txt.split(“&quot;| |\\.|\\,”); word[] words &#x3D; new word[51]; for (int i &#x3D; 0; i &lt;&#x3D; 50; i++) { words[i] &#x3D; new word(); } int j = 0; for (int k = 0; k &lt;= 55; k++) &#123; if (str[k].isEmpty()) &#123; &#125; else &#123; words[j].word = str[k]; j++; &#125; &#125; for (int i = 0; i &lt;= 50; i++) &#123; System.out.println(words[i].word + &quot;:&quot; + words[i].count); &#125; System.out.println(&quot; &quot;); System.out.println(&quot; &quot;); for (int i = 0; i &lt;= 50; i++) &#123; for (int n = i + 1; n &lt;= 50; n++) &#123; boolean b = words[i].word.equalsIgnoreCase(words[n].word); // System.out.println(b); if (b == true) &#123; // System.out.println(i); //System.out.println(n); //System.out.println(&quot;del&quot;); words[i].add(); words[n].word = &quot;del&quot;; &#125; &#125; &#125; for (int i = 0; i &lt;= 50; i++) &#123; if (!words[i].word.equals(&quot;del&quot;) ) &#123; System.out.println(words[i].word + &quot;:&quot; + words[i].count); &#125; &#125; JVM规范内存模型https://blog.csdn.net/qq_36704549/article/details/109390566 值传递&#x2F;引用传递（内存理解）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package javasuanfa;public class Main &#123; public static void main(String[] args) &#123; circle circle1 = new circle(1); circle circle2 = new circle(2); swap1(circle1, circle2); System.out.println(circle1.radius + &quot;\\n&quot; + circle2.radius); swap2(circle1, circle2); System.out.println(circle1.radius + &quot;\\n&quot; + circle2.radius); int[] a = &#123;1, 2&#125;; swap3(a[0], a[1]); System.out.println(&quot;a[0]=&quot; + a[0] + &quot;a[1]=&quot; + a[1]); int[] b = &#123;1, 2&#125;; swap4(b); System.out.println(&quot;b[0]=&quot; + b[0] + &quot;b[1]=&quot; + b[1]); T t1=new T(); T t2=new T(); System.out.println(&quot;t1.i=&quot;+t1.i); System.out.println(&quot;t2.i=&quot;+t2.i); int[] list= &#123;1,2,3,4,5&#125;; reverse(list); for(int i = 0;i&lt;list.length;i++ )&#123; System.out.println(list[i]+&quot; &quot;); &#125; swarp(list); for(int i = 0;i&lt;list.length;i++ )&#123; System.out.println(list[i]+&quot; &quot;); &#125; &#125; public static void reverse(int[] list)&#123; int[] newlist = new int [list.length]; for(int i = 0;i&lt;list.length;i++)&#123; newlist[i]=list[list.length-1-i]; &#125; list=newlist; &#125; public static void swarp(int[] a)&#123; int temp=a[0]; a[0]=a[1]; a[1]=temp; &#125; public static void swap1(circle x, circle y) &#123; circle temp = x; x = y; y = temp; &#125; public static void swap2(circle x, circle y) &#123; double temp = x.radius; x.radius = y.radius; y.radius = temp; &#125; public static void swap3(int n1, int n2) &#123; int temp = n1; n1 = n2; n2 = temp; &#125; public static void swap4(int[] a) &#123; int temp = a[0]; a[0] = a[1]; a[1] = temp; &#125; &#125;class circle &#123; double radius; circle(double i) &#123; radius = i; &#125; &#125;class T&#123; static int i=0; T()&#123; i++; &#125;&#125; out: 1234567891.02.02.01.0a[0]=1a[1]=2b[0]=2b[1]=1t1.i=2t2.i=2 https://blog.csdn.net/xiaojinlai123/article/details/88678367?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&amp;utm_relevant_index=2","categories":[{"name":"culitivate","slug":"culitivate","permalink":"http://example.com/categories/culitivate/"},{"name":"java技术栈","slug":"culitivate/java技术栈","permalink":"http://example.com/categories/culitivate/java%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"java","slug":"culitivate/java技术栈/java","permalink":"http://example.com/categories/culitivate/java%E6%8A%80%E6%9C%AF%E6%A0%88/java/"}],"tags":[]},{"title":"","slug":"culitivate/408/计组","date":"2023-09-05T06:13:16.676Z","updated":"2023-09-20T08:42:18.828Z","comments":true,"path":"2023/09/360cf1687a6f.html","link":"","permalink":"http://example.com/2023/09/360cf1687a6f.html","excerpt":"","text":"第一章 计算机系统概述第二章 数据的表示和运算第三章 存储系统第四章 指令系统第五章 中央处理器第六章 总线第七章 I&#x2F;O系统","categories":[{"name":"culitivate","slug":"culitivate","permalink":"http://example.com/categories/culitivate/"},{"name":"408","slug":"culitivate/408","permalink":"http://example.com/categories/culitivate/408/"}],"tags":[]},{"title":"","slug":"culitivate/other/CTF/解题","date":"2023-08-23T05:08:29.213Z","updated":"2023-09-20T08:42:18.846Z","comments":true,"path":"2023/08/0181bf88249d.html","link":"","permalink":"http://example.com/2023/08/0181bf88249d.html","excerpt":"","text":"我们开发的微信小程序是关于碳排放的微信小程序，本微信小程序将低碳环保与个人的健康紧密相连。在使用本小程序时，用户通过一些趣味性的打卡活动来获取并且记录自己的碳足迹，在潜移默化之中提升用户的环保、低碳意识。同时我们还有健康饮食等热门专区，以便用户在关注地球健康的同时也注重自身健康，此外我们还会有垃圾分类、光盘打卡等专区以及一些短期活动来让用户在获取碳足迹的同时，亲身参与到低碳生活之中。下面是关于本微信小程序的一些详细介绍。 此次低碳主题的微信小程序开发，作为团队的一员，万雅慧主要负责一级页面及衍生界面。一级页面即进入小程序所展现的页面，有首页、专区、我的三大板块，衍生界面包括对一级页面功能的进一步实现。 首先简要介绍一下，在小程序中，用户可以进行各种打卡：饮食、出行、低碳……获得“能量值”，程序在后台将其转化为虚拟的“树木”。树木的数量一定程度上体现了用户的规模和低碳行动的程度。在后续开发中，我们也将考虑树木的具体用途。 其次介绍页面及其具体功能。 “首页”主要内容有三个：一是展示所有用户收集的树木，作为用户了解树木总量，以及了解其他用户树木情况的接口。二是各种打卡任务、参与活动的入口。三是小型排行榜区域，展示前几名的用户的树木量，同时也能跳转到更多用户排名。 由此，首页的衍生界面有用户树木展示区、排行榜、每日打卡区、参与活动区。在展示区中，除了总的树木量，用户可以点击屏幕随机获取其他用户的简略信息和树木量，后续我们将考虑地图的形式，增加体验感。打卡区则作为一个重点，用户进行每日的低碳健康打卡，如微信步数、骑行距离、屏幕使用时间、睡眠时间等……我们期待通过这些日常打卡，用户开始注意并自觉养成低碳健康的生活习惯。 “专区”的主要功能是不同专题区域的入口，同时编写了发布的衍生界面。进入发布页面，用户可以分享“低碳”、“饮食”、“垃圾”三种类型的经验，并更新到相关专题。同时，该页面还包括用户发布的所有图文，方便用户管理、查看。在设计时，采用了区域内滚动的方法，营造有限中的无限感。总的来说，我们期待通过合理的页面设计、良好的数据支持、趣味的交互体验，促使用户积极分享经验，让低碳健康的生活成为交流的桥梁，融入日常。 “我的”顾名思义，是用户个人信息及登录等功能的页面。包括一些简单的逻辑，比如用户授权前后头像昵称的更换，提示用户授权的方法。衍生界面目前实现了：一是个人信息的保存更改，二是小程序的概念和介绍。其中，个人信息界面在实现初期耗费较多时间，为后续提供了数据交互、方法实现、网络申请等经验。 最后，在开发过程中，可能会碰到各种状况，会因为小错误耽误许多时间，会因为不够理解琢磨方法，会因为结果不理想不断调试……客观上的困难，主观上的挫折都是前进的阻碍。当然我们坚持到这一步，不仅是技术上的可行性，更是因为低碳健康生活的社会价值和深远意义。作为一个开发团队，我们使用专业知识促进低碳环保，相信这是具有社会责任感的方式。 作为团队的一员，邬宇俊主要负责光盘打卡、垃圾分类等子页面，下面是详细的介绍。 首先，碳排放足迹功能是我微信小程序的核心之一。通过用户输入的信息，计算出他们在生活中产生的碳排放量。在开发这一功能时，我深入学习了碳排放的计算方法，了解到不同生活方式和消费习惯对环境的影响。这让我意识到，每一个人都应该对自己的行为负责，努力减少碳排放，为地球的可持续发展出一份微薄的力量。 其次，光盘打卡功能是鼓励用户节约粮食的创意之一。通过记录用户每餐的食物摄入情况，提醒他们适量就餐，减少浪费。在这个过程中，我感受到了食物资源的宝贵性。大量的粮食被浪费，不仅浪费了资源，也加剧了环境压力。通过这个功能，我希望能够唤起用户的节约意识，从小事做起，减少不必要的浪费。 最后，垃圾分类页面也是我微信小程序的亮点之一。我提供了详细的垃圾分类指南，帮助用户正确分类处理垃圾。在这个过程中，我深刻意识到垃圾分类对于环境保护的重要性。正确的垃圾分类可以最大限度地减少资源的浪费，降低污染。通过这个功能，我希望能够引导用户养成良好的垃圾分类习惯，从而为环保事业贡献一份力量。 而我在本款微信小程序中担任后端开发的工作，在本微信小程序的后端中，我们采用了springboot框架进行开发，较好地实现了用户登录、动态打卡等一些基本功能，以下是已经实现的部分功能： 1. 构建用户账号系统： 我设计了一个完善的用户账号系统，用户可以注册、登录、修改个人信息等。通过有效的身份验证，确保用户数据的安全性和隐私。 2. 实现低碳任务打卡： 在微信小程序中，我开发了每日低碳任务打卡功能，用户可以记录自己的碳排放行为，获得碳能量值作为奖励。采用定时任务来处理每日任务的重置和分配。 3. 社区分享与动态发布： 用户可以发布碳排放打卡的动态分享，促进用户之间的互动与碳减排意识的传播。我开发了动态发布和浏览功能，支持文字、图片等多种形式的内容分享。 通过本次微信小程序的开发，我们成功将环保意识与个人健康紧密融合，为用户提供了一个有趣而又有意义的互动平台。用户不仅可以通过趣味性的打卡活动记录碳足迹，逐步培养环保习惯，还能在关注地球健康的同时关注自身健康。健康饮食、垃圾分类、光盘打卡等专区的设置，更进一步引导用户在日常生活中采取实际行动，促进低碳生活的融入。 我们坚信，这款微信小程序将成为推动环保与健康理念传播的重要平台。用户不仅可以在小程序中获取有关碳足迹的知识，还能通过积极参与各类活动，将这些理念融入到自己的生活中。从而在个人层面积极响应环保倡议，共同建设可持续的地球家园。","categories":[{"name":"culitivate","slug":"culitivate","permalink":"http://example.com/categories/culitivate/"},{"name":"other","slug":"culitivate/other","permalink":"http://example.com/categories/culitivate/other/"},{"name":"CTF","slug":"culitivate/other/CTF","permalink":"http://example.com/categories/culitivate/other/CTF/"}],"tags":[]},{"title":"","slug":"工具记录/找书","date":"2023-08-15T06:27:29.283Z","updated":"2023-09-20T08:42:18.828Z","comments":true,"path":"2023/08/5c873852bb67.html","link":"","permalink":"http://example.com/2023/08/5c873852bb67.html","excerpt":"","text":"感谢信任，认真找一下，你想要的书都可以找到。 请认真花2分钟看完 【进文档后 要下载文档 可以直接进入网站 不用复制】 一定要看完文档【淘宝卖家所有下载书籍网站 在最下面分类好的】 使用方法 进入网站 搜索书名或者作者 不要搜索isbn 资源库网址：1 http://119.28.90.216 账号：13441239011密码12345678（账号密码需手动输入）****【注意一定要看 不要把资源库 卡密借给别人使用 资源库后台有监控 下载IP异常的 会限制IP登陆下载，！！ 账号登入异常联系客服处理****】 资源库没有的在文档下面搜索其他的对应的资源 资源库没有的在文档下面搜索其他的对于的资源 资源库没有的在文档下面搜索其他的对于的资源 最大的中文电子书借阅平台： http://www.ucdrs.superlib.net/ （需要注册一个账号 很简单） 可以查找 书籍 期刊 报纸 论文 还有外文哦 点击图书文献传递 每个账户每天可以借阅50页，可以设置每次借阅的页数，比如你特别需要哪些页可以指定。【可以查到文献下载的就是有 没有文献下载的就是没有】 资源3：最好的云盘搜索引擎 https://www.upyunso.com/ 网站四：刚发布的新书有些也能找到 https://weread.qq.com/ 网站五：无名图书 https://www.book123.info 网站六： https://new.shuge.org 网站七：古籍书下载 https://new.shuge.org/ https://ctext.org/library.pl?if=gb https://www.allhistory.com 网站八：漫画站 https://5ikmh.ink 外文常用网站： https://www.gutenberg.org/ https://www.forgottenbooks.com/en **https://pubmed.ncbi.nlm.nih.gov/(**英语医学文献) **https://monoskop.org/Library_Genesis**（创世纪） 【资源库没有的 在找下面分类的 资源 】 这里集合了所有的 淘宝卖家代找书籍下载的所有资源网站 【图片下面是对应的网站】 下载链接 鸠摩搜书 https://www.jiumodiary.com/ 搬书匠 http://www.banshujiang.cn 爱悦读 https://www.iyd.wang/ 阅读 书籍搜索 https://bks.thefuture.top/ 备注 【打不开换浏览器】 智慧教育 https://basic.smartedu.cn/tchMaterial 144****本生物医学电子书资源 https://zhuanlan.zhihu.com/p/423568288 丁香园 https://portal.dxy.cn/ 计算机编程类 IT****类相关书籍汇总 https://tanqingbo.cn/CSBook001/ 码农之家 https://www.xz577.com/ Github https://github.com/justjavac/free-programming-books-zh_CN 英文外文类资源 在下面对应网站搜索 project Gutenberg https://www.gutenberg.org/ Digilbraries.com https://digilibraries.com/ Forgotten books 129w****本书 https://www.forgottenbooks.com/en 小说和漫画 Animex 动漫社 http://www.animetox.com/category/source BZ Mangabz https://mangabz.com/ K 漫 注册需要5毛钱 https://5ikmh.ink/ 久久小说下载网 https://www.ijjxsw.net/ 知轩藏书 https://www.zxcs.info/ 千秋书在 https://www.qqszz.com/manhuakk/mianfeimanhua 古籍古书 红堂文库 http://hong.ioc.u-tokyo.ac.jp/list.php 国家书籍图书馆 https://www.digital.archives.go.jp/","categories":[{"name":"工具记录","slug":"工具记录","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7%E8%AE%B0%E5%BD%95/"}],"tags":[]},{"title":"","slug":"工具记录/工具使用","date":"2023-08-09T02:45:47.121Z","updated":"2023-09-20T08:42:18.828Z","comments":true,"path":"2023/08/aac36af29990.html","link":"","permalink":"http://example.com/2023/08/aac36af29990.html","excerpt":"","text":"anaconda环境命令查看环境conda info –envs 激活环境activate envs 退出当前环境deactivate envs 删除环境 1conda remove -n 环境名 --all 创建环境conda create -n envname python&#x3D;versionnumber","categories":[{"name":"工具记录","slug":"工具记录","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7%E8%AE%B0%E5%BD%95/"}],"tags":[]},{"title":"","slug":"plan/安排","date":"2023-08-02T09:38:24.937Z","updated":"2023-09-20T08:42:18.828Z","comments":true,"path":"2023/08/0bb587f95395.html","link":"","permalink":"http://example.com/2023/08/0bb587f95395.html","excerpt":"","text":"日常9.129-12 mysql必知必会看完2.30-4 核心技术4+54.30-5.30普通话准备6.30-8.30数据结构：过基础+刷题8.30-10.30计组10.30-11.30课程 9.139-11.30 普通话：1. 10篇命题11.30-1吃饭+休息1.30-5 核心技术4+55.30-6.30普通话 词表（1小时） 10篇命题（1小时） 20篇朗读（1小时）6.30-9数据结构10-11计组 9.143-5核心技术6+76-8数据结构8-10普通话 9.152-420篇6分钟一篇4-4.30熟练3篇5.30-10.30熟练27篇 9.19核心技术6+7数学建模数据结构计组项目&#x2F;数学&#x2F;课程 9.204-5核心技术75.30-6.30核心技术86.30-9核心技术6 2023 年计算机基础最全自学指南！ - 知乎 (zhihu.com)(9 封私信 &#x2F; 9 条消息) 数据结构，计算机网络，数据库，计算机组成原理，操作系统有哪些好的网课值得推荐? - 知乎 (zhihu.com)】 书籍：计算机专业电子书下载_程序员免费高清PDF书籍_IT类相关书籍汇总 | IT码农 (tanqingbo.cn) 计算机基础计算机考研408专业课130+经验分享 - 知乎 (zhihu.com) 数据结构与算法实战中总结的125道面试高频算法题！再也不怕手撕代码了！ (qq.com) 《数据结构（C语言版）》 严蔚敏《数据结构考研复习指导》王道https://www.zhihu.com/answer/3189783945 第一轮 基础(20天) 9.7-9.27基础理论(算法，20天系统过一遍) 第二轮 提升(两个月)根据刷题册刷leetcode （120）LeetCode刷题顺序，按标签分类刷题 - Uoffer 第三轮 强化(三个月)Leetcode、剑指offer、笔试题刷题清单 (ngui.cc)剑指offer(66，一天3题25天)力扣刷题hot100(40天)leetcode前200(80天) 第四轮 面试题（持续）第一轮（三月9.7-12.7）看完书本每一章节,再看对应的王道的章节,做笔记，再做王道对应习题。 计算机组成原理（21天）唐书+王道讲义+（刘、王道视频）《计算机组成原理》唐朔飞《计算机系统基础 》袁春风 1袁春风老师的《计算机系统基础》这本书与王道《组成原理》的对应关系大致为：《系统基础》第1章对应“王道”第1章，《系统基础》第2章对应“王道”第2章，《系统基础》第3、4章对应“王道”第4章，《系统基础》第5章对应“王道”第5章，《系统基础》第6章对应“王道”第3章，《系统基础》第7、8章对应“王道”第6、7章（注：看完《系统基础》7、8章，再看王道6、7章）。 《计算机组成原理考研复习指导》王道 操作系统（48天）《计算机操作系统(第四版)》汤小丹《深入理解计算机系统》《现代操作系统》《计算机操作系统考研复习指导》王道 计算机网络（24天）《计算机网络(第 7 版)》谢希仁《计算机网络 自顶向下》《计算机网络考研复习指导》王道 第二轮（12.10-1.25）刷一遍自己以及王道笔记+书上错题真题，结合教材，巩固。 计组+操作系统交叉复习（一个月）组原1-&gt;操作系统1-&gt;组原2-&gt;组原3-&gt;操作系统3-&gt;组原4-&gt;组原5-&gt;操作系统2-&gt;组原6-&gt;组原7-&gt;操作系统4、5。 计算机网络（15天）第三轮（一月2.1-3.1）成套做真题，并且查漏补缺二十套左右 第四轮（一月3.1-4.1）刷第三轮中的错题二十套左右 秋招java技术栈2022Java岗最全面试攻略，吃透25个技术栈Offer拿到手软 - 知乎 (zhihu.com) 2023年最新互联网Java面试八股文出炉（附大厂P5-P8技术栈） - 知乎 (zhihu.com) Github 标星 120k！2023 最新Java 学习线路图重磅来袭| JavaGuide - 知乎 (zhihu.com) 2023年Java学习路线【超详细超实用】 - 哔哩哔哩 (bilibili.com) 2022超详细的Java学习路线总结 - 知乎 (zhihu.com) 2023最新超详细Java学习路线一条龙版（建议收藏🔥） | 二哥的Java进阶之路 (javabetter.cn) 一、JAVA基础（30天）1.1基础(30天)9.7-10.7《java核心技术 卷1》 基本语法、基本数据类型 对象、类、接口 继承、泛型 方法 异常、断言 集合 容器 IO 1.2多线程&amp;并发《java并发编程之美》《java并发编程实战》《实战java高并发程序设计》第一篇：基础篇 - 深入浅出Java多线程 (gitbook.io) 1.3JVM《深入理解java虚拟机》 1.4 JDK8二、数据库（7天）9.7-9.142.1mysql《mysql必知必会》《高性能MySQL》《MySQL技术内幕》 三、javaweb（15天）(9 封私信 &#x2F; 13 条消息) 2023年，求适合小白的JavaWeb学习路线图，求分享？ - 知乎 (zhihu.com) 3.1html，css，JavaScript，vue3.2ajax3.3服务器容器Tomcat&amp;HTTP协议3.4jdbc（可省）3.5动态网页开发技术Serviet&amp;Jsp（可省）3.6会话技术3.7xml（可省）四、java开发框架（75天）4.1常用工具（几天熟悉一下）4.1.1项目构建Maven4.1.2版本控制Git4.1.2Docker4.2SSM4.2.1Spring4.2.2Spring MVC4.2.3MyBatis\\MyBatis-Plus4.3SpringBoot4.4Linux（10天）项目实战五、分布式中间件（60天）5.1Nginx5.2Redis5.3RocketMQ（Message Queue）5.4Elasticsearch5.5Docker面试八股文六、微服务和分布式（60天）6.1Spring Cloud6.2Dubbo6.3ZooKeeper考研(9 封私信 &#x2F; 13 条消息) 660和880什么阶段做? - 知乎 (zhihu.com) 数学(9 封私信 &#x2F; 13 条消息) 24考研数学一，基础比较薄弱，330、660、880、1000、1800这些习题集建议做哪几本呢？ - 知乎 (zhihu.com) 知能行考研数学 - App (bestzixue.com) (9 封私信 &#x2F; 17 条消息) 考研数学做题是汤家凤1800好，还是张宇1000题好？ - 知乎 (zhihu.com) 题型分布一、试卷内容结构高等教学约60% 线性代数约20% 概率论与数理统计约20%二、试卷题型结构单选题10小题，每小题5分，共50分 填空题6小题，每小题5分，共30分 解答题（包括证明题）6小题，共70分三、具体1、微积分：函数、极限、连续、一元函数微积分学、多元函数微积分学、无穷级数、常微分方程与差分方程; 2、线性代数：行列式、矩阵、向量、线性方程组、矩阵的特征值和特征向量、二次型; 3、概率论与数理统计：随机事件和概率、随机变量及其概率分布、随机变量的联合概率分布、随机变量的数字特征、大数定律和中心极限定理、数理统计的基本概念、参数估计、假设检验。 第一轮（2个月）9.7-11.7 - 高数、线代和概率论 - 跟着以往笔记复习一遍（搞个讲义 张宇18讲+李永乐 ），刷知能行(汤家凤1800+张宇1000（难，选部分）)打基础 第二轮（三个月）11.7-2.7 - 刷知能行(660（选择填空难度大）+330（大题看情况）+880（难度接近真题）+108)强化基础 第三轮（两个月）2.7-4.7 - 真题+模拟 第四轮（一个月）4.7-5.7 - 真题错题+专题训练+知识点回顾 英语(9 封私信 &#x2F; 17 条消息) 考研英语应该怎么复习？时间怎么安排？ - 知乎 (zhihu.com) 题型分布 第一轮 （三个月）9.10-12.10- 一轮背单词（一个月） - 《考研词汇闪过》 - 二轮背单词+学语法（两个月） - 做真题加强单词熟悉度（一个月） - 任务:本阶段重点为英语单词、考研语法。具体任务为: 1.背诵5500大纲单词，第-轮大概花费30天时间,第-遍在单词书上背,后续可以用碎片化时间 在手机上 2.选择一个考研语法网课， 在5月前将课程看- 遍, 并记笔记。 3.做2002-2008年真题阅读部分,把不认识的单词都标记出来，在语境中重复单词会记得更牢。 第二轮（两个月）12.10-2.10- 真题训练（两个月） - 2009-2019共11套真题 - 任务:本阶段重点为英语真题，辅助英语单词背诵。 1.英语真题训练，提前留出2020-2024年的真题作为冲刺阶段考前模拟。剩下年份的真题以周为单 位，保持一周一套英语真题的速度。除大小作文之外都要做. 2.每周一套英语真题，要做到: . ●标记出每一个不认识的单词; ●画咄出长难句句子结构并分析; ●通篇阅读文章感受行文逻辑; ●分析题目理解错误原因,并总结做题技巧; 第三轮（两个月）2.10-4.10- 任务: 1.总结英语大小作文写作框架，背诵优质句子充实作文语料库。 2.完整模拟近5年英语真题(含大小作文) ,严格控制做题时间训练答题速度,在模拟中训练做题 技巧，最后进行查漏补缺。 3.回顾复习近20年真题和选项。 政治","categories":[{"name":"plan","slug":"plan","permalink":"http://example.com/categories/plan/"}],"tags":[]},{"title":"","slug":"culitivate/java技术栈/Linux/Linux","date":"2023-08-02T09:33:51.315Z","updated":"2023-09-20T08:42:18.829Z","comments":true,"path":"2023/08/44c50b79138d.html","link":"","permalink":"http://example.com/2023/08/44c50b79138d.html","excerpt":"","text":"","categories":[{"name":"culitivate","slug":"culitivate","permalink":"http://example.com/categories/culitivate/"},{"name":"java技术栈","slug":"culitivate/java技术栈","permalink":"http://example.com/categories/culitivate/java%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"Linux","slug":"culitivate/java技术栈/Linux","permalink":"http://example.com/categories/culitivate/java%E6%8A%80%E6%9C%AF%E6%A0%88/Linux/"}],"tags":[]},{"title":"","slug":"culitivate/PHP/PHP笔记","date":"2023-08-02T09:31:06.409Z","updated":"2023-09-20T08:42:18.828Z","comments":true,"path":"2023/08/32e240f3738f.html","link":"","permalink":"http://example.com/2023/08/32e240f3738f.html","excerpt":"","text":"弱类型 ==&#x3D;在进行比较的时候，会先判断两种字符串的类型是否相等，再比较=&#x3D;在进行比较的时候，会先将字符串类型转化成相同，再比较 1=&#x3D;=true:false1=&#x3D;ture:true 如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则字符串会被转换成数值并且比较按照数值来进行","categories":[{"name":"culitivate","slug":"culitivate","permalink":"http://example.com/categories/culitivate/"},{"name":"PHP","slug":"culitivate/PHP","permalink":"http://example.com/categories/culitivate/PHP/"}],"tags":[]},{"title":"","slug":"culitivate/other/CTF/CTF笔记","date":"2023-08-02T02:38:51.478Z","updated":"2023-09-20T08:42:18.829Z","comments":true,"path":"2023/08/1b0a1e9c8caf.html","link":"","permalink":"http://example.com/2023/08/1b0a1e9c8caf.html","excerpt":"","text":"学习平台https://www.bilibili.com/video/BV1eq4y1x71H?p=5&amp;vd_source=51ce6b684d2afd4de72a9121533cd3ca\\https://www.bilibili.com/video/BV1eq4y1x71H?p=5&amp;vd_source=51ce6b684d2afd4de72a9121533cd3ca练习平台https://zhuanlan.zhihu.com/p/407953508\\https://zhuanlan.zhihu.com/p/407953508 https://blog.csdn.net/wanzt123/article/details/75174675 https://zhuanlan.zhihu.com/p/393641905 工具Burp Suite·主要功能:1．拦截、查看或者修改网络请求和响应。2.扫描web应用程序的安全漏洞。3．自动化攻击web应用。4．对数据编码和解码。 HackBar浏览器插件帮助测试sql注入，xss漏洞利用 sqlmapsql自动注入工具 webshell管理工具蚁剑：网站管理工具冰蝎：通信过程中使用AES加密哥斯拉：替代工具 安全导航:纳威安全导航: https://navisec.it/安全圈info:https://www.anquanquan.info/渗透师导航:https://www.shentoushi.top/ 日程安排4.1、初期刚刚走进大学，入了web安全的坑，面对诸多漏洞必然是迷茫的，这时的首要任务就是打好网站开发的基础，曾有伟人说过-“自己不会做网站，何谈去找网站的漏洞”，在学习漏洞前，了解基本网站架构、基础网站开发原理，基础的前后端知识，能够让你之后的漏洞学习畅通无阻。 0、协议基础：HTTP、TCP&#x2F;IP1、html+css+js（2-3天）前端三要素 html、css、js是被浏览器解析的代码，是构成静态页面的基础。也是前端漏洞如xss、csrf的基础。 ☆重点了解html和js 推荐学习资料： https://www.runoob.com/ https://www.w3school.com.cn/ 能力要求： 能够写出简单表单，能够通过js获取DOM元素，控制DOM树即可。 2、apache+php （4-5天）推荐使用phpstudy来进行傻瓜式安装，可以少走很多弯路。通过apache+php体会一下网站后端的工作，客户端浏览器通过请求apache服务器上的php脚本，php执行后生成的html页面返回给浏览器进行解析。 ☆重点了解php 推荐学习资料： https://www.runoob.com/ https://www.w3school.com.cn/ 能力要求： 了解基本网站原理，了解php基本语法，开发简单动态页面 3、mysql （2-3天）之前已经安装的phpstudy可以轻易的安装mysql。mysql是一款典型的关系型数据库，一般来说，大部分网站都会带有数据库进行数据存储。 ☆重点了解sql语句 推荐学习资料： https://www.runoob.com/ https://www.w3school.com.cn/ 能力要求： 能够用sql语句实现增删改查，并且能用php+mysql开发一个增删改查的管理系统（如学生管理系统） 4、python (2-3天)虽然 “php是最好的语言”，但它主要还是应用在服务端做网站开发，我们搞安全经常需要写一些脚本或工具来进行诸如密码爆破、目录扫描、攻击自动化等操作，需要一个方便且趁手的编程语言，这里我推荐python ☆重点学习requests、BeautifulSoup、re这三个库 推荐学习资料 https://www.runoob.com/ https://www.w3school.com.cn/ 能力要求： 了解python基础语法，能够用python爬取网站上的信息（requests+BeautifulSoup+re） 5、burpsuite （1-2天）web安全的工具很多，但我觉得必备的渗透工具还得是它 重点学习Proxy、Repeater、Intruder三个模块，分别用于抓包放包、重放包、爆破 初步使用即可，在中期的漏洞学习中去逐渐熟练它 推荐学习资料 DVWA之暴力破解 能力要求： 能够用burpsuite抓包改包、爆破用户名密码 4.2、中期此时我们对网站已经不再陌生，能够自己动手完成一个简单站点。但我们写出来的代码真的安全吗？进入中期，我们便要开始着眼经典漏洞的学习。 一个漏洞的学习，要搞明白三点（每学完一个漏洞就问自己这三个问题）： 如何利用这个漏洞？ 为什么会产生这个漏洞？ 如何修复这个漏洞？ 1、SQL注入（7-8天）我们web狗学习的第一个漏洞一般都是SQL注入，它是web安全经典fg中的经典，也是在这里被灌输 “永远不信任用户的输入” 的口号，即使是现在sql注入也依旧存在，并且它还在不断衍生出如nosql注入、ORM注入等，可谓防不胜防。 推荐学习资料： sqli-labs：如何使用它网上有很多教学，wp也有很多大佬写了 这里贴一个https://blog.csdn.net/wang_624&#x2F;article&#x2F;details&#x2F;101913584 sqlmap：sql注入神器，有余力可以去看看它的源码，学习一下大佬进行sql注入并把它自动化的思路 buuctf：找相关的真题进行练习 wp百度一搜就有 [极客大挑战 2019]EasySQL [极客大挑战 2019]LoveSQL [SUCTF 2019]EasySQL 能力要求： 能够手工注入出任意表的数据，熟悉三种盲注的手法，能够通过sql注入实现任意文件读取和任意文件写入，能够自己编写一个不含sql注入的查询功能 2、文件上传（7-8天）webshell是可以进行代码执行的木马 而文件上传其实就是想办法把webshell上传到目标的服务器上去并成功解析，达到控制目标服务器的目的，这也是web安全的一个重点内容 推荐学习资料 upload-labs：几乎涵盖所有上传漏洞类型 buuctf：找相关的真题进行练习（[ACTF2020 新生赛]Upload） 趁手的webshell管理工具： 蚁剑 能力要求： 会写php的webshell，明白webshell的原理，熟悉常见的文件上传绕过方法（如过后缀检测、过文件头检测、过MIME类型检测），能够自己编写一个不含漏洞的上传功能 3、其他漏洞（14-15天）以上两个漏洞是我认为一个初学者最应该掌握也是最典型的漏洞，涵盖了代码执行、文件操作、数据库操作等web应用的主体内容。然而web安全的世界还有很多的漏洞需要你去探索，不过学会了这两种漏洞的你去学其他漏洞定然是游刃有余，不会像刚开始那么困惑了。 以下四个为中期要掌握的漏洞 命令执行（RCE）：php常见的代码执行（eval）、命令执行（system）函数 文件包含：file协议、php伪协议的利用 XSS：通过XSS获取用户cookie CSRF：通过csrf让用户点击恶意链接就触发敏感操作 4.3、后期此时的你熟悉了web安全几个核心的漏洞，并且有了一些ctf题目的练习经验，已经是一个合格的ctfer了。恭喜你。成功入门web安全。后续的学习方法或许该由你自己决定，我在此只给一些建议。 学习笔记基础知识 (wolai.com) MISC（安全杂项）：全称Miscellaneous。题目涉及流量分析、电子取证、人肉搜索、数据分析、大数据统计等等，覆盖面比较广。我们平时看到的社工类题目；给你一个流量包让你分析的题目；取证分析题目，都属于这类题目。主要考查参赛选手的各种基础综合知识，考察范围比较广。 PPC（编程类）：全称Professionally Program Coder。题目涉及到程序编写、编程算法实现。算法的逆向编写，批量处理等，有时候用编程去处理问题，会方便的多。当然PPC相比ACM来说，还是较为容易的。至于编程语言嘛，推荐使用Python来尝试。这部分主要考察选手的快速编程能力。 CRYPTO（密码学）：全称Cryptography。题目考察各种加解密技术，包括古典加密技术、现代加密技术甚至出题者自创加密技术。实验吧“角斗场”中，这样的题目汇集的最多。这部分主要考查参赛选手密码学相关知识点。 REVERSE（逆向）：全称reverse。题目涉及到软件逆向、破解技术等，要求有较强的反汇编、反编译扎实功底。需要掌握汇编，堆栈、寄存器方面的知识。有好的逻辑思维能力。主要考查参赛选手的逆向分析能力。此类题目也是线下比赛的考察重点。 STEGA（隐写）：全称Steganography。隐写术是我开始接触CTF觉得比较神奇的一类，知道这个东西的时候感觉好神奇啊，黑客们真是聪明。题目的Flag会隐藏到图片、音频、视频等各类数据载体中供参赛选手获取。载体就是图片、音频、视频等，可能是修改了这些载体来隐藏flag，也可能将flag隐藏在这些载体的二进制空白位置。有时候需要你侦探精神足够的强，才能发现。此类题目主要考查参赛选手的对各种隐写工具、隐写算法的熟悉程度。实验吧“角斗场”的隐写题目在我看来是比较全的，以上说到的都有涵盖。新手盆友们可以去了解下。 PWN（溢出）：PWN在黑客俚语中代表着攻破，取得权限，在CTF比赛中它代表着溢出类的题目，其中常见类型溢出漏洞有栈溢出、堆溢出。在CTF比赛中，线上比赛会有，但是比例不会太重，进入线下比赛，逆向和溢出则是战队实力的关键。主要考察参数选手漏洞挖掘和利用能力。 WEB（web类）：WEB应用在今天越来越广泛，也是CTF夺旗竞赛中的主要题型，题目涉及到常见的Web漏洞，诸如注入、XSS、文件包含、代码审计、上传等漏洞。这些题目都不是简单的注入、上传题目，至少会有一层的安全过滤，需要选手想办法绕过。且Web题目是国内比较多也是大家比较喜欢的题目。因为大多数人开始安全都是从web日站开始的。 前置知识1.Linux 基本命令Linux 2.http、TCP&#x2F;IP协议网络协议 3.SQL、PHP、JSPHP笔记 工具学习Burp Suite·主要功能:1．拦截、查看或者修改网络请求和响应。2.扫描web应用程序的安全漏洞。3．自动化攻击web应用。4．对数据编码和解码。 教程：\\https://blog.csdn.net/Forget_liu/article/details/129824815 \\https://blog.csdn.net/YQavenger/article/details/108611357?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1-108611357-blog-129824815.235%5Ev38%5Epc_relevant_sort_base2&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1-108611357-blog-129824815.235%5Ev38%5Epc_relevant_sort_base2&amp;utm_relevant_index=2 \\https://zhuanlan.zhihu.com/p/547973012?utm_id=0应用场景：\\https://blog.51cto.com/u_15127666/4516339 HackBar浏览器插件帮助测试sql注入，xss漏洞利用 sqlmapsql自动注入工具 sqlmap教程：\\https://blog.csdn.net/qq_33530840/article/details/82144515\\https://www.freebuf.com/sectool/164608.html webshell管理工具蚁剑：网站管理工具冰蝎：通信过程中使用AES加密哥斯拉：替代工具查看隐藏文件，网址 dirsearchgit泄露，目录扫描用于发现git泄露教程：\\https://www.cnblogs.com/linfangnan/p/13600490.html 命令：\\http://www.onctf.com/posts/b4763959.html dirsearch发现git泄露githack获取源码activate cc 1GitHack.py http://220.249.52.133:58698/.git/ 进行代码审计 Misc（杂项）解码：\\https://www.codeeeee.com/encrypt/rabbit.html\\https://www.iamwawa.cn/ 正则表达式匹配网站\\https://regexr.com/菜鸟教程：\\https://www.runoob.com/regexp/regexp-tutorial.html 文件操作与隐写图片隐写术工具\\https://blog.csdn.net/m0_62770485/article/details/124231894思路\\https://blog.51cto.com/u_14449312/39023001.winhex看文本2.stegdetect检测\\https://xz.aliyun.com/t/1875 压缩文件处理流量取证技术Crypto（密码学）WEB思路：https://blog.csdn.net/m0_64815693/article/details/126834664\\https://blog.csdn.net/m0_64815693/article/details/126834664 一、SQL注入sqlmap教程：\\https://www.freebuf.com/sectool/164608.html sql注入教程：\\https://www.cnblogs.com/snad/p/17247726.html 123456789101112131415# table 1schemata --&gt; 存储该用户创建的所有数据库的库名schema_name --&gt; 记录数据库库名的字段# table 2tables --&gt; 存储该用户创建的所有数据库的库名和表名table_schema --&gt; 记录数据库库名的字段table_name --&gt; 记录数据库表名的字段# table 3columns --&gt; 存储该用户创建所有数据库的库名、表名和字段名table_schema --&gt; 记录数据库库名的字段table_name --&gt; 记录数据库表名的字段column_name --&gt; 记录表中的字段名的字段 1.联合查询注入CnHongke{8sblmmh65nu1sdki40od3iiud7} 爆库： 1select * from `uu` WHERE flag=&#x27;a&#x27; UNION select 1,2,group_concat(table_name) from information_schema.`TABLES` WHERE table_schema=database() 11&#x27; union select 1,group_concat(table_name) from information_schema.tables where table_schema = &#x27;dvwa&#x27; # 爆表字段： 1select 1,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;user&#x27; 构造payload获取值： 1select group_concat(id),group_concat(username) from user 2.报错注入1.通过updatexml()函数进行报错注入函数解释：UPDATEXML (XML_document, XPath_string, new_value);第一个参数：XML_document是String格式，为XML文档对象的名称第二个参数：XPath_string (Xpath格式的字符串) ，如果不了解Xpath语法，可以在网上查找教程。第三个参数：new_value，String格式，替换查找到的符合条件的数据作用：此函数用来更新选定XML片段的内容，将XML标记的给定片段的单个部分替换为 xml_target 新的XML片段 new_xml ，然后返回更 改的XML。xml_target替换的部分 与xpath_expr 用户提供的XPath表达式匹配。如果未xpath_expr找到表达式匹配 ，或者找到多个匹配项，则该函数返回原始 xml_targetXML片段。 报错原理这里和extractvalue函数一样，当Xpath路径语法错误时，就会报错，报错内容含有错误的路径内容。 约束条件输出字符长度限制为32个字符 ?id&#x3D;1’ and updatexml(1, concat(0x7e, database(),0x7e),1) – a ?id&#x3D;1’ and updatexml(1, concat(0x7e, (select group_concat(table_name) from information_schema.tableswhere table_schema &#x3D; database()), 0x7e), 1) – a ?id&#x3D;1’ and updatexml(1, concat(0x7e, (select group_concat(column_name) frominformation_schema.columns where table_schema &#x3D; database() and table_name &#x3D; ‘users’), 0x7e),1) – a ?id&#x3D;1’ and updatexml(1, concat(0x7e, (select group_concat(username) from users), 0x7e),1) – a?id&#x3D;1’ and updatexml(1, concat(0x7e, (select group_concat(password) from users), 0x7e),1) – a 3.Bool盲注① 判断数据库的长度?id&#x3D;1’ and length(database())&gt;7 – a?id&#x3D;1’ and length(database())&gt;8 – a 回显不同，说明数据库的长度是8个字符① 获取数据库名?id&#x3D;1’ and ascii(substr(select database(),1,1))&#x3D;97 – a ② 判断库里表的个数?id&#x3D;1’ and (select count(table_name) from information_schema.tables where table_schema &#x3D; database()) &gt; 3 – a?id&#x3D;1’ and (select count(table_name) from information_schema.tables where table_schema &#x3D; database()) &gt; 4 – a ③ 获取库里各个表名的长度?id&#x3D;1’ and length(select table_name from information_schema.tables where table_schema&#x3D;database() limit 0, 1)&gt;8 – a③ 获取库里第一个表名中的第一个字符的ASCII值，可以此推断出表名，可借助bp爆破?id&#x3D;1’ and ascii(substr((select table_name from information_schema.tables where table_schema &#x3D;database() limit 0, 1),1,1))&#x3D;101 – a ④ 获取users表里的字段数?id&#x3D;1’ and (select count(column_name) from information_schema.columns where table_schema &#x3D;database() and table_name &#x3D; ‘users’) &#x3D; 3 – a ⑤ 获取各字段(列名)长度?id&#x3D;1’ and length(select column_name from information_schema.columns where table_schema&#x3D;database() and table_name &#x3D; ‘users’ limit 0, 1)&gt;8 – a⑤ 获取字段名称?id&#x3D;1’ and ascii(substr((select column_name from information_schema.columns where table_schema&#x3D;database() and table_name &#x3D; ‘users’ limit 0, 1), 1, 1) )&#x3D;97 – a ⑥ 获取字段值?id&#x3D;1’ and ascii(substr((select username from users limit 0, 1), 1, 1)) &#x3D; 97 – a?id&#x3D;1’ and ascii(substr((select group_concat(username) from users), 1, 1)) &#x3D; 97 – a 4.宽字节（时间）注入?id&#x3D;1’ and if(length(database()) &#x3D; 8, sleep(5), 1) – a 睡了5秒因为没有回显，可在布尔盲注上加上if(布尔盲注语句,sleep(5),1)，通过时间判断对错 主要通过if() 和substr() 和sleep() 5.二次注入第一次过滤了’等特殊字符 但后面更新是没有过滤’等特殊字符 导致更新是二次注入 二、xss（跨站脚本攻击）\\https://www.cnblogs.com/snad/p/17247840.html 1.XSS漏洞类型和利用方法2.绕过“内容安全策略”三、PHP特性攻击1.=&#x3D;与==&#x3D;区别==&#x3D;在进行比较的时候，会先判断两种字符串的类型是否相等，再比较=&#x3D;在进行比较的时候，会先将字符串类型转化成相同，再比较 1=&#x3D;=true:false1=&#x3D;ture:true 如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则字符串会被转换成数值并且比较按照数值来进行字符串与数字转换规则：从遇见的第一位不是数字开始丢弃123admin-&gt;123123a12321-&gt;123 2.MD5验证绕过方法\\https://blog.csdn.net/m0_64815693/article/details/126834664 四、文件上传1.客户端检测绕过方式2.MIME类型检测绕过方式3.文件后缀检测绕过方式4.文件内容检测绕过方式五、文件包含1.文件包含的函数2.读取敏感文件65473.获取服务器权限六、远程命令执行1.PHP等语言常见的系统命令执行函数利用了执行命令函数的参数漏洞mkdir 2.命令拼接方法3.绕过过滤机制七、服务端请求伪造1.SSRF的利用技巧2.SSRF攻击mysql3.SSRF攻击redis八、XML外部实体注入\\https://www.cnblogs.com/wwcdg/p/15913894.html 1.XML基础知识2.绕过过滤机制，实现漏洞利用九、NodeJS1.javaScrip基本语法2.类型污染3.原型链污染十、反序列化1.PHP反序列化漏洞原理2.构造POP链Reverse（逆向工程）PNW（漏洞挖掘与漏洞利用）二进制难","categories":[{"name":"culitivate","slug":"culitivate","permalink":"http://example.com/categories/culitivate/"},{"name":"other","slug":"culitivate/other","permalink":"http://example.com/categories/culitivate/other/"},{"name":"CTF","slug":"culitivate/other/CTF","permalink":"http://example.com/categories/culitivate/other/CTF/"}],"tags":[]},{"title":"","slug":"工具记录/vim/vim","date":"2023-07-15T07:40:13.026Z","updated":"2023-09-20T08:42:18.828Z","comments":true,"path":"2023/07/1a64d2540900.html","link":"","permalink":"http://example.com/2023/07/1a64d2540900.html","excerpt":"","text":"(96条消息) vim使用教程图文教程（零基础超详细）_士别三日wyx的博客-CSDN博客 (106条消息) vim命令大全_万山寒的博客-CSDN博客 vim命令大全1.vim介绍vim编辑器有三种模式：命令模式、编辑模式、末行模式 模式间切换方法：（1）命令模式下，输入:后，进入末行模式（2）末行模式下，按esc慢退、按两次esc快退、或者删除所有命令，可以回到命令模式（3）命令模式下，按下i、a等键，可以计入编辑模式（4）编辑模式下，按下esc，可以回到命令模式 vim打开文件：Vi 使用的选项 说 明vim filename 打开或新建一个文件，并将光标置于第一行的首部vim -r filename 恢复上次 vim 打开时崩溃的文件vim -R filename 把指定的文件以只读方式放入 Vim 编辑器中vim + filename 打开文件，并将光标置于最后一行的首部vi +n filename 打开文件，并将光标置于第 n 行的首部vi +&#x2F;pattern filename 打幵文件，并将光标置于第一个与 pattern 匹配的位置vi -c command filename 在对文件进行编辑前，先执行指定的命令2.命令模式1.光标移动快捷键 功能描述jkhl 基本上下左右gg 光标移动到文档首行G 光标移动到文档尾行^或_ 光标移动到行首第一个非空字符home键或0或者g0 光标移动到行首第一个字符g_ 光标移动到行尾最后一个非空字符end或或者 g 或者g或者g 光标移动到行尾最后一个字符gm 光标移动到当前行中间处b&#x2F;B 光标向前移动一个单词（大写忽略&#x2F;-等等特殊字符）w&#x2F;W 光标向后移动一个单词（大写忽略&#x2F;-等等特殊字符）e&#x2F;E 移到单词结尾（大写忽略&#x2F;-等等特殊字符）ctrl+b或pageUp键 翻屏操作，向上翻ctrl+f或pageDn键 翻屏操作，向下翻数字+G 快速将光标移动到指定行&#96;. 移动到上次编辑处数字+上下方向键 以当前光标为准，向上&#x2F;下移动n行数字+左右方向键 以当前光标为准，向左&#x2F;右移动n个字符H 移动到屏幕顶部M 移动到屏幕中间L 移动到屏幕尾部z+Enter键 当前行在屏幕顶部z+ . 当前行在屏幕中间z+ - 当前行在屏幕底部shift+6 光标移动到行首shift+4 光标移动到行尾- 移动到上一行第一个非空字符+ 移动到下一行第一个非空字符) 向前移动一个句子( 向后移动一个句子} 向前移动一个段落{ 向前移动一个段落count l 移动到count 列counth 向左移动count 字符countl 向右移动count字符countgo 移动到count字符2.选中内容快捷键 功能描述v 进行字符选中V 或shift+v 进行行选中gv 选中上一次选择的内容o 光标移动到选中内容另一处结尾O 光标移动到选中内容另一处角落ctr + V 进行块选中3.复制（配合粘贴命令p使用）快捷键 功能描述y 复制已选中的文本到剪贴板n+yy 复制光标所在行，此命令前可以加数字 n，可复制多行yw 复制光标位置的单词ctrl+v + 方向键+yy ctrl+v，并按方向键选中区块，按下yy复制4.剪切快捷键 功能描述dd 剪切光标所在行数字+dd 以光标所在行为准（包含当前行），向下剪切指定行数D 剪切光标所在行5.粘贴快捷键 功能描述p 将剪贴板中的内容粘贴到光标后P（大写） 将剪贴板中的内容粘贴到光标前6.删除快捷键 功能描述x 删除光标所在位置的字符X(大写) 删除光标前一个字符dd 删除光标所在行，删除之后，下一行上移D 删除光标位置到行尾的内容，删除之后，下一行不上移ndd 删除当前行（包括此行）后 n 行文本dw 移动光标到单词的开头以删除该单词dG 删除光标所在行一直到文件末尾的所有内容:a1,a2d 删除从 a1 行到 a2 行的文本内容7.撤销&#x2F;恢复快捷键 功能描述u 撤销ctrl+r 恢复U(大写) 撤销所有编辑8.字符转换快捷键 功能描述~ 转换大小写u 变成小写U 变成大写9.编辑命令的快捷键快捷键 功能描述↑或ctr + p 上一条命令↓或ctr + n 下一条命令ctr + b 移动到命令行开头ctr + e 移动到命令行结尾ctr + ← 向左一个单词ctr + → 向右一个单词3.末行模式(: xxx命令)1.保存&#x2F;退出文件操作命令 功能描述:wq 保存并退出 Vim 编辑器:wq! 保存并强制退出 Vim 编辑器:q 不保存就退出 Vim 编辑器:q! 不保存，且强制退出 Vim 编辑器:w 保存但是不退出 Vim 编辑器:w! 强制保存文本:w filename 另存到 filename 文件x！ 保存文本，并退出 Vim 编辑器ZZ 直接退出 Vim 编辑器2.查找：“&#x2F;关键词”在查找结果中，用N、n可以切换上下结果；输入nohl，可以取消高亮 快捷键 功能描述&#x2F;abc 从光标所在位置向前查找字符串 abc&#x2F;^abc 查找以 abc 为行首的行&#x2F;abc$ 查找以 abc 为行尾的行?abc 从光标所在位置向后查找字符串 abcn或； 向同一方向重复上次的查找指令N或, 向相反方向重复上次的查找指定3.替换快捷键 功能描述r 替换光标所在位置的字符R 从光标所在位置开始替换字符，其输入内容会覆盖掉后面等长的文本内容，按“Esc”可以结束:s&#x2F;a1&#x2F;a2 替换当前光标所在行第一处符合条件的内容:s&#x2F;a1&#x2F;a2&#x2F;g 替换当前光标所在行所有的 a1 都用 a2 替换:%s&#x2F;a1&#x2F;a2 替换所有行中，第一处符合条件的内容:%s&#x2F;a1&#x2F;a2&#x2F;g 替换所有行中，所有符合条件的内容:n1,n2 s&#x2F;a1&#x2F;a2 将文件中 n1 到 n2 行中第一处 a1 都用 a2 替换:n1,n2 s&#x2F;a1&#x2F;a2&#x2F;g 将文件中 n1 到 n2 行中所有 a1 都用 a2 替换4.行号显示：“: set nu”;行号显示:set nu取消行号显示：:set nonu5.文件切换使用vim打开多个文件后，在末行模式下可以进行切换。 查看当前已经打开的所有文件：:files(%a表示激活状态，#表示上一个打开的文件)切换到指定文件：:open 文件名切换到上一个文(back previous)：:bp切换到下一个文件(back next)：:bn4.编辑模式快捷键 功能描述i 在当前光标所在位置插入，光标后的文本相应向右移动I 在光标所在行的行首插入，行首是该行的第一个非空白字符，相当于光标移动到行首执行 i 命令o 在光标所在行的下插入新的一行。光标停在空行首，等待输入文本O（大写） 在光标所在行的上插入新的一行。光标停在空行的行首，等待输入文本a 在当前光标所在位置之后插入A 在光标所在行的行尾插入，相当于光标移动到行尾再执行 a 命令esc键 退出编辑模式5.扩展1.代码颜色显示：“：syntax on&#x2F;off” 2.vim内置计算器：a.进入编辑模式b.按“ctrl+r，光标变成引号，，输入&#x3D;，光标转到最后一行c.输入需要计算的内容，按下enter后，计算结果回替代上一步中的引号，光标恢复 3.vim的配置a.文件打开时，末行模式下输入的配置为临时配置，关闭文件后配置无效b.修改个人配置文件，可以永久保存个人配置（~&#x2F;.vimrc，如果没有可以自行创建）c.修改全局配置文件，对每个用户生效（vim自带，&#x2F;etc&#x2F;vimrc） 注：个人配置文件优先级更高，当个人配置和全局配置发生冲突时，系统以当前用户的个人配置文件为准 4.异常退出在编辑文件后，未正常保存退出时，会产生异常退出交换文件（.原文件名.swp）将交换文件删除后，再次打开文件时，无提示：“#rm -f .原文件名.swp” 5.别名机制：自定义指令Linux中，存在一个别名映射文件： ~&#x2F;.bashrc修改文件内容，可以自定义指令，重新登录账号后生效 6.文件快捷方式对于深层文件，可以创建文件快捷方式，便于后续操作：#ln -s 源路径 新路径7. 退出方式（1）在vim中退出文件编辑模式，可以使用:q或者:wq（2）建议使用:x：使用效果等同于wq，如果文件有改动则先保存后退出；但是如果文件没有做修改，会直接退出，不会修改文件更新时间，避免用户混淆文件的修改时间————————————————版权声明：本文为CSDN博主「万山寒」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/blood_Z/article/details/125064927","categories":[{"name":"工具记录","slug":"工具记录","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7%E8%AE%B0%E5%BD%95/"},{"name":"vim","slug":"工具记录/vim","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7%E8%AE%B0%E5%BD%95/vim/"}],"tags":[]},{"title":"","slug":"culitivate/java技术栈/git/git","date":"2023-07-15T07:37:27.399Z","updated":"2023-09-20T08:42:18.829Z","comments":true,"path":"2023/07/79a5e1d4887a.html","link":"","permalink":"http://example.com/2023/07/79a5e1d4887a.html","excerpt":"","text":"克隆项目git clone -b branch http…. 上传与本地分支同名并且合并git push 拉取与本地分支同名并且合并git pull 解决冲突git如何处理别人的pull request及解决冲突 - 程序员大本营 (pianshen.com) 教程链接git安装后如何拉取gitee代码-git-PHP中文网 (96条消息) 使用git把项目提交到gitee（命令篇）_如何使用git推送到gitee_Ken_1115的博客-CSDN博客 www.bilibili.com","categories":[{"name":"culitivate","slug":"culitivate","permalink":"http://example.com/categories/culitivate/"},{"name":"java技术栈","slug":"culitivate/java技术栈","permalink":"http://example.com/categories/culitivate/java%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"git","slug":"culitivate/java技术栈/git","permalink":"http://example.com/categories/culitivate/java%E6%8A%80%E6%9C%AF%E6%A0%88/git/"}],"tags":[]},{"title":"","slug":"project/2023暑期项目health/idea","date":"2023-07-11T11:27:48.541Z","updated":"2023-09-20T08:42:18.828Z","comments":true,"path":"2023/07/46d1691adbad.html","link":"","permalink":"http://example.com/2023/07/46d1691adbad.html","excerpt":"","text":"数据库表session表名：session用途：存储用户的openid，以及sessionid 字段 数据类型 约束 描述 id INT PRIMARY KEY id标识 openid VARCHAR(50) NOT NULL 保存用户的唯一openid sessionid VARCHAR(50) NOT NULL userid user表名：user用途：存储用户基本公共信息 字段 数据类型 约束 描述 id INT PRIMARY KEY id标识 userid VARCHAR(50) PRIMARY KEY 用于唯一标识每个用户的ID号，确保每个用户都有一个唯一的标识符 username VARCHAR(50) NOT NULL 用于存储用户的名字或昵称 useravatar VARCHAR(50) DEFAULT 储存用户头像路径（先存在腾讯存储桶中后存储路径） userbirth INT DEFAULT 0 用于记录用户出生年月日 usercountry VARCHAR(50) DEFAULT 北京 用于记录用户所在地区 treecount INT DEFAULT 0 用于记录用户所拥有的树木数量 energycount INT DEFAULT 0 用于记录用户所拥有的能量值，每天更新 trends 字段 数据类型 约束 描述 id INT PRIMARY KEY id标识 userid VARCHAR(50) DEFAULT 用户唯一标识 words VARCHAR(50) DEFAULT 0 动态文本 pictures VARCHAR(50) DEFAULT 0 动态图片 lasttime VARCHAR(50) DEFAULT 0 上传时间 表名：tantrends用途：存储用户的碳排放打卡动态 表名：foodtrends用途：存储用户的光盘打卡动态 表名：rubbishtrends用途：存储用户的垃圾分类打卡动态 food表名：food用途：存储食谱 字段 数据类型 约束 描述 foodname VARCHAR(50) PRIMARY KEY 食物名称 foodpicture VARCHAR(50) DEFAULT 食物图片 foodcalorie INT DEFAULT 0 食物卡路里 task表名：task用途：记录每日打卡任务 字段 数据类型 约束 描述 id INT PRIMARY KEY id标识 energy INT DEFAULT 任务能量值 words VARCHAR(50) DEFAULT 任务描述 answer VARCHAR(50) DEFAULT 0 任务答案:[a,b,c] 任务类型： 问答型 题目+答案 前端请求task表，获取每日打卡任务 用户作答打卡后，记录下用户作答情况:如一共五题，打卡了前三题，则向后端传[1,1,1,0,0]，以及增加的能量值（每打卡一题传一次） usertask表名：usertask用途：记录用户每日打卡任务情况 字段 数据类型 约束 描述 id INT PRIMARY KEY id标识 userid VARCHAR(50) DEFAULT 用户唯一标识 situation VARCHAR(50) DEFAULT 0 打卡情况，每日更新为null,[1,0,1] 后端接口列表登录接口post方法*地址http://47.120.14.52:8081/login参数：code返回值返回user信息以及sessionidsessionid用于校验用户身份 更新用户信息接口post方法地址：http://47.120.14.52:8081/updatauser参数必须参数：sessionid可选参数：username、userarea、useravatar、userdate（日期字符串格式1991-01-01）返回值：更新后的user信息 动态接口上传动态地址：\\http://47.120.14.52:8081/trends/upheader:{“sessionid”,”trendtype”:{“tan”&#x2F;“food”&#x2F;“rubbish”}}raw:{ “username”:”最新name”, “useravatar”:”bb”, “words”:”bc”, “pictures”:[“bd”,”wed”,”wedw”], “lasttime”:”1039-02-02 14:34:54” } 获取动态大厅展示地址:\\http://47.120.14.52:8081/trends/findbypageheader:{“sessionid”,”trendtype”:{“tan”&#x2F;“food”&#x2F;“rubbish”}}raw:{ “page”:1, “size”:2 } 个人仓库动态展示设计思路：在大厅的方法中加入sessionid查询地址:\\http://47.120.14.52:8081/trends/findselfbypageheader:{“sessionid”,”trendtype”:{“tan”&#x2F;“food”&#x2F;“rubbish”}}raw:{ “page”:1, “size”:2 } 删除动态设计思路：只有用户自己可以删除自己的动态先进行用户检查，确保在数据库中将用户sessionid与删除动态的userid对应若一致则删除若不一致，显示无权限删除 地址:\\http://47.120.14.52:8081/trends/rmvheader:{“sessionid”,”trendid”,”trendtype”:{“tan”&#x2F;“food”&#x2F;“rubbish”}} 每日打卡项目提升登录前端传code+appid+appsecret 后端 接收code+appid+appsecret 在接受方法内调用登录凭证校验接口获取appid 新建一张用户表存放appid+sessionid，appid对应userid 框架使用Spring Security 做权限控制，替代拦截器的拦截控制，并使用自己的认证方案替代Security认证流程,使权限认证和控制更加方便灵活。使用Redis的set实现点赞, zset 实现关注，并使用Redis存储登录ticket和验证码，解决分布式session问题。使佣Redis高级数据类型HyperLogLog统计UV(Unique Visitor),使用Bitmap统计DAU (Daily Active User)。使用Kafka处理发送评论、点赞和关注等系统通知，并使用事件进行封装，构建了强大的异步消息系统。使用Elasticsearch做全局搜索，并通过事件封装，增加关键词高亮显示等功能。对热帖排行模块，使用分布式缓存Redis和本地缓存Caffeine作为多级缓存,避免了缓存雪崩，将QPS提升了20倍(10-200)，大大提升了网站访问速度。并使用Quartz定时更新热帖排行。 使用 Kafka 处理发送评论、点赞和关注等系统通知，并使用事件进行封装，构建了强大的异步消息系统。 技术栈: SpringBoot+ SpringCloud+ Redis + Kafka+XXL-Job+Vue.js+其他第三方SDK等●将校内服务与百度地图结合实现信息视觉呈现;采用人脸识别打造安全机制，通过模型训练数据采集提供了智能系统问答服务●对系统慢SQL进行优化，使得系统性能大幅度提高。●用Redis存储登录ticket和验证码，解决分布式session问题●定义热点数据并缓存在Redis,降低了数据库访问压力●将校内服务与百度地图结合实现信息视觉呈现;采用人脸识别打造安全机制，通过模型训练数据采集提供了智能系统问答服务●对热帖排行模块，使用分布式缓存Redis和本地缓存Caffeine作为多级缓存，避免了缓存雪崩，将QPS提升了20倍(10-200)，大大提升了网站访问速度。并使用Quartz定时更新热帖排行●利用JVM指令排查出GC问题，调整JVM配置，降低GC次数使●用Kafka打造强大的异步消息系统version1.0可以公众号后台回复[基于人工智能的智慧校园助手]","categories":[{"name":"project","slug":"project","permalink":"http://example.com/categories/project/"},{"name":"2023暑期项目health","slug":"project/2023暑期项目health","permalink":"http://example.com/categories/project/2023%E6%9A%91%E6%9C%9F%E9%A1%B9%E7%9B%AEhealth/"}],"tags":[]},{"title":"","slug":"culitivate/Python/python","date":"2023-06-18T06:28:53.957Z","updated":"2023-09-20T08:42:18.828Z","comments":true,"path":"2023/06/66d03afcf0b4.html","link":"","permalink":"http://example.com/2023/06/66d03afcf0b4.html","excerpt":"","text":"考试题型满分 100 分，考试题型如下：（1）单选题（40 题，1 分&#x2F;题，共 40 分）（2）多选题（20 题，1 分&#x2F;题，共 20 分）（3）填空题（30 题，1 分&#x2F;题，共 30 分）（4）判断题（10 题，1 分&#x2F;题，共 10 分） 期末复习要点第 1 章 Python 基本使用 计算机编程语言 Python 的特点。 IDLE 的功能，如何调试程序。 变量和常量，赋值语句，单行注释和多行注释。 如何导入模块。 通用函数：input()、print()、len()、int()、eval()等。 专用函数：upper()、lower()等。 第 2 章 基本数据的表示 变量的命名规则与使用，Python 的保留字。 整数、浮点、字符串和布尔型数据，类型的判断及之间的转换。str() float() bool() int() 复数类型的表示，转义符的用法。 各种运算符及其优先级，Python 的书写规则。 不同进制数的表示及转换。 常用函数：type()、chr()、ord()、format()等。 第 3 章 控制语句 表达式的计算，常用运算符，全局变量。 顺序结构、单分支&#x2F;多分支结构、分支嵌套结构的程序设计。 for&#x2F;while 循环结构、多重循环、分支和循环嵌套的程序设计。 循环结构中 else 子句的用法，死循环的概念及中断。 break 和 continue 保留字的功能。 异常处理：基本语句结构，else 和 finally 子句的用法。 常用函数：input()、print()、range()、chr()、ord()、eval()、int()等。 第 4 章 函数与模块 函数的定义和使用（1）使用函数的优点。（2）函数的分类（内置函数和用户自定义函数）。（3）用户自定义函数的格式。 函数参数（1）实参、形参的含义。(当我们调用函数时，需要向函数传递一些参数，这些参数称为实参（arguments），它们是函数调用时传入的具体值。而函数定义时声明的参数称为形参（parameters），它们是函数定义时指定的占位符变量，用于将函数调用时传入的实参接收并进行处理。)（2）函数调用时参数传递有哪些方式（位置传参、默认参数、关键字传参），能通过实例进行判别。（3）可变参数的定义方式（*和**运算符的作用）。( *args 来定义可变参数，表示该函数可以接收任意数量的位置参数。**kwargs 来定义可变参数，表示该函数可以接收任意数量的关键字参数。)（4）return 语句的属性（位置、数量特点）。(return 语句用于结束函数并返回结果，在 Python 中可以出现在函数的任意位置，函数也可以有多个 return 语句，但只有一个执行。如果 return 语句后面没有跟值，或者 return 语句缺失，则函数返回 None。) 变量的作用域（1）全局变量的含义（能通过实例辨别）、特点，声明全局变量的关键字。(声明全局变量的关键字是 global。如果需要在函数内部修改全局变量的值，必须使用 global 关键字来声明该变量是全局变量，否则 Python 将会把它视为函数内部新定义的一个局部变量。)（2）局部变量的含义、特点。 匿名函数和递归函数（1）匿名函数的特征（本质是一个表达式）。（2）定义匿名函数的关键字、格式。(使用 lambda 关键字来创建函数对象,lambda 参数列表: 表达式)（3）递归函数的概念及代码。 内置函数（1）辨别常用的内置函数。（2）常用函数：print()、range()、split()、list()、min()、max()、reverse()、int()、str()、ord()、chr()、eval()、append()、sorted()、input()等。（3）time 库：time()、gmtime()、localtime()、ctime()、mktime()、strftime()、strptime()、perf_counter()、sleep()等。2.计算生态。（1）pip 库。三种安装方式（工具安装、自定义安装、文件安装）。（2）PyInstaller 库。参数：Python 源程序文件名、-F、-i、-D、-clean 的功能。（3）jieba 库。中文分词库，三种分词模式（精确模式 jieba.lcut(s)、全模式 jieba.lcut(s,cut_all&#x3D;True)、搜索引擎模式 jieba.lcut_for_search(s)）。（4）wordcloud 库。创建 WordCloud 对象、generate(text)方法、to_file(filename)方法。（5）NumPy 库的简单使用。numpy.array()函数、numpy.arange()函数。（6）第三方库纵览（只要求了解第三方库的名称及分类） 数据分析：numpy、pandas、scipy 文本处理：beautifulsoup4、pdfminer、python-docx、openpyxl 数据可视化：matplotlib、TVTK、mayavi、seaborn 机器学习：TensorFlow、scikit-learn、Theano、mxnet、PyTorch 网络爬虫：requests、scrapy、grab Web 开发：Django、Pyramid、Flask 图形用户界面：PyQt5、wxPython、PyGTK 游戏开发：Pygame、Panda3D、Cocos2d （7）更多第三方库: PIL：图像处理方面的重要第三方库 SymPy：支持符号计算，是一个全功能的计算机代数系统 NLTK：自然语言处理的第三方库 WeRoBot：微信机器人框架 MyQR：产生基本二维码、艺术二维码、动态效果二维码 Loso：另一种中文分词库 SnowNLP：情感分析 第 6 章 组合数据 组合数据的类型与表示，序列的类型。 序列（含字符串）的索引与切片，列表的复制与引用。 常用函数：list()、range()、len()、max()、format()、sorted()、input()、eval()、type()、chr()、ord()等。 列表函数（方法）：append()、index()、copy()、reverse()、insert()、pop()、clear()等。 字典函数（方法）：keys()、items()、pop()、popitem()、get()、update()等。 第 7 章 数据文件 文件类型：文本和二进制，文本文件的编码（中英文的 UTF-8 编码表示）。 文件指针：文本不同打开方式时指针的位置。 文件打开、读写和关闭。 常用函数和方法：open()、close()、read([size])、readline()、readlines()、write()、writelines()、tell()、seek()等。 目录路径概念，os 模块的 rename()、getcwd()、remove()、mkdir()的作用。 一维数据、二维数据和高维数据的特点、存储方式和表示形式。 采用 CSV 格式对一维和二维数据文件的读写。","categories":[{"name":"culitivate","slug":"culitivate","permalink":"http://example.com/categories/culitivate/"},{"name":"Python","slug":"culitivate/Python","permalink":"http://example.com/categories/culitivate/Python/"}],"tags":[]},{"title":"","slug":"课程笔记/大学语文/大学语文","date":"2023-06-13T09:55:23.137Z","updated":"2023-09-20T08:42:18.828Z","comments":true,"path":"2023/06/2eaba3ee2658.html","link":"","permalink":"http://example.com/2023/06/2eaba3ee2658.html","excerpt":"","text":"道德经 二章原文： 天下皆知美之为美，斯恶已。皆知善之为善，斯不善已。故有无相生，难易相成，长短相形，高下相盈，音声相和，前后相随。恒也。是以圣人处无为之事，行不言之教。万物作焉而弗始。生而弗有，为而弗恃，功成而弗居。夫唯弗居，是以不去。 提示：这一章分为两部分：第一部分，通过“美”、“善”，引申“有无”、“难易”、“长短”、“前后”，说明矛盾的对立与统一，及其相互影响、相互关联、和相互依存的关系；第二部分，要求人们按自然规律办事，不妄为、不过分苛求。 解读： “天下皆知美之为美，斯恶已。”当天下都知道美的时候，那么，丑的观念也就产生了（“恶”，指丑）。 “皆知善之为善，斯不善已。”都知道善的时候，那么，不善的观念也就产生了。 “故有无相生，难易相成，长短相形，高下相盈，音声相和，前后相随。”因此，有无在对立中生成，难易在对立中形成，长短在对立中显现，高下（低）在对立中区分，音（乐）声（音）在对立中和谐，前后在对立中分别。 “恒也。”这是永恒不变的法则。 “是以圣人处无为之事，行不言之教。”所以，圣人用自然的法则——“无为”对待世事，用不言的方式施行教化。 “万物作焉而弗始。”任万物生长不加干预。 “生而弗有，为而弗恃，功成而弗居。”生养万物不据为私有，哺育万物不求报答，成就万物而不居功。 “夫唯弗居，是以不去。”因为其不居功，所以，业绩永存。 （注：“无为”是老子所用的一个特定概念。它指的是按自然规律办事，不是无所作为，而是不妄为。 三章原文： 不尚贤，使民不争；不贵难得之货，使民不为盗；不见可欲，使民心不乱。是以圣人之治也，虚其心，实其腹，弱其志，强其骨。恒使民无知无欲。使夫智者不敢为也。为无为，则无不治矣。 提示： 这一章，讲的是如何治国的问题。在老子看来，要使国家安定，最根本的是要解决好社会矛盾。“尚贤”、“贵难得之货”、“见可欲”，都是容易引起社会动乱的动因。老子认为，解决这一问题最好的办法是“无为”。 解读： “不尚贤，使民不争；不贵难得之货，使民不为盗；不见可欲，使民心不乱。”不去推崇重用那些有才干的能人，民众就不会为此去争名夺利；不贵重那些难得的东西，民众就不会去偷盗；看不到（不显露）可引起贪欲的东西，民众就不会产生欲望。 “是以圣人之治也，虚其心，实其腹，弱其志，强其骨。”所以，圣人的治理方法是：淡化他的心理（欲望），解决他的温饱，减低他的志向，强壮他的身体。 “恒使民无知无欲。”使百姓永远不会去奇思妙想，有过分的欲望。 “使夫智者不敢为也。”使那些有心智的人不敢妄为。 “为无为，则无不治也。”按照“无为”的方法去治理，那么，就没有什么治理不好的 二十二章原文： 曲则全，枉则直，洼则盈，敝则新，少则得，多则惑。是以圣人抱一为天下式。不自见，故明；不自是，故彰；不自伐，故有功；不自矜，故长。夫唯不争，故天下莫能与之争。古之所谓“曲则全”者，岂虚言哉！诚全而归之。 提示： 这一章老子以“正反璧合”的方式，论述矛盾相互转化的辩证关系。以委屈，反而能保全；低凹，反而能积满；少取，反而能有得的道理，说明矛盾的两面性。并提出以“道”，作为观天下的规范。 解读： “曲则全，枉则直，洼则盈，敝则新，少则得，多则惑。”委屈反而能保全，弯曲反而能伸展，低洼之处反而能充盈，破旧反而能产生崭新，少取反而能多得，贪多反而会迷惑。 “是以圣人抱一为天下式。”所以，圣人以“道”作为观察天下的范式。 “不自见，故明；不自是，故彰；不自伐，故有功；不自矜，故长。”不自我显示（表现），反而能显明；不自以为是，反而能显著；不自己夸赞，反而能有功劳；不自我骄傲，反而能长久。 “夫唯不争，故天下莫能与之争。”正因为他不与别人相争，所以天下没有人能与他争。 “古之所谓‘曲则全’者，岂虚言哉！诚全而归之。”古时所说“委屈反而能保全”的话，怎么会是空话呢？它实实在在能够达到。 六十三章原文： 为无为，事无事，味无味。大小，多少，报怨以德。图难于其易，为大于其细。天下难事，必作于易；天下大事，必作于细。是以圣人终不为大，故能成其大。夫轻诺必寡信，多易必多难。是以圣人犹难之，故终无难矣。 提示： 这一章讲的是圣人的处事原则。 解读： “为无为，事无事，味无味。”以“无为”的态度去作为，以“无事”的方式去做事，把恬淡无味当作味。 “大小，多少，报怨以德。”大生于小，多起于小，用恩德去报答别人的仇怨。 “图难于其易，为大于其细。”解决困难的事从它容易的地方入手，做大事要从细小的地方入手。 “天下难事，必作于易；天下大事，必作于细。”天下的难事，必须从容易的地方做起；天下的大事，必须从细微的地方着眼。 “是以圣人终不为大，故能成其大。”因此，圣人不自以为在干大事情，所以，才能做成大事。 “夫轻诺必寡信，多易必多难。”轻易许诺必然很少守信用，把事情看得过分容易必然带来更多的困难。 “是以圣人犹难之，故终无难矣。”因此，圣人尚且把事看得困难，所以，终究没有困难。 七十七章原文： 天之道，其犹张弓欤？高者抑之，下者举之；有余者损之，不足者补之。天之道，损有余而补不足。人之道则不然，损不足而奉有余。孰能有余以奉天下，唯有道者。是以圣人为而不恃，功成而不处，其不欲见贤。 提示： 这一章讲的是“天道”与“人道”的区别。说明“天道”，近“道”；“人道”，远“道”。 解读： “天之道，其犹张弓欤？”指自然的法则，就像拉弓射箭一样。 “高者抑之，下者举之；有余者损之，不足者补之。”偏高就放低一点，偏低就举高一些；拉得过满就放松一点，用力不足就加强一些。 “天之道，损有余而补不足。”自然的法则，是减去过剩补充不足。 “人之道则不然，损不足而奉有余。”人的法则则不是这样，是减去不够供奉给有余。 “孰能有余以奉天下，唯有道者。”谁能把有余的奉献给天下，只有尊循“道”的人。 “是以圣人为而不恃，功成而不处，其不欲见贤。”所以，有“道”的圣人有奉献不自恃有功，有成就而不自居，因为他不愿去表现自己的无私。","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"大学语文","slug":"课程笔记/大学语文","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E5%A4%A7%E5%AD%A6%E8%AF%AD%E6%96%87/"}],"tags":[]},{"title":"","slug":"速记","date":"2023-06-08T12:46:04.841Z","updated":"2023-09-18T10:22:39.933Z","comments":true,"path":"2023/06/a934b4d782e0.html","link":"","permalink":"http://example.com/2023/06/a934b4d782e0.html","excerpt":"","text":"https://zhuanlan.zhihu.com/p/387408041 (108条消息) Windows10 安装 WSL2_windows10 wsl2_一个默默无闻的小程序员的博客-CSDN博客 系统镜像文件https://next.itellyou.cn/Original/Index?id=7ab5f0cb-7607-4bbe-9e88-50716dc43de6#cbp=Product?ID=6f677346-0a09-43fa-b60d-e878ed7625a0 查看环境conda info –envs 激活环境activate envs 退出当前环境deactivate envs 删除环境 1conda remove -n 环境名 --all 创建环境conda create -n envname python&#x3D;versionnumber 教务系统官网\\https://jwxt.nufe.edu.cn/student/login 联网上网登录页 姚的记录 123456789101112131415【南京人力资源和社会保障学会】：报名2023年下半年企业人力资源管理师、劳动关系协调员、企业人力资源管理师（劳务派遣管理员）考试的同志（机构报名的学员由机构统一送交审核材料）请于10月7日—10月17日(周末正常审核)上午9:00-11:30 下午13:30-16:30携带以下资料前往鼓楼区管家桥55号（南京市职业技能培训中心）三楼301教室进行资格审核，通过人员现场缴纳费用（支付宝、现金） 现场审验纸质材料：（初考人员以下1、2、3项需要提供原件及复印件，第4项手工填写，其余项提供打印件即可。补考人员只需携带身份证原件及复印件，现场填写职业技能认定个人登记表。） 1、身份证（或军官证、护照、港澳台通行证。驾驶证和医保卡除外） 2、学历证书（学历证书、学信网学历证书电子注册备案表，电子注册备案表有效期选择6个月。） （1）国内学历：提交全国高等学校学生信息咨询与就业指导中心出具的《中国高等教育学历认证报告》或学信网的电子注册备案表； （2）国内学位：提交教育部学位与研究生教育发展中心出具的《认证报告》或江苏省大学生信息服务中心出具的《江苏省学位证书认证报告》； （3）国（境）外学历学位：提交教育部留学服务中心出具的《国外学历学位认证书》； （4）党校、军校院校取得的学历：提交档案保管部门签章确认的《毕业生登记表》； （5）高中学历：提交毕业证书 （6）在校生（含自考未毕业）：出具学校开具的相关证明 3、现职业证书。（考四级证书的人员无需提供现职业证书） 4、工作年限承诺书（固定模板见申报通知附件3,承诺书填写部分全部手工填写。） 5、申报人员现场填写（职业技能认定个人登记表） 6、请涉及到工作年限的报名人员，需提供相对应的社保缴纳证明 7、证明已完成江苏人社线上平台实名注册认证的截图","categories":[],"tags":[]},{"title":"","slug":"课程笔记/安卓论文/代码备份","date":"2023-06-05T06:23:24.084Z","updated":"2023-09-20T08:42:18.829Z","comments":true,"path":"2023/06/ba95bad06ff4.html","link":"","permalink":"http://example.com/2023/06/ba95bad06ff4.html","excerpt":"","text":"package com.example.test.ui.home; import android.os.Bundle;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.ImageView;import android.widget.TextView; import androidx.annotation.NonNull;import androidx.fragment.app.Fragment;import androidx.lifecycle.ViewModelProvider;import androidx.recyclerview.widget.RecyclerView;import androidx.recyclerview.widget.StaggeredGridLayoutManager; import com.example.test.R;import com.example.test.databinding.FragmentHomeBinding; import java.util.ArrayList;import java.util.List;import java.util.Random; public class HomeFragment extends Fragment { private FragmentHomeBinding binding; private RecyclerView recyclerView; private List&lt;CardData&gt; cardDataList; public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View root = inflater.inflate(R.layout.fragment_home, container, false); // Initialize your data. cardDataList = new ArrayList&lt;&gt;(); cardDataList.add(new CardData(R.drawable.p1, &quot;Text 1&quot;)); cardDataList.add(new CardData(R.drawable.p2, &quot;Text 2&quot;)); cardDataList.add(new CardData(R.drawable.p3, &quot;Text 3&quot;)); cardDataList.add(new CardData(R.drawable.p4, &quot;Text 4&quot;)); recyclerView =root.findViewById(R.id.recyclerView); recyclerView.setLayoutManager(new StaggeredGridLayoutManager(2, StaggeredGridLayoutManager.VERTICAL)); recyclerView.setAdapter(new MyAdapter()); return root; &#125; private class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.MyViewHolder&gt; &#123; private Random random = new Random(); private static final int HEIGHT_TYPE_1_DP = 400; private static final int HEIGHT_TYPE_2_DP = (int)(HEIGHT_TYPE_1_DP * 1.2); @Override public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_card, parent, false); return new MyViewHolder(view); &#125; @Override public void onBindViewHolder(MyViewHolder holder, int position) &#123; // Set your image and text here. // You can use position to get the corresponding data. // holder.imageView.setImageResource(...); // holder.textView.setText(...); CardData cardData = cardDataList.get(position); holder.imageView.setImageResource(cardData.getImageResId()); holder.textView.setText(cardData.getText()); // Set the height of imageView. ViewGroup.LayoutParams layoutParams = holder.imageView.getLayoutParams(); if (position % 2 == 0) &#123; layoutParams.height = dpToPx(HEIGHT_TYPE_2_DP); &#125; else &#123; layoutParams.height = dpToPx(HEIGHT_TYPE_1_DP); &#125; holder.imageView.setLayoutParams(layoutParams); &#125; @Override public int getItemCount() &#123; // Return the total number of items. // You should replace this with your own data. return cardDataList.size(); &#125; private int dpToPx(int dp) &#123; float density = getResources().getDisplayMetrics().density; return (int) (dp * density + 0.5f); &#125; class MyViewHolder extends RecyclerView.ViewHolder &#123; ImageView imageView; TextView textView; MyViewHolder(View view) &#123; super(view); imageView = view.findViewById(R.id.imageView); textView = view.findViewById(R.id.textView); &#125; &#125; &#125; public class CardData &#123; private int imageResId; private String text; public CardData(int imageResId, String text) &#123; this.imageResId = imageResId; this.text = text; &#125; public int getImageResId() &#123; return imageResId; &#125; public String getText() &#123; return text; &#125; &#125; @Override public void onDestroyView() &#123; super.onDestroyView(); binding = null; &#125; } &lt;androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android&#x3D;”http://schemas.android.com/apk/res/android“ xmlns:app&#x3D;”http://schemas.android.com/apk/res-auto“ xmlns:tools&#x3D;”http://schemas.android.com/tools“ android:layout_width&#x3D;”match_parent” android:layout_height&#x3D;”match_parent” tools:context&#x3D;”.ui.home.HomeFragment”&gt; &lt;com.google.android.material.appbar.AppBarLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;ImageView android:id=&quot;@+id/topImageView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;200dp&quot; android:src=&quot;@drawable/p5&quot; android:scaleType=&quot;centerCrop&quot; app:layout_scrollFlags=&quot;scroll|enterAlways|snap&quot; /&gt; &lt;/com.google.android.material.appbar.AppBarLayout&gt; &lt;androidx.recyclerview.widget.RecyclerView android:id=&quot;@+id/recyclerView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_marginTop=&quot;0dp&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot; /&gt; &lt;com.google.android.material.floatingactionbutton.FloatingActionButton android:id=&quot;@+id/scrollToTopButton&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;16dp&quot; android:src=&quot;@drawable/ic_notifications_black_24dp&quot; app:layout_anchor=&quot;@id/recyclerView&quot; app:layout_anchorGravity=&quot;bottom|end&quot; app:layout_behavior=&quot;com.google.android.material.behavior.HideBottomViewOnScrollBehavior&quot; /&gt; &lt;&#x2F;androidx.coordinatorlayout.widget.CoordinatorLayout&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android&#x3D;”http://schemas.android.com/apk/res/android“ xmlns:app&#x3D;”http://schemas.android.com/apk/res-auto“ xmlns:tools&#x3D;”http://schemas.android.com/tools“ android:layout_width&#x3D;”match_parent” android:layout_height&#x3D;”match_parent” tools:context&#x3D;”.ui.home.HomeFragment”&gt; &lt;com.google.android.material.floatingactionbutton.FloatingActionButton android:id=&quot;@+id/scrollToTopButton&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentEnd=&quot;true&quot; android:layout_alignParentBottom=&quot;true&quot; android:layout_margin=&quot;16dp&quot; android:layout_marginEnd=&quot;52dp&quot; android:layout_marginBottom=&quot;144dp&quot; android:src=&quot;@drawable/ic_notifications_black_24dp&quot; app:backgroundTint=&quot;@color/purple_500&quot; app:layout_constraintBottom_toBottomOf=&quot;@+id/recyclerView&quot; app:layout_constraintEnd_toEndOf=&quot;@+id/recyclerView&quot; /&gt; &lt;androidx.recyclerview.widget.RecyclerView android:id=&quot;@+id/recyclerView&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; android:layout_marginBottom=&quot;?attr/actionBarSize&quot; android:layout_marginTop=&quot;150dp&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintHorizontal_bias=&quot;0.0&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintVertical_bias=&quot;1.0&quot; /&gt; &lt;&#x2F;androidx.constraintlayout.widget.ConstraintLayout&gt;","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"安卓论文","slug":"课程笔记/安卓论文","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E5%AE%89%E5%8D%93%E8%AE%BA%E6%96%87/"}],"tags":[]},{"title":"","slug":"课程笔记/数据挖掘/实验报告/实验汇总","date":"2023-06-04T15:42:06.184Z","updated":"2023-09-20T08:42:18.849Z","comments":true,"path":"2023/06/1411b53ef5dd.html","link":"","permalink":"http://example.com/2023/06/1411b53ef5dd.html","excerpt":"","text":"实验一一、实验目的(1) 编写程序，实现数据的预处理，以及检查数据的分布特征。(2) 调用有关模型，检查数据异常值，并且比较与分析模型。(3) 写出实验报告。 二、实验原理(1) 数据预测处理：现实世界中的数据库极易受到噪音数据、遗漏数据和不一致性数据的估计，为提供⾼数据质量进入并提供⾼挖掘结果的质量，产生了大数据预测处理技术。数据预测处理有多种方法：数据清理，数据集合，数据变换，数据归约等。这些数据处理技术在 数据挖掘之前使用，大大提⾼了数据挖掘模型的质量，降低了实际挖掘所需要的时间。 (2) 数据清理：数据清理示例通过填写遗漏的值，平滑噪声数据，识别、删去离群点，并解决不一致于“理”数据。 (3) 检测数据异常值：在数据挖掘的过程中，数据异常值可能会对模型的准确性和稳定性产生负面影响。因此，检测和处理数据中的异常值是数据预处理的重要步骤之一。常见的数据异常值检测方法包括孤立森林（Isolation Forest）、局部异常因子（Local Outlier Factor）和支持向量机（Support Vector Machine）等。这些方法利用数据的统计特性、密度、距离或边界来识别与大多数数据点明显不同的数据点。通过使用这些异常值检测方法，我们可以标识出数据中的异常值，并进行进一步的处理，例如删除异常值、替换为缺失值或使用其他方法进行修正。这样可以提高数据质量，减少异常值对数据挖掘模型的影响，从而获得更准确和可靠的分析结果。 三、实验内容和步骤(1)实验内容 用Python编写程序工具编写程序，实现数据清理、检查数据特征等功能，并在实验报告中写出主要的过程和采用的方法。 通过一些模型来检测数据的异常值 (2)实验步骤 导入库 读取数据 检查缺失值 检查分类数据 4.1查看数据的基本统计描述 4.2绘制交易金额分布柱状图 4.3绘制交易时间与交易量分布图 4.4抽取数据样本观察分布 4.5相关性分析 模型建立与分析 5.1数据准备 5.2模型与分析 5.3模型比较 具体步骤： 1.导入库1234567891011121314151617from warnings import filterwarnings filterwarnings(&#x27;ignore&#x27;)import numpy as np import pandas as pdimport sklearnimport scipyimport matplotlib.pyplot as pltimport seaborn as snsfrom sklearn.metrics import classification_report,accuracy_scorefrom sklearn.ensemble import IsolationForestfrom sklearn.neighbors import LocalOutlierFactorfrom sklearn.svm import OneClassSVMfrom pylab import rcParamsrcParams[&#x27;figure.figsize&#x27;] = 14, 8RANDOM_SEED = 42LABELS = [&quot;Normal&quot;, &quot;Fraud&quot;] 2.读取数据12data = pd.read_csv(&#x27;../Dataset/creditcard.csv&#x27;,sep=&#x27;,&#x27;)data.head() 结果： 3.检查缺失值1data.isnull().values.any() 输出：False说明该数据集中不存在缺失值 粗看数据分类占比 1234567count_classes = pd.value_counts(data[&#x27;Class&#x27;], sort = True)count_classes.plot(kind = &#x27;bar&#x27;, rot=0)LABELS = [&quot;Normal&quot;, &quot;Fraud&quot;]plt.title(&quot;Transaction Class Distribution&quot;)plt.xticks(range(2), LABELS)plt.xlabel(&quot;Class&quot;)plt.ylabel(&quot;Frequency&quot;) 运行结果： 4.检查分类数据4.1查看数据的基本统计描述123fraud = data[data[&#x27;Class&#x27;]==1]normal = data[data[&#x27;Class&#x27;]==0]print(fraud.shape,normal.shape) 输出被诈骗数据以及正常数据的维度：(492, 31) (284315, 31)从中看出正常数据有284315条，而被诈骗数据仅仅有492条。 查看正常数据以及被诈骗数据的基本统计量 1fraud.Amount.describe() 1normal.Amount.describe() &#96; 4.2绘制交易金额分布柱状图按类别列出的每笔交易的金额，据此分别绘制柱状图，观察数据分布。 12345678910111213f, (ax1, ax2) = plt.subplots(2, 1, sharex=True)f.suptitle(&#x27;Amount per transaction by class&#x27;)bins = 50ax1.hist(fraud.Amount, bins = bins)ax1.set_title(&#x27;Fraud&#x27;)ax2.hist(normal.Amount, bins = bins)ax2.set_title(&#x27;Normal&#x27;)plt.xlabel(&#x27;Amount ($)&#x27;)plt.ylabel(&#x27;Number of Transactions&#x27;)plt.xlim((0, 20000))plt.yscale(&#x27;log&#x27;)plt.show(); 4.3绘制交易时间与交易量分布图将检查欺诈交易是否在特定时间段内更频繁发生，用数据可视化——点状图来直观分析。 123456789f, (ax1, ax2) = plt.subplots(2, 1, sharex=True)f.suptitle(&#x27;Time of transaction vs Amount by class&#x27;)ax1.scatter(fraud.Time, fraud.Amount)ax1.set_title(&#x27;Fraud&#x27;)ax2.scatter(normal.Time, normal.Amount)ax2.set_title(&#x27;Normal&#x27;)plt.xlabel(&#x27;Time (in Seconds)&#x27;)plt.ylabel(&#x27;Amount&#x27;)plt.show() 输出的点状图如下： 4.4抽取数据样本观察分布通过在总体数据集中随机抽取一定量(10%)的样本，来观察样本中正常数据与被诈骗数据的分布情况。 1234567891011data1= data.sample(frac = 0.1,random_state=1)data1.shapeFraud = data1[data1[&#x27;Class&#x27;]==1]Valid = data1[data1[&#x27;Class&#x27;]==0]outlier_fraction = len(Fraud)/float(len(Valid))print(outlier_fraction)print(&quot;Fraud Cases : &#123;&#125;&quot;.format(len(Fraud)))print(&quot;Valid Cases : &#123;&#125;&quot;.format(len(Valid))) 输出结果如下：0.0017234102419808666 Fraud Cases : 49 Valid Cases : 28432&#96;得出样本数据中，欺诈交易数量与有效（正常）交易数量之比为0.0017234102419808666。可见欺诈交易占比之小。 4.5相关性分析通过以下代码，获取数据集中每个特征的相关性，并绘制出相关性的图像。 12345import seaborn as snscorrmat = data1.corr()top_corr_features = corrmat.indexplt.figure(figsize=(26,26))g=sns.heatmap(data[top_corr_features].corr(),annot=True,cmap=&quot;RdYlGn&quot;) 图像如下： 5.模型建立与分析5.1数据准备1234567891011columns = data1.columns.tolist()columns = [c for c in columns if c not in [&quot;Class&quot;]]target = &quot;Class&quot;state = np.random.RandomState(42)X = data1[columns]Y = data1[target]X_outliers = state.uniform(low=0, high=1, size=(X.shape[0], X.shape[1]))print(X.shape)print(Y.shape) 5.2模型与分析为了检测数据集中的异常值或离群点，将分别使用以下三个模型进行检测：孤立森林（Isolation Forest）、局部异常因子（Local Outlier Factor）与局部异常因子（Local Outlier Factor） 孤立森林（Isolation Forest）：这是一种基于树的模型，用于异常值检测。它的工作原理是随机选择一个特征，然后随机选择一个分割值，将数据分为两部分。这个过程重复进行，形成了一个“森林”。孤立森林认为那些容易被孤立的点是异常值。 局部异常因子（Local Outlier Factor）：这是一种基于邻近性的方法，用于异常值检测。它比较了一个点和其邻居的局部密度，如果一个点的局部密度远低于其邻居，那么这个点就被认为是异常值。 支持向量机（Support Vector Machine）：这是一种基于边界的方法，用于异常值检测。在这种情况下，它被配置为一个单类支持向量机（One-Class SVM），这意味着它试图找到数据的“正常”边界，然后将那些在边界之外的点视为异常值。 以下是定义了三个模型检测方法的一个字典序列： 1234567classifiers = &#123; &quot;Isolation Forest&quot;:IsolationForest(n_estimators=100, max_samples=len(X), contamination=outlier_fraction,random_state=state, verbose=0), &quot;Local Outlier Factor&quot;:LocalOutlierFactor(n_neighbors=20, algorithm=&#x27;auto&#x27;,leaf_size=30, metric=&#x27;minkowski&#x27;,p=2, metric_params=None, contamination=outlier_fraction), &quot;Support Vector Machine&quot;:OneClassSVM(kernel=&#x27;rbf&#x27;, degree=3, gamma=0.1,nu=0.05,max_iter=-1)&#125; 5.3模型比较将从模型的误差精确度、召回率、f1-score等方面对三个模型进行比较。 1234567891011121314151617181920212223n_outliers = len(Fraud)for i, (clf_name,clf) in enumerate(classifiers.items()): #Fit the data and tag outliers if clf_name == &quot;Local Outlier Factor&quot;: y_pred = clf.fit_predict(X) scores_prediction = clf.negative_outlier_factor_ elif clf_name == &quot;Support Vector Machine&quot;: clf.fit(X) y_pred = clf.predict(X) else: clf.fit(X) scores_prediction = clf.decision_function(X) y_pred = clf.predict(X) #Reshape the prediction values to 0 for Valid transactions , 1 for Fraud transactions y_pred[y_pred == 1] = 0 y_pred[y_pred == -1] = 1 n_errors = (y_pred != Y).sum() # Run Classification Metrics print(&quot;&#123;&#125;: &#123;&#125;&quot;.format(clf_name,n_errors)) print(&quot;Accuracy Score :&quot;) print(accuracy_score(Y,y_pred)) print(&quot;Classification Report :&quot;) print(classification_report(Y,y_pred)) 该代码使用前面定义的三种异常检测方法（孤立森林、局部异常因子、单类支持向量机）来预测数据集中的异常值，并计算每种方法的预测错误数、准确度和分类报告。 结论：在精确度方面，Isolation Forest为99.74%比Local Outlier Factor的99.66%和Support Vector Machine的70.09%都要高。在召回率方面，Isolation Forest模型依然是最优的，其召回率为27%，而Local Outlier Factor的召回率为2%，Support Vector Machine仅为0%。因此，整体上，Isolation Forest在确定欺诈交易方面表现得更好。 四、实验结果首先，通过检查缺失值、检查分类数据等数据预处理步骤，对数据进行一个初步处理与了解。然后，通过模型的建立与分析，对比了三种模型：solation Forest、Local Outlier Factor和Support Vector Machine，在检测异常值方面的优劣。最终，得出loslation Forest模型在确定欺诈交易方面表现得更好。 五、实验分析此次实验，在三个模型上进行了优劣对比，往后可以考虑用更多的模型来进行对比，以此来获得更加切合，表现更为优秀的模型。 实验二一、实验目的(1) 编写程序，实现房价的预测模型的建立。(2) 调用建立的模型，进行未知房价地区的房价预测。(3) 写出实验报告。 二、实验原理(1)数据预处理：对原始数据进行清洗、缺失值处理、特征工程等预处理步骤，以获得可用于建模的数据集。 (2)模型选择和训练：选取多个线性回归模型作为候选模型，例如多元线性回归模型、递归特征消除、交叉验证的递归特征消除等。针对每个模型，使用训练数据集进行模型训练。 (3)模型评估：使用测试数据集评估每个模型的性能，计算评价指标如均方根误差（RMSE）、决定系数（R-squared）等，以衡量模型的预测能力。 (4)模型比较与选择：比较不同模型的性能和特点，考虑各个模型的优缺点，选择最佳的模型作为最终的房价预测模型。 三、实验内容和步骤(1)实验内容 首先，检查数据的完整性，并进行方差分析和韦尔奇T检验等统计检验，以发现数据中的显著性。研究发现，该物业的邮政编码、重建状况、地下室的存在以及物业的状况是影响物业价值的重要因素。 其次，设计了许多功能来增强线性回归建模。一些特征被重新创建为伯努利分布，用作分类数据，例如主浴室的存在。卧室和浴室等普通价值也被平方，以强调多个浴室和卧室对房地产价格的影响。 最后，以统计模型OLS方法为基线，建立了四个线性回归模型。该模型主要基于工程特性。然后，从Scikit Learn库中创建了三个模型：基本线性回归、具有递归特征消除的线性回归以及具有递归特征去除和交叉验证的线性回归。通过系数分析，确定具有递归特征消除的线性回归模型是最稳定的模型，并选择它进行最终实现。 (2)实验步骤 库和数据的导入 探索性数据分析 特征工程（Feature Engineering） 线性回归模型选择 模型导出 预测（模型的使用） 具体步骤： 1.库和数据的导入1234567891011121314151617181920import osimport pandas as pdimport numpy as npimport scipy.stats as statsimport matplotlib.pyplot as pltimport seaborn as snsimport plotly.express as pximport geopandas as gpdimport statsmodels.api as smimport statsmodels.formula.api as smffrom sklearn.model_selection import train_test_splitfrom sklearn.linear_model import LinearRegressionfrom sklearn.feature_selection import RFE, RFECVfrom sklearn import metricsimport pickle%matplotlib inlinepd.options.display.max_columns = 500pd.options.display.max_rows = 500kc_df = pd.read_csv(&quot;../../Dataset/kc_house_data_train.csv&quot;, index_col=0) 2.探索性数据分析为了便于理解，本节将对数据进行可视化，然后对数据中的实证结果进行适当的统计分析。以下是本节中回答的问题的摘要： 哪个街区拥有最有价值的房产？ 房产状况是否会影响价值？ 房产年龄和状况是否相关？ 哪些功能为房子增值？ 翻修会增加房地产价值吗？ 地下室能增加房地产价值吗？ 2.1检查数据完整性检查数据集中是否存在缺失值 1234total_null = 0for null_count in kc_df.isnull().sum(): total_null += null_countprint(f&quot;There are total &#123;total_null&#125; null values in the data&quot;) 输出：here are total 0 null values in the data说明该数据集中不存在缺失值，数据集完整。 由于数据集包含连续值和分类值的混合，许多列包含与基本统计分析无关的分类值，因此选择我们需要的列来分析数据。 12summary_features = [&quot;price&quot;, &quot;yr_built&quot;, &quot;bedrooms&quot;, &quot;bathrooms&quot;, &quot;sqft_living&quot;, &quot;sqft_lot&quot;,&quot;floors&quot;, &quot;condition&quot;, &quot;grade&quot;, &quot;sqft_living15&quot;, &quot;sqft_lot15&quot;]kc_df[summary_features].describe() 截取所需列后的数据概述如下： 2.2列分析-价格-价格有2个数量级的巨大差距。将需要进一步的分析，特别是针对销售日期。-yr_builded-数据集包含从1900年到2015年构建的构建。-间卧室-0间卧室表示单间公寓，大多数住宅包含4间或更少的卧室，并有一些极端的异常值。-浴室-惊讶地发现，有些家庭没有浴室。大多数人似乎至少有一个3&#x2F;4的浴室。-sqft_living-从小公寓到豪宅，居住区也有很大的差异。-sqft_lot-类似于上面的sqft_living。-层-有一半的楼层需要考虑，它们是不跨越房子整体的顶层。-条件-售出的平均房产售价为3.4（可能需要表面修复）。-等级-金县的平均等级为7，这意味着平均房产的销售等级略高于平均等级。-sqft_living15-相邻属性的大小往往相似（与sqft_lving的趋势相似）-sqft_lot15-与上面的sqft_ling15相似 2.3分析哪个街区拥有最高房价？通过邮政编码，对不同街区的房价进行统计分析，获取最高房价的几个街区，以下是具体实现代码： 12345678910111213141516171819202122#property values by zipcode calculationkc_top5_price = kc_df.groupby(&quot;zipcode&quot;)[&quot;price&quot;].mean().sort_values(ascending = False)[:5]kc_mean_price = kc_df.price.mean()#top5 neighborhood label for plotarea_labels = [&quot;Medina&quot;, &quot;Bellevue&quot;, &quot;Mercer Island&quot;, &quot;Madison Park&quot;, &quot;Capitol Hill&quot;]#plotting the dataplt.subplots(figsize=(8,4))sns.barplot(x=kc_top5_price.index, y=kc_top5_price, order=kc_top5_price.index, palette=&quot;Blues_d&quot;) #blue for seahawks!plt.xticks(np.arange(5), area_labels, rotation=75, size=8) #relabel x with list aboveplt.hlines(kc_mean_price, -.5 ,4.5, colors=&quot;darkgoldenrod&quot;, label=&quot;Average Price&quot;) #plot average price horizontal line#prettify graphplt.xlabel(&quot;Neighborhoods&quot;, size=14)plt.ylabel(&quot;Prices ($1mil)&quot;, size=14)plt.title(&quot;Neighborhoods with Highest Property Price&quot;, size=16, y=1.08)plt.legend() #show legend#uncomment line below to export image# plt.savefig(&quot;images/high_price_neighborhood.png&quot;,bbox_inches = &quot;tight&quot;)plt.show(); 房价最高的街区 接着，通过热力型地图，将每个地区平均房价以热力值的形式，直观地表现在地图上，颜色越深代表平均房价越高，以下是具体实现代码： 12345678910111213141516171819202122232425262728293031323334#shapefile data setupking_county = gpd.read_file(&quot;data/zipcode_shape/Zipcodes_for_King_County_and_Surrounding_Area___zipcode_area.shp&quot;)king_county[&quot;zipcode&quot;] = king_county[&quot;ZIP&quot;] #set up column for merge#kc_df price setupzip_price = kc_df.groupby(&quot;zipcode&quot;).price.mean()#plotting data setupzip_plot_df = king_county.join(zip_price, on=&quot;zipcode&quot;, how=&quot;inner&quot;)#plot setupfig, ax = plt.subplots(figsize=(12,6))zip_plot_df.plot(column=&quot;price&quot;, cmap=&quot;YlOrRd&quot;, linewidth=.25, edgecolor=&quot;.25&quot;, ax=ax)#set up colorbarcolor_bar = plt.cm.ScalarMappable(cmap=&quot;YlOrRd&quot;, norm=plt.Normalize(vmin=zip_price.min(), vmax=zip_price.max()))color_bar._A = []cbar = fig.colorbar(color_bar, fraction=0.03, pad=0.02)#set figure limit to zoom in on select neighborhoodsax.set_ylim(47.45, 47.7)ax.set_xlim(-122.35, -122.15)ax.set_xticks([-122.35, -122.15])ax.set_ylabel(&quot;Latitude&quot;, size=12)ax.set_xlabel(&quot;Longitude&quot;, size=12)#labeling few areasax.text(-122.257, 47.62, &#x27;Medina&#x27;)ax.text(-122.2, 47.57, &#x27;Bellevue&#x27;, rotation=-45)ax.text(-122.26, 47.58, &#x27;Mercer Island&#x27;)plt.title(&quot;Average Price per Zipcode Heatmap&quot;, size=14)#uncomment below to save image# plt.savefig(&quot;images/zipcode_price_heatmap.png&quot;,bbox_inches = &quot;tight&quot;)plt.show(); 平均房价的热力型地图： 通过分析每个地区（不同邮政编码）的平均房地产价值，Medina、Belleve、Mercer Island、Madison Park和Capitol Hill地区成为平均房地产价格最高的地区。这些社区的大多数房产是金县平均房产价值的两倍，麦地那的平均房产价值是金县的四倍。似乎是由于靠近华盛顿湖和大型公园，这些房产的价值越来越高。 使用前5个街区的对房地产价格进行方差分析对比前五个排名的邮政编码与平均房价之间的关系，通过ANOVA检验判断是否存在统计上的显著差异，并进行相应的输出。 12345678910alpha = 0.05#ANOVA Test Setupkc_top5 = kc_df[kc_df.zipcode.isin(kc_top5_price.index)]formula = &#x27;price~C(zipcode)&#x27;lm_top5 = smf.ols(formula, kc_top5).fit()anova_top5_table = sm.stats.anova_lm(lm_top5, typ=2)if anova_top5_table[&quot;PR(&gt;F)&quot;][0] &lt; alpha: print(&quot;Top 5 ranked zipcode have a statistically significant impact on average property value&quot;) print(&quot;Zipcdoe ANOVA F-statisic Probability: &quot;, anova_top5_table[&quot;PR(&gt;F)&quot;][0]) 输出：Top 5 ranked zipcode have a statistically significant impact on average property value Zipcdoe ANOVA F-statisic Probability: 1.2515560223110402e-19 2.4分析房产状况是否会影响价值？通过以下代码可视化不同房屋条件评分下的平均房价和中位数房价，并对比平均房价和中位数房价之间的差异。 123456789101112131415161718192021222324252627282930313233343536373839404142#-------------------Conditions Calculation--------------------------------#condition_mean = kc_df.groupby(&quot;condition&quot;)[&quot;price&quot;].mean()condition_median = kc_df.groupby(&quot;condition&quot;)[&quot;price&quot;].median()condition_score = np.arange(1,6)#--------------------------Bar Plots--------------------------------------##set subplot datafig, ax = plt.subplots(figsize=(8,4))ax2 = ax.twinx() #set ax2 on same x axis as axax3 = ax.twinx() #same as above, for hlinewidth = 0.5#barplots ax.bar(x=condition_score, height=condition_median, width=width, label=&quot;Median Price&quot;, color=&quot;midnightblue&quot;, alpha=0.8)ax2.bar(x=condition_score, height=condition_mean, width=width, label=&quot;Mean Price&quot;, color=&quot;royalblue&quot;, alpha=0.8)#horizontal line for mean priceax3.hlines(kc_mean_price, .7 ,5.3, colors=&quot;red&quot;, label=&quot;Average Price&quot;)#set ylimit to the same scale and display only 1ax.set_ylim(0,1.2*condition_mean.max())ax2.set_ylim(0,1.2*condition_mean.max())ax3.set_ylim(0,1.2*condition_mean.max())ax2.yaxis.set_visible(False) #hide the 2nd axisax3.yaxis.set_visible(False)#set legend positionsax.legend(bbox_to_anchor=(0,0,1,1), loc=&quot;upper left&quot;)ax2.legend(bbox_to_anchor=(0,-.1,1,1), loc=&quot;upper left&quot;)ax3.legend(bbox_to_anchor=(0,0,1,1), loc=&quot;upper right&quot;)#prettify graphax.set_ylabel(&quot;Average Prices ($)&quot;, size=14)ax.set_xlabel(&quot;Condition Score&quot;, size=14)plt.title(&quot;Average Property Value per Condition&quot;, size=16, y=1.08)#uncomment line below to export image# plt.savefig(&quot;images/condition_value.png&quot;,bbox_inches = &quot;tight&quot;)plt.legend()plt.show(); 输出图片如下： 物业条件统计分析𝛼 &#x3D; 0.05Null-Hypothesis：不同条件下的平均财产价值没有显著差异。Alternative Hypothesis：不同条件下的平均财产价值有显著差异。 123456789alpha = 0.05 #ANOVA Test Setupformula = &#x27;price~C(condition)&#x27;lm_condition = smf.ols(formula, kc_df).fit()anova_condition = sm.stats.anova_lm(lm_condition, typ=2)if anova_condition[&quot;PR(&gt;F)&quot;][0] &lt; alpha: print(&quot;The property condition have a statistically significant impact on average property value&quot;) print(&quot;Conditions F-statisic Probability: &quot;, anova_condition[&quot;PR(&gt;F)&quot;][0]) 输出如下：The property condition have a statistically significant impact on average property value Conditions F-statisic Probability: 6.813536869407728e-24 结论：房产条件对房地产的价格有重大影响。随着情况的恶化，平均房价和中值房价都呈上升趋势。 2.5房产的特点和升级（哪些功能为房子增值）本部分将对有&#x3D;&#x3D;地下室的房子会为房产增值吗？&#x3D;&#x3D;以及&#x3D;&#x3D;翻新是否会增加房产的价值？&#x3D;&#x3D;两个问题进行分析。通过将数据集分类成[有地下室，无地下室]以及[翻新、未翻新]继续平均房价的柱状图绘制，来直观得出上述问题的答案。以下是具体实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142#--------------------------Property Feature Calculation---------------------------------------#basement = kc_df[(kc_df[&quot;sqft_basement&quot;] &gt; 0)]basement_mean = basement.price.mean()no_basement = kc_df[(kc_df[&quot;sqft_basement&quot;] == 0)]no_basement_mean = no_basement.price.mean()#mean values to plotrenovated = kc_df[(kc_df[&quot;yr_renovated&quot;] &gt; 0)]renovated_mean = renovated.price.mean()not_renovated = kc_df[(kc_df[&quot;yr_renovated&quot;] == 0)]not_renovated_mean = not_renovated.price.mean()#prepare plot labelslabel_basement = [&quot;Basement&quot;, &quot;No basement&quot;]values_basement = [basement_mean, no_basement_mean]label_renovation = [&quot;Renovated&quot;, &quot;No Renovation&quot;]values_renovation = [renovated_mean, not_renovated_mean]#--------------------------Bar Plots--------------------------------------#fig, ax = plt.subplots(1, 2, figsize=(14,4))sns.barplot(ax=ax[0], x=label_basement, y=values_basement, palette=&quot;Blues_r&quot;)sns.barplot(ax=ax[1], x=label_renovation, y=values_renovation, palette=&quot;Blues_r&quot;)ax[0].hlines(kc_mean_price, -.5 ,1.5, colors=&quot;coral&quot;, label=&quot;Average Price&quot;) #plot average price horizontal lineax[1].hlines(kc_mean_price, -.5 ,1.5, colors=&quot;coral&quot;, label=&quot;Average Price&quot;) #plot average price horizontal line#prettify graphax[0].set_ylabel(&quot;Average Prices ($)&quot;, size=12)ax[0].set_title(&quot;Average Property Value&quot;, size=14)ax[0].set_ylim(0,1.1*renovated_mean)ax[0].legend()ax[1].set_ylabel(&quot;Average Prices ($)&quot;, size=12)ax[1].set_title(&quot;Average Property Value&quot;, size=14)ax[1].set_ylim(0,1.1*renovated_mean)ax[1].legend()plt.suptitle(&quot;Affect of Basement and Renovation on Property Value&quot;, size=16, y=1.02)#uncomment below to export image# plt.savefig(&quot;images/basement_renovation_value.png&quot;,bbox_inches = &quot;tight&quot;)plt.show(); 结果图： 房产特征统计分析$\\alpha$&#x3D;0.05地下室Null-Hypothesis：有地下室和没有地下室的房产之间的平均房产价值没有显著差异Alternative Hypothesis：有或没有地下室的房产的平均房产价值有显著差异。 翻新Null-Hypothesis：翻新或未翻新的房产的平均房产价值没有显著差异。Alternative Hypothesis：翻新或未翻新的房产之间的平均房产价值有显著差异。 123456789101112alpha = 0.05basement_p_val = stats.ttest_ind(basement.price, no_basement.price, equal_var=False)[1]print(&quot;Basement vs No Basement T-test P Value: &quot;, basement_p_val)if basement_p_val &lt; alpha: print(&quot;The P value is less than alpha, reject null-hypothesis&quot;)print(&quot;\\n&quot;) #white space for formatting outputrenovation_p_val = stats.ttest_ind(renovated.price, not_renovated.price, equal_var=False)[1]print(&quot;Renovated vs Not Renovated T-test P Value: &quot;, renovation_p_val)if renovation_p_val &lt; alpha: print(&quot;The P value is less than alpha, reject null-hypothesis&quot;) 输出如下：Basement vs No Basement T-test P Value: 1.935598808013724e-102 The P value is less than alpha, reject null-hypothesis Renovated vs Not Renovated T-test P Value: 6.478917377975333e-20 The P value is less than alpha, reject null-hypothesis 结论：地下室和翻新都为房产增加了显著的价值，翻新对房产价值的平均影响更大。 2.6探索性数据分析总结 哪个街区拥有最有价值的房产？-金县的麦地那、贝尔韦、默瑟岛、麦迪逊公园和国会山社区的平均房地产价值最高。这些地区的房地产价值与金县的平均房地产价值在统计上存在显著差异。 房产状况是否会影响价值？-房地产条件对房地产价值有统计学上的显著影响。然而，条件4&#x2F;5的平均值小于条件3&#x2F;5的平均值。这可能是由于其他因素造成的，如公寓&#x2F;合作公寓，其每栋房产的价格可能较低，但往往比私人住宅维护得更好。 哪些功能为房子增值？-翻新后的房产比未翻新的房产具有更高的价值。-基准面为特性添加了重要的值。 3.特征工程（Feature Engineering）Feature Engineering（特征工程）是指在机器学习中对原始数据中的属性进行提取、转换、选择和创建新特征的过程。它是机器学习中至关重要的一步，可以显著影响模型的性能和准确度。 在特征工程中，我们通过对原始数据进行处理和转换，提取出更具信息量和表达能力的特征，以便更好地描述数据的特性和模式。这可以通过以下几种方式实现： 特征提取（Feature Extraction）：从原始数据中提取有用的特征。例如，从文本数据中提取词袋模型、TF-IDF值或词嵌入向量作为特征；从图像数据中提取边缘、纹理或颜色直方图作为特征。 特征转换（Feature Transformation）：对原始特征进行转换或降维。例如，通过主成分分析（PCA）将高维数据转换为低维表示；使用多项式特征转换将原始特征转化为更高阶的多项式特征。 特征选择（Feature Selection）：选择对目标变量预测有重要影响的特征，剔除对模型无关的特征。这可以通过统计方法（如方差阈值、相关系数等）或基于模型的方法（如L1正则化、决策树特征重要性等）来实现。 特征创造（Feature Creation）：通过组合、衍生或生成新的特征来增强原始特征的表达能力。例如，将时间数据分解为年、月、日等组成部分；通过数值间的计算（如差值、比值）来创建新的特征。 通过精心进行特征工程，可以使模型更好地捕捉数据中的模式和规律，提高模型的准确性、鲁棒性和泛化能力。因此，特征工程是机器学习中非常重要和常用的技术之一。 功能检查在进行工程设计之前，所有功能都应该是浮点或整数。在添加到Sklearn线性回归训练之前，日期、id和价格列将被删除。 1kc_df.head() 输出结果： 翻新由于翻新对物业价值有重大影响，因此可以将此功能更新为分类功能 1kc_df[&quot;renovated&quot;] = kc_df.yr_renovated.apply(lambda x: 1 if x &gt; 0 else 0) 翻新年限翻新价值可能会随着年限而贬值，因此此功能可能会提供负相关功能 1kc_df[&quot;renovation_age&quot;] = kc_df.yr_renovated.apply(lambda x: 2020-x if x &gt; 0 else 0) 地下室创建”Basement”特征与进行装修类似。由于拥有地下室可以自动增加房产的价值，因此将其作为二元分类特征可以更好地引导模型。 1kc_df[&quot;basement&quot;] = kc_df.sqft_basement.apply(lambda x: 1 if x != 0 else 0) 主浴室拥有2个或更多浴室的房产很可能包含一个主卫生间，而对许多买家来说，主卫生间是非常理想的。虽然拥有2个浴室并不保证房产有一个主卫生间，但鉴于浴室与房价高度相关且与其他特征存在多重共线性，它可能是进行特征工程的一个好的候选。 1kc_df[&quot;master_bathroom&quot;] = kc_df.bathrooms.apply(lambda x: 1 if x &gt; 2 else 0) 家庭住宅“Family House”特征的创建与上面的”Master Bathroom”特征类似，旨在引导模型将房产区分为公寓和独立房屋。这并不是一个完美的实现，但它是一个简单的方式来区分小型公寓，例如工作室式公寓。 1kc_df[&quot;family_house&quot;] = kc_df.bedrooms.apply(lambda x: 1 if x &gt; 2 else 0) 销售年份和销售季度“Sold Year”和”Sold Quarter”特征的创建是基于原始日期列的处理。由于日期列的数据类型为字符串，为了将其处理为整数类型，将其拆分为年份和年度季度。 12kc_df[&quot;sale_year&quot;] = kc_df.date.apply(lambda x: int(x[:4])) #convert first 4 character, year, into intkc_df[&quot;sale_quarter&quot;] = kc_df.date.apply(lambda x: int(x[4:6])//3.1 + 1) #fancy math convert month, 4-5 index, to quarters in int 邮政编码伪变量“Zipcode Dummy Variables”是指将邮政编码作为虚拟变量来表示。由于邮政编码不是一种有序值，将其作为虚拟变量可以更好地表示其在模型中的影响。 12ziplist = pd.Series(kc_df[&quot;zipcode&quot;]) #make dummy columnskc_df = kc_df.merge(pd.get_dummies(ziplist), left_index=True, right_index=True) #merge dummy columns 方形卧室和浴室。“Squared Bedrooms”和”Squared Bathrooms”特征的创建是为了增强它们与价格之间的相关性。由于卧室数量和浴室数量与房价高度相关，通过对它们的值进行平方操作，可以增加它们在线性模型中的影响力。这将减少0和1对线性模型的影响。 12kc_df[&quot;bedroom_squared&quot;] = kc_df[&quot;bedrooms&quot;] ** 2kc_df[&quot;bathroom_squared&quot;] = kc_df[&quot;bathrooms&quot;] ** 2 4.线性回归模型选择4.1训练以及测试数据集概述：在该步骤中准备训练集以及测试集，将原始数据集划分为训练集和测试集，并确保两者之间的数据是相互独立的、没有重叠的。具体代码： 1234features = [col for col in kc_df.columns if col not in [&quot;id&quot;, &quot;date&quot;, &quot;price&quot;] ] #remove id, date, and price column from featureslr_kc_df = kc_df[features] #set train/test data using feature abovemodel_target = kc_df[&quot;price&quot;] #target column is the price columnx_train, x_test, y_train, y_test = train_test_split(lr_kc_df, model_target ,test_size=0.2) 4.2多元线性回归模型概述：该模型将作为所有其他模型的基线比较。该模型利用了一些基本特征和经过特征工程处理的特征。调整后的R-squared值为0.738，这意味着模型可以解释因变量约73.8%的变异程度。较高的R-squared值表示模型对数据的拟合较好，但并不代表模型一定是最佳模型，因为R-squared无法告诉我们关于模型中其他因素。 代码解析：使用statsmodels库中的ols函数来拟合一个多元线性回归模型，并计算模型在训练集上的预测结果和均方根误差（RMSE）。在这段代码中，定义了一个包含多个自变量的回归模型，其中自变量包括’sqft_living’（居住面积）、’C(zipcode)’（邮政编码，使用了虚拟变量表示）、’condition’（房屋条件）、’renovation_age’（翻新年龄）、’sale_year’（售出年份，使用了虚拟变量表示）、’C(sale_quarter)’（销售季度，使用了虚拟变量表示）、’C(basement)’（地下室，使用了虚拟变量表示）、’bedroom_squared’（卧室数量的平方）和’bathroom_squared’（浴室数量的平方）。 接下来，使用这个模型在训练集上进行预测，并计算了预测结果与实际值之间的均方根误差（RMSE）。 最后调用kc_ols.summary()来获取模型的详细统计结果。该方法会输出模型的摘要信息，包括回归系数、标准误差、t统计量、p值等。通过查看这些统计结果，以此了解模型的拟合效果、各个自变量的显著性以及模型的解释能力等信息。 具体代码如下： 1234567eq = &quot;price~sqft_living+C(zipcode)+condition+renovation_age+sale_year+C(sale_quarter)+C(basement)+bedroom_squared+bathroom_squared&quot;kc_ols = smf.ols(formula=eq, data=kc_df).fit()# uncomment below for summary of the ols model# print(kc_ols.summary())ols_result = kc_ols.predict(x_train)ols_rmse = np.sqrt(metrics.mean_squared_error(y_train, ols_result))kc_ols.summary() 部分输出结果： 4.3Scikit-learn库中的线性回归模型概述：使用Scikit-learn库中的线性回归模型，可以建立一个基本的线性回归模型，使用数据集中的所有特征进行训练和预测。 代码解析：首先使用Scikit-learn库中的LinearRegression()函数创建一个线性回归模型lm_kc，并使用训练数据x_train和对应的目标变量y_train进行了模型的训练。 接下来，使用训练好的模型对训练数据x_test进行预测，得到了预测值y_train_prediction。 然后，通过计算均方根误差（RMSE）来评估模型在测试数据上的性能。RMSE是衡量模型预测误差的指标，表示预测值与实际值之间的平均差异。 最后，使用list(zip(lr_kc_df.columns, lm_kc.coef_))这一行代码来查看模型的系数。通过这行代码，可以得到一个由特征列名和对应的系数值组成的列表，用于查看模型对各个特征的权重影响。 具体代码如下： 12345678910#fit modellm_kc = LinearRegression().fit(x_train, y_train)#training data predictiony_train_prediction = lm_kc.predict(x_test)#rmsetrain_rmse = np.sqrt(metrics.mean_squared_error(y_test, y_train_prediction))#coeffeicient checkinglist(zip(lr_kc_df.columns,lm_kc.coef_)) 输出结果：总结：根据上述信息，可以看出这个模型在预测中高度依赖房产的邮政编码，同时减少了卧室数量、浴室数量和居住面积等房产的其他方面对房价的影响。在实际应用中，这种影响效果可能非常明显，导致该模型预测大多数房产的价格为负数。 4.4递归特征消除概述：使用递归特征消除（Recursive Feature Elimination）方法来消除不必要的特征。通过这个方法，线性回归模型在每一次迭代中会剔除对模型预测性能贡献较小的特征。理论上，这个方法应该能够提供更准确的模型。 代码解析：使用递归特征消除（RFE）方法来对特征进行排名和选择。 首先，使用RFE函数创建一个RFE对象，其中指定估计器（estimator）为线性回归模型（LinearRegression()），并设置步长（step）为1。然后，使用x_train和y_train作为训练数据来拟合RFE模型。 接下来，通过将特征名称和对应的特征排名组成的数据框（kc_rfe_ranking）打印出来，可以可视化特征的排名情况。数据框中的”Model Features”列包含特征的名称，”Feature Ranking”列包含每个特征的排名。 具体代码如下： 1234567kc_rfe = RFE(estimator=LinearRegression(), step=1)kc_rfe = kc_rfe.fit(x_train, y_train)# Run this cell to visualize how the feature are rankedkc_rfe_ranking = pd.DataFrame(&#123;&quot;Model Features&quot;:x_train.columns, &quot;Feature Ranking&quot;:kc_rfe.ranking_&#125;)rank_check = kc_rfe_ranking.sort_values(by=&quot;Feature Ranking&quot;)print(rank_check) 输出结果： 代码解析：首先使用RFE对象的transform方法将训练数据x_train进行特征选择，得到经过特征选择后的训练数据x_train_rfe和测试数据x_test_rfe。 接下来，使用经过特征选择后的训练数据x_train_rfe和对应的目标变量y_train，创建一个新的线性回归模型lm_kc_rfe，并进行模型的训练。 然后，使用训练好的模型lm_kc_rfe对测试数据x_test_rfe进行预测，得到了预测值y_train_prediction_rfe。 最后，通过计算均方根误差（RMSE）来评估经过特征选择后模型在测试数据上的性能。使用np.sqrt(metrics.mean_squared_error(y_test, y_train_prediction_rfe))计算了模型在测试数据上的均方根误差。 lm_kc_rfe.coef_这一行代码输出了经过特征选择后的线性回归模型lm_kc_rfe的系数。通过这个系数，可以查看经过特征选择后，每个特征对于模型的影响程度。 具体代码如下： 123456789101112x_train_rfe = kc_rfe.transform(x_train)x_test_rfe = kc_rfe.transform(x_test)#fit modellm_kc_rfe = LinearRegression().fit(x_train_rfe, y_train)#training data predictiony_train_prediction_rfe = lm_kc_rfe.predict(x_test_rfe)#rmsetrain_rmse_rfe = np.sqrt(metrics.mean_squared_error(y_test, y_train_prediction_rfe))lm_kc_rfe.coef_ 输出结果：总结：可以看出经过递归特征消除交叉验证（RFECV）的模型系数异常地高。这些系数无法与特征名称轻松对应，但是大多数特征的单位变化会导致数百万甚至数千万美元的价格变化。这也解释了在数据集稍微变化时，该模型的不稳定行为。总结来说，可以预测这个模型是高度不现实的。 4.5交叉验证的递归特征消除概述：通过使用交叉验证的方式进行特征选择，这个模型会花费更多的时间来完成。理论上，这个模型应该是最准确的模型，但实际结果显示，这个模型在某些情况下虽然准确，但也表现不稳定。这种不稳定的行为可以通过下面的模型系数来解释。 代码解析：首先创建一个RFECV对象kc_rfecv，其中指定估计器（estimator）为线性回归模型（LinearRegression()），步长（step）为1，交叉验证的折数（cv）为5，评估指标（scoring）为负的均方根误差（neg_root_mean_squared_error），并使用所有可用的处理器（n_jobs&#x3D;-1）进行并行计算。然后，使用x_train和y_train作为训练数据来拟合RFECV模型。 接下来，使用RFECV对象的transform方法将训练数据x_train进行特征选择，得到经过特征选择后的训练数据x_train_rfecv和测试数据x_test_rfecv。 然后，使用经过特征选择后的训练数据x_train_rfecv和对应的目标变量y_train，创建一个新的线性回归模型lm_kc_rfecv，并进行模型的训练。 然后，使用训练好的模型lm_kc_rfecv对测试数据x_test_rfecv进行预测，得到了预测值y_train_prediction_rfecv。 最后，通过计算均方根误差（RMSE）来评估经过特征选择后模型在测试数据上的性能。使用np.sqrt(metrics.mean_squared_error(y_test, y_train_prediction_rfecv))计算了模型在测试数据上的均方根误差。 具体代码如下： 1234567891011121314151617kc_rfecv = RFECV(estimator=LinearRegression(), step=1, cv=5, scoring=&quot;neg_root_mean_squared_error&quot;, n_jobs=-1)kc_rfecv = kc_rfecv.fit(x_train, y_train)x_train_rfecv = kc_rfecv.transform(x_train)x_test_rfecv = kc_rfecv.transform(x_test)#fit modellm_kc_rfecv = LinearRegression().fit(x_train_rfecv, y_train)#training data predictiony_train_prediction_rfecv = lm_kc_rfecv.predict(x_test_rfecv)#rmsetrain_rmse_rfecv = np.sqrt(metrics.mean_squared_error(y_test, y_train_prediction_rfecv))lm_kc_rfecv.coef_ 输出结果： 总结：RFECV模型的系数看起来异常地高。这些系数无法与特征名称轻松对应，但大多数特征的单位变化会导致数百万甚至数千万美元的价格变化。这也解释了在数据集稍微变化时，该模型的不稳定行为。总结来说，可以预测这个模型也是高度不现实的。 4.6模型对比与选择通过以下代码，输出上述不同模型在训练数据上的均方根误差。通过这些误差，可以比较不同模型的性能，了解它们在训练数据上的预测精度。较低的均方根误差表示模型的预测结果与实际值之间的误差较小，预测性能较好。 1234567891011121314print(&quot;OLS Model Errors&quot;)print(&quot;Root Mean Squared Error:&quot;, ols_rmse)print(&quot;\\n&quot;)print(&quot;Basic Linear Regression Model Errors&quot;)print(&quot;Root Mean Squared Error:&quot;, train_rmse)print(&quot;\\n&quot;)print(&quot;Linear Regression Model with Recursive Feature Elimination Errors&quot;)print(&#x27;Root Mean Squared Error:&#x27; , train_rmse_rfe)print(&quot;\\n&quot;)print(&quot;Linear Regression Model with Recursive Feature Elimination with Cross Validation Errors&quot;)print(&quot;Root Mean Squared Error:&quot; , train_rmse_rfecv) 输出结果：OLS Model Errors Root Mean Squared Error: 189818.9783572206 Basic Linear Regression Model Errors Root Mean Squared Error: 157757.42505386463 Linear Regression Model with Recursive Feature Elimination Errors Root Mean Squared Error: 206293.18835843043 Linear Regression Model with Recursive Feature Elimination with Cross Validation Errors Root Mean Squared Error: 158517.33695024686 结论：综上，Basic Linear Regression model的均方根误差在所有模型中最低。然而，RMSE并不是模型的全貌。当对各模型的系数进行分析时，观察到以下情况：-基本线性模型在负预测中出现偏斜-RFE线性模型系数表现出最佳平衡。-RFECV线性模型系数异常高，大多数都高于目标值。因此，选择RFE线性回归模型作为最终模型。 5.模型导出1234567with open(&quot;models/regression_model_rfe.pickle&quot;, &quot;wb&quot;) as model: pickle.dump(lm_kc_rfe, model)with open(&quot;models/transform_rfe.pickle&quot;, &quot;wb&quot;) as transform: pickle.dump(kc_rfe, transform)ziplist.to_csv(&quot;data/zipcod_dummy.csv&quot;) 6.预测（模型的使用）6.1导入库1234567import osimport pandas as pdimport numpy as npimport picklepd.options.display.max_columns = 500pd.options.display.max_rows = 500 6.2导入测试集123kc_import_df = pd.read_csv(&quot;data/kc_house_data_test_features.csv&quot;, index_col=0)kc_test_df = kc_import_df #this is done not to adulterate the original filekc_test_df.head() 部分测试集： 6.3 邮政编码伪变量导入注意：导入的数据集应与线性模型相匹配 123ziplist = pd.read_csv(&quot;data/zipcod_dummy.csv&quot;, index_col=0)ziplist = ziplist.zipcodeziplist.head() 输出结果： 6.4特征工程相当于3.特征工程（Feature Engineering） 具体代码： 12345678910111213141516171819202122232425262728293031#renovationkc_test_df[&quot;renovated&quot;] = kc_test_df.yr_renovated.apply(lambda x: 1 if x &gt; 0 else 0)kc_test_df[&quot;renovation_age&quot;] = kc_test_df.yr_renovated.apply(lambda x: 2020-x if x &gt; 0 else 0)#basementkc_test_df[&quot;basement&quot;] = kc_test_df.sqft_basement.apply(lambda x: 1 if x != 0 else 0)#master bathroomkc_test_df[&quot;master_bathroom&quot;] = kc_test_df.bathrooms.apply(lambda x: 1 if x &gt; 2 else 0)#family housekc_test_df[&quot;family_house&quot;] = kc_test_df.bedrooms.apply(lambda x: 1 if x &gt; 2 else 0)#sold year and quarterkc_test_df[&quot;sale_year&quot;] = kc_test_df.date.apply(lambda x: int(x[:4]))kc_test_df[&quot;sale_quarter&quot;] = kc_test_df.date.apply(lambda x: int(x[4:6])//3.1 + 1)#zipcode dummy variableskc_test_df = kc_test_df.merge(pd.get_dummies(ziplist), left_index=True, right_index=True)#squared bedrooms and bathroomskc_test_df[&quot;bedroom_squared&quot;] = kc_test_df[&quot;bedrooms&quot;] ** 2kc_test_df[&quot;bathroom_squared&quot;] = kc_test_df[&quot;bathrooms&quot;] ** 2# uncomment to check the data set# kc_test_df.head()features = [col for col in kc_test_df.columns if col not in [&quot;id&quot;, &quot;date&quot;] ] #remove unused columnkc_test_df_features = kc_test_df[features] #set train/test data using feature above 1kc_test_df_features.head() 输出结果： 1kc_test_df_features.describe() 输出结果： 6.5导入模型与预测价格导入模型： 12345with open(&quot;models/regression_model_rfe.pickle&quot;, &quot;rb&quot;) as model: lr_model_rfe = pickle.load(model)with open(&quot;models/transform_rfe.pickle&quot;, &quot;rb&quot;) as transform: rfe_transform = pickle.load(transform) 根据RFECV变换特征： 1rfe_features = rfe_transform.transform(kc_test_df_features) 房价预测： 123kc_price_predict_rfe = lr_model_rfe.predict(rfe_features)price_prediction_rfe = pd.DataFrame(&#123;&quot;price&quot;:kc_price_predict_rfe&#125;)price_prediction_rfe.describe() 预测结果： 6.6预测结果合并与导出1234567selectedfeatures = []final_model.predict(holdout[sele])kc_import_df = kc_import_df.merge(price_prediction_rfe, left_index=True, right_index=True)#reset columns for exportkc_import_df = kc_import_df[[&#x27;id&#x27;, &#x27;price&#x27;, &#x27;date&#x27;, &#x27;bedrooms&#x27;, &#x27;bathrooms&#x27;, &#x27;sqft_living&#x27;,&#x27;sqft_lot&#x27;, &#x27;floors&#x27;, &#x27;waterfront&#x27;, &#x27;view&#x27;, &#x27;condition&#x27;, &#x27;grade&#x27;,&#x27;sqft_above&#x27;, &#x27;sqft_basement&#x27;, &#x27;yr_built&#x27;,&#x27;yr_renovated&#x27;,&#x27;zipcode&#x27;,&#x27;lat&#x27;,&#x27;long&#x27;,&#x27;sqft_living15&#x27;, &#x27;sqft_lot15&#x27;]]kc_import_df.to_csv(&quot;results/kc_house_price_prediction.csv&quot;)price_prediction_rfe.to_csv(&quot;results/kc_house_price_prediction_no_features.csv&quot;) 根据选定的特征进行房价预测，并将预测结果与其他相关数据进行合并。然后，将合并后的数据保存为名为”kc_house_price_prediction.csv”的CSV文件。最后，将price_prediction_rfe保存为名为”kc_house_price_prediction_no_features.csv”的CSV文件。 四、实验结果首先，对多元线性回归模型、递归特征消除、交叉验证的递归特征消除等回归模型分别进行测试，比较出在预测房价上表现的最好的最稳定的模型：RFE线性回归模型。其次，通过建立好的RFE线性回归模型进行未知房价的数据集的房价预测，得到房价预测表。 五、实验分析此次实验，在多个模型上进行了优劣对比，但在模型考察上只使用了均方根误差（RMSE），往后可以考虑用更多评价指标来对模型进行评估，以此获得更加全面的模型报告。 实验三一、实验目的(1) 编写程序，实现心脏病的预测模型的建立。(2) 对多个模型，依据混淆矩阵进行评估度量。(3) 写出实验报告。 二、实验原理(1)数据预处理：首先，对心脏病数据集进行数据预处理，包括特征选择、缺失值处理、数据标准化等操作，以准备数据集用于模型训练和测试。 (2)模型训练：选择了多个机器学习算法，包括SVM、朴素贝叶斯、逻辑回归、决策树、随机森林、LightGBM和XGBoost。对于每个算法，使用训练集对模型进行训练，调整算法参数以获得最佳性能。 (3)模型评估：使用测试集对训练好的模型进行预测，并计算评估指标：混淆矩阵。 (4)结果分析：根据实验结果，对不同算法的预测性能进行比较和分析，以确定哪种算法在心脏病预测任务中表现最好 三、实验内容和步骤(1)实验内容 数据预处理：对心脏病数据集进行特征选择、缺失值处理、数据标准化等预处理操作。 模型训练：使用SVM、朴素贝叶斯、逻辑回归、决策树、随机森林、LightGBM和XGBoost等算法进行模型训练。 模型评估：使用测试集对训练好的模型进行预测，并计算评估指标，混淆矩阵。 结果比较和分析：对不同算法的预测性能进行比较和分析，以确定最佳的模型。 结论：总结实验结果，给出针对心脏病预测任务的最佳模型选择和建议。 (2)实验步骤 导入数据并判断是否有缺省值 数据预处理 模型训练与评估 具体步骤： 1. 导入数据并判断是否有缺省值具体代码如下： 1234567891011121314151617181920import pandas as pd# import warnings filterfrom warnings import simplefilter# ignore all future warningssimplefilter(action=&#x27;ignore&#x27;, category = FutureWarning)# import warnings filterfrom warnings import simplefilter# ignore all future warningssimplefilter(action=&#x27;ignore&#x27;, category = FutureWarning)df = pd.read_csv(&#x27;cleveland.csv&#x27;, header = None)df.columns = [&#x27;age&#x27;, &#x27;sex&#x27;, &#x27;cp&#x27;, &#x27;trestbps&#x27;, &#x27;chol&#x27;, &#x27;fbs&#x27;, &#x27;restecg&#x27;, &#x27;thalach&#x27;, &#x27;exang&#x27;, &#x27;oldpeak&#x27;, &#x27;slope&#x27;, &#x27;ca&#x27;, &#x27;thal&#x27;, &#x27;target&#x27;]### 1 = male, 0 = femaledf.isnull().sum() 输出结果： 查看每个目标阶层的年龄和性别分布具体代码如下： 12345678910111213df[&#x27;target&#x27;] = df.target.map(&#123;0: 0, 1: 1, 2: 1, 3: 1, 4: 1&#125;)df[&#x27;sex&#x27;] = df.sex.map(&#123;0: &#x27;female&#x27;, 1: &#x27;male&#x27;&#125;)df[&#x27;thal&#x27;] = df.thal.fillna(df.thal.mean())df[&#x27;ca&#x27;] = df.ca.fillna(df.ca.mean())import matplotlib.pyplot as pltimport seaborn as sns# distribution of target vs agesns.set_context(&quot;paper&quot;, font_scale = 2, rc = &#123;&quot;font.size&quot;: 20,&quot;axes.titlesize&quot;: 25,&quot;axes.labelsize&quot;: 20&#125;) sns.catplot(kind = &#x27;count&#x27;, data = df, x = &#x27;age&#x27;, hue = &#x27;target&#x27;, order = df[&#x27;age&#x27;].sort_values().unique())plt.title(&#x27;Variation of Age for each target class&#x27;)plt.show() 输出结果： 具体代码如下： 12345# barplot of age vs sex with hue = targetsns.catplot(kind = &#x27;bar&#x27;, data = df, y = &#x27;age&#x27;, x = &#x27;sex&#x27;, hue = &#x27;target&#x27;)plt.title(&#x27;Distribution of age vs sex with the target class&#x27;)plt.show() 输出结果： 2. 数据预处理12345678910################################## data preprocessingX = df.iloc[:, :-1].valuesy = df.iloc[:, -1].valuesfrom sklearn.model_selection import train_test_splitX_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 0)from sklearn.preprocessing import StandardScaler as sssc = ss()X_train = sc.fit_transform(X_train)X_test = sc.transform(X_test) 代码解析： 数据划分：使用train_test_split函数将数据集df划分为训练集和测试集。X是除了最后一列外的所有特征，y是最后一列的目标变量。通过设置test_size参数为0.2，将数据集划分为80%的训练集和20%的测试集。random_state参数用于设定随机种子，以确保每次划分结果的一致性。 特征缩放：使用StandardScaler类进行特征缩放。sc对象是StandardScaler的实例。首先，fit_transform方法在训练集上进行拟合和转换，计算每个特征的均值和标准差，并将训练集进行标准化处理。然后，使用transform方法将测试集按照相同的均值和标准差进行标准化处理。 通过数据划分和特征缩放，可以将原始数据集划分为训练集和测试集，并对特征进行标准化处理，以便在后续的模型训练和评估中使用。这些步骤有助于确保模型在相同的数据范围内进行训练和测试，提高模型的性能和泛化能力。 3. 模型训练与评估应用以下模型进行训练，并且使用混淆矩阵进行模型评估与度量以下模型将具体使用$$accuracy&#x3D;\\frac{TP+TN}{TP+TN+FP+FN}$$作为模型的评估度量混淆矩阵如下图所示： 3.1 SVM(支持向量机)代码解析： 模型训练：使用SVC类创建一个SVM分类器对象。kernel=&#39;rbf&#39;参数指定了使用径向基函数作为核函数。然后，使用fit方法将训练集的特征X_train和标签y_train作为输入，对分类器进行训练。 预测测试集结果：使用训练好的分类器对测试集的特征X_test进行预测，使用predict方法得到预测的类别标签y_pred。 混淆矩阵：使用confusion_matrix函数计算测试集预测结果的混淆矩阵。 预测训练集结果和混淆矩阵：类似地，使用训练好的分类器对训练集的特征X_train进行预测，得到预测的类别标签y_pred_train。然后使用confusion_matrix函数计算训练集预测结果的混淆矩阵。 具体代码如下： 1234567891011121314151617######################################### SVM #############################################################from sklearn.svm import SVCclassifier = SVC(kernel = &#x27;rbf&#x27;)classifier.fit(X_train, y_train)# Predicting the Test set resultsy_pred = classifier.predict(X_test)from sklearn.metrics import confusion_matrixcm_test = confusion_matrix(y_pred, y_test)y_pred_train = classifier.predict(X_train)cm_train = confusion_matrix(y_pred_train, y_train)print()print(&#x27;Accuracy for training set for svm = &#123;&#125;&#x27;.format((cm_train[0][0] + cm_train[1][1])/len(y_train)))print(&#x27;Accuracy for test set for svm = &#123;&#125;&#x27;.format((cm_test[0][0] + cm_test[1][1])/len(y_test))) 输出结果：Accuracy for training set for svm = 0.9256198347107438 Accuracy for test set for svm = 0.8032786885245902 3.2 Naive Bayes(朴素贝叶斯)代码解析： 数据准备：使用df.iloc[:, :-1].values将数据集中除了最后一列之外的所有特征赋值给X，将最后一列的标签赋值给y。 数据划分：使用train_test_split函数将数据集划分为训练集和测试集。通过设置test_size参数为0.2，将数据集划分为80%的训练集和20%的测试集。random_state参数用于设定随机种子，以确保每次划分结果的一致性。划分后的训练集特征赋值给X_train，训练集标签赋值给y_train，测试集特征赋值给X_test，测试集标签赋值给y_test。 模型训练：使用GaussianNB类创建一个朴素贝叶斯分类器对象，即高斯朴素贝叶斯分类器。然后，使用fit方法将训练集的特征X_train和标签y_train作为输入，对分类器进行训练。 预测测试集结果：使用训练好的分类器对测试集的特征X_test进行预测，使用predict方法得到预测的类别标签y_pred。 混淆矩阵：使用confusion_matrix函数计算测试集预测结果的混淆矩阵。 预测训练集结果和混淆矩阵：类似地，使用训练好的分类器对训练集的特征X_train进行预测，得到预测的类别标签y_pred_train。然后使用confusion_matrix函数计算训练集预测结果的混淆矩阵。 具体代码如下： 1234567891011121314151617181920212223242526######################################### Naive Bayes #############################################################X = df.iloc[:, :-1].valuesy = df.iloc[:, -1].valuesfrom sklearn.model_selection import train_test_splitX_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 0)from sklearn.naive_bayes import GaussianNBclassifier = GaussianNB()classifier.fit(X_train, y_train)# Predicting the Test set resultsy_pred = classifier.predict(X_test)from sklearn.metrics import confusion_matrixcm_test = confusion_matrix(y_pred, y_test)y_pred_train = classifier.predict(X_train)cm_train = confusion_matrix(y_pred_train, y_train)print()print(&#x27;Accuracy for training set for Naive Bayes = &#123;&#125;&#x27;.format((cm_train[0][0] + cm_train[1][1])/len(y_train)))print(&#x27;Accuracy for test set for Naive Bayes = &#123;&#125;&#x27;.format((cm_test[0][0] + cm_test[1][1])/len(y_test))) 输出结果：Accuracy for training set for Naive Bayes = 0.8677685950413223Accuracy for test set for Naive Bayes = 0.7868852459016393 3.3 Logistic Regression(逻辑回归)代码解析： 数据准备：使用df.iloc[:, :-1].values将数据集中除了最后一列之外的所有特征赋值给X，将最后一列的标签赋值给y。 数据划分：使用train_test_split函数将数据集划分为训练集和测试集。通过设置test_size参数为0.2，将数据集划分为80%的训练集和20%的测试集。random_state参数用于设定随机种子，以确保每次划分结果的一致性。划分后的训练集特征赋值给X_train，训练集标签赋值给y_train，测试集特征赋值给X_test，测试集标签赋值给y_test。 模型训练：使用LogisticRegression类创建一个逻辑回归分类器对象。然后，使用fit方法将训练集的特征X_train和标签y_train作为输入，对分类器进行训练。 预测测试集结果：使用训练好的分类器对测试集的特征X_test进行预测，使用predict方法得到预测的类别标签y_pred。 混淆矩阵：使用confusion_matrix函数计算测试集预测结果的混淆矩阵。 预测训练集结果和混淆矩阵：类似地，使用训练好的分类器对训练集的特征X_train进行预测，得到预测的类别标签y_pred_train。然后使用confusion_matrix函数计算训练集预测结果的混淆矩阵。 具体代码如下： 1234567891011121314151617181920212223242526######################################### Logistic Regression #############################################################X = df.iloc[:, :-1].valuesy = df.iloc[:, -1].valuesfrom sklearn.model_selection import train_test_splitX_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 0)from sklearn.linear_model import LogisticRegressionclassifier = LogisticRegression()classifier.fit(X_train, y_train)# Predicting the Test set resultsy_pred = classifier.predict(X_test)from sklearn.metrics import confusion_matrixcm_test = confusion_matrix(y_pred, y_test)y_pred_train = classifier.predict(X_train)cm_train = confusion_matrix(y_pred_train, y_train)print()print(&#x27;Accuracy for training set for Logistic Regression = &#123;&#125;&#x27;.format((cm_train[0][0] + cm_train[1][1])/len(y_train)))print(&#x27;Accuracy for test set for Logistic Regression = &#123;&#125;&#x27;.format((cm_test[0][0] + cm_test[1][1])/len(y_test))) 输出结果：Accuracy for training set for Logistic Regression = 0.8677685950413223Accuracy for test set for Logistic Regression = 0.8032786885245902 3.4 Decision Tree(决策树)代码解析： 数据准备：使用df.iloc[:, :-1].values将数据集中除了最后一列之外的所有特征赋值给X，将最后一列的标签赋值给y。 数据划分：使用train_test_split函数将数据集划分为训练集和测试集。通过设置test_size参数为0.2，将数据集划分为80%的训练集和20%的测试集。random_state参数用于设定随机种子，以确保每次划分结果的一致性。划分后的训练集特征赋值给X_train，训练集标签赋值给y_train，测试集特征赋值给X_test，测试集标签赋值给y_test。 模型训练：使用DecisionTreeClassifier类创建一个决策树分类器对象。然后，使用fit方法将训练集的特征X_train和标签y_train作为输入，对分类器进行训练。 预测测试集结果：使用训练好的分类器对测试集的特征X_test进行预测，使用predict方法得到预测的类别标签y_pred。 混淆矩阵：使用confusion_matrix函数计算测试集预测结果的混淆矩阵。 预测训练集结果和混淆矩阵：类似地，使用训练好的分类器对训练集的特征X_train进行预测，得到预测的类别标签y_pred_train。然后使用confusion_matrix函数计算训练集预测结果的混淆矩阵。 具体代码如下： 12345678910111213141516171819202122232425######################################### Decision Tree #############################################################X = df.iloc[:, :-1].valuesy = df.iloc[:, -1].valuesfrom sklearn.model_selection import train_test_splitX_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 0)from sklearn.tree import DecisionTreeClassifierclassifier = DecisionTreeClassifier()classifier.fit(X_train, y_train)# Predicting the Test set resultsy_pred = classifier.predict(X_test)from sklearn.metrics import confusion_matrixcm_test = confusion_matrix(y_pred, y_test)y_pred_train = classifier.predict(X_train)cm_train = confusion_matrix(y_pred_train, y_train)print()print(&#x27;Accuracy for training set for Decision Tree = &#123;&#125;&#x27;.format((cm_train[0][0] + cm_train[1][1])/len(y_train)))print(&#x27;Accuracy for test set for Decision Tree = &#123;&#125;&#x27;.format((cm_test[0][0] + cm_test[1][1])/len(y_test))) 输出结果：Accuracy for training set for Decision Tree = 1.0Accuracy for test set for Decision Tree = 0.8032786885245902 3.5 Random Forest(随机森林)代码解析： 数据准备：使用df.iloc[:, :-1].values将数据集中除了最后一列之外的所有特征赋值给X，将最后一列的标签赋值给y。 数据划分：使用train_test_split函数将数据集划分为训练集和测试集。通过设置test_size参数为0.2，将数据集划分为80%的训练集和20%的测试集。random_state参数用于设定随机种子，以确保每次划分结果的一致性。划分后的训练集特征赋值给X_train，训练集标签赋值给y_train，测试集特征赋值给X_test，测试集标签赋值给y_test。 模型训练：使用RandomForestClassifier类创建一个随机森林分类器对象。通过设置n_estimators参数为10，指定随机森林中树的数量为10。然后，使用fit方法将训练集的特征X_train和标签y_train作为输入，对分类器进行训练。 预测测试集结果：使用训练好的分类器对测试集的特征X_test进行预测，使用predict方法得到预测的类别标签y_pred。 混淆矩阵：使用confusion_matrix函数计算测试集预测结果的混淆矩阵。 预测训练集结果和混淆矩阵：类似地，使用训练好的分类器对训练集的特征X_train进行预测，得到预测的类别标签y_pred_train。然后使用confusion_matrix函数计算训练集预测结果的混淆矩阵。 具体代码如下： 12345678910111213141516171819202122232425######################################### Random Forest #############################################################X = df.iloc[:, :-1].valuesy = df.iloc[:, -1].valuesfrom sklearn.model_selection import train_test_splitX_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 0)from sklearn.ensemble import RandomForestClassifierclassifier = RandomForestClassifier(n_estimators = 10)classifier.fit(X_train, y_train)# Predicting the Test set resultsy_pred = classifier.predict(X_test)from sklearn.metrics import confusion_matrixcm_test = confusion_matrix(y_pred, y_test)y_pred_train = classifier.predict(X_train)cm_train = confusion_matrix(y_pred_train, y_train)print()print(&#x27;Accuracy for training set for Random Forest = &#123;&#125;&#x27;.format((cm_train[0][0] + cm_train[1][1])/len(y_train)))print(&#x27;Accuracy for test set for Random Forest = &#123;&#125;&#x27;.format((cm_test[0][0] + cm_test[1][1])/len(y_test))) 输出结果：Accuracy for training set for Random Forest = 0.9834710743801653Accuracy for test set for Random Forest = 0.7049180327868853 3.6 LightGBM代码解析： 数据准备：使用lgb.Dataset函数将训练集的特征X_train和标签y_train组成LightGBM需要的数据集对象d_train。 参数设置：定义一个空字典params用于设置LightGBM的参数。 模型训练：使用lgb.train函数训练LightGBM模型。传入参数params表示模型的参数设置，d_train表示训练数据集，100表示训练的轮数（迭代次数）。 预测测试集结果：使用训练好的模型对测试集的特征X_test进行预测，得到预测的概率值y_pred。 二值化处理：根据设定的阈值（0.5），将概率值转换为二进制的类别标签。概率值大于等于0.5的被划分为类别1，小于0.5的被划分为类别0。 混淆矩阵：使用confusion_matrix函数计算测试集预测结果的混淆矩阵。 预测训练集结果和混淆矩阵：类似地，使用训练好的模型对训练集的特征X_train进行预测，得到预测的概率值y_pred_train。然后使用confusion_matrix函数计算训练集预测结果的混淆矩阵。 具体代码如下： 12345678910111213141516171819202122232425262728293031323334################################################################################ applying lightGBMimport lightgbm as lgbd_train = lgb.Dataset(X_train, label = y_train)params = &#123;&#125;clf = lgb.train(params, d_train, 100)#Predictiony_pred = clf.predict(X_test)#convert into binary valuesfor i in range(0, len(y_pred)): if y_pred[i]&gt;= 0.5: # setting threshold to .5 y_pred[i]=1 else: y_pred[i]=0 from sklearn.metrics import confusion_matrixcm_test = confusion_matrix(y_pred, y_test)y_pred_train = clf.predict(X_train)for i in range(0, len(y_pred_train)): if y_pred_train[i]&gt;= 0.5: # setting threshold to .5 y_pred_train[i]=1 else: y_pred_train[i]=0 cm_train = confusion_matrix(y_pred_train, y_train)print()print(&#x27;Accuracy for training set for LightGBM = &#123;&#125;&#x27;.format((cm_train[0][0] + cm_train[1][1])/len(y_train)))print(&#x27;Accuracy for test set for LightGBM = &#123;&#125;&#x27;.format((cm_test[0][0] + cm_test[1][1])/len(y_test))) 输出结果：Accuracy for training set for LightGBN = 0.9958677685950413Accuracy for test set for LightGBN = 0.7704918032786885 3.7 XGBoost代码解析： 模型训练：使用XGBClassifier类创建一个XGBoost分类器对象xg。然后，使用fit方法将训练集的特征X_train和标签y_train作为输入，对分类器进行训练。 预测测试集结果：使用训练好的分类器对测试集的特征X_test进行预测，得到预测的类别标签y_pred。 混淆矩阵：使用confusion_matrix函数计算测试集预测结果的混淆矩阵。 预测训练集结果和混淆矩阵：类似地，使用训练好的分类器对训练集的特征X_train进行预测，得到预测的类别标签y_pred_train。然后使用confusion_matrix函数计算训练集预测结果的混淆矩阵。 具体代码如下： 12345678910111213141516171819202122232425262728################################################################################ applying XGBoost#from sklearn.model_selection import train_test_split#X_train, X_test, y_train, y_test = train_test_split(X, target, test_size = 0.20, random_state = 0)from xgboost import XGBClassifierxg = XGBClassifier()xg.fit(X_train, y_train)y_pred = xg.predict(X_test)from sklearn.metrics import confusion_matrixcm_test = confusion_matrix(y_pred, y_test)y_pred_train = xg.predict(X_train)for i in range(0, len(y_pred_train)): if y_pred_train[i]&gt;= 0.5: # setting threshold to .5 y_pred_train[i]=1 else: y_pred_train[i]=0cm_train = confusion_matrix(y_pred_train, y_train)print()print(&#x27;Accuracy for training set for XGBoost = &#123;&#125;&#x27;.format((cm_train[0][0] + cm_train[1][1])/len(y_train)))print(&#x27;Accuracy for test set for XGBoost = &#123;&#125;&#x27;.format((cm_test[0][0] + cm_test[1][1])/len(y_test))) 输出结果：Accuracy for training set for XGBoost = 0.987603305785124 Accuracy for test set for XGBoost &#x3D; 0.7540983606557377&#96; 四、实验结果通过对上述七个模型进行混淆矩阵评估度量，得到以下实验结果：Accuracy for training set for svm = 0.9256198347107438 Accuracy for test set for svm = 0.8032786885245902 Accuracy for training set for Naive Bayes = 0.8677685950413223Accuracy for test set for Naive Bayes = 0.7868852459016393 Accuracy for training set for Logistic Regression = 0.8677685950413223Accuracy for test set for Logistic Regression = 0.8032786885245902 Accuracy for training set for Decision Tree = 1.0Accuracy for test set for Decision Tree = 0.8032786885245902 Accuracy for training set for Random Forest = 0.9834710743801653Accuracy for test set for Random Forest = 0.7049180327868853 Accuracy for training set for LightGBN = 0.9958677685950413Accuracy for test set for LightGBN = 0.7704918032786885 Accuracy for training set for XGBoost = 0.987603305785124 Accuracy for test set for XGBoost &#x3D; 0.7540983606557377&#96;由此可得，在训练集上Decision Tree具有最高的Accuracy；而在测试集上SVM、Logistic Regression、Decision Tree具有最高的Accuracy。 五、实验分析此次实验，在多个模型上进行了优劣对比，但在模型的评估度量上只使用了混淆矩阵中的Accuracy，往后可以考虑用更多评估度量标准来对模型进行评估，评估模型的性能和可靠性。以此获得更加全面准确的模型报告。 实验四一、实验目的(1) 编写程序，实现对图片上颜色的检测。(2) 写出实验报告。 二、实验原理(1)导入所需的库：代码中导入了 pandas 和 cv2 库。pandas 用于读取颜色名称数据集，cv2 用于处理图像。 (2)读取图像和颜色名称数据集：使用 cv2.imread() 函数读取图像文件，并使用 pandas 的 read_csv() 函数读取颜色名称数据集。 (3)定义函数获取颜色名称：定义了一个名为 getColorName() 的函数，用于根据 RGB 值获取对应的颜色名称。该函数通过计算 RGB 值与数据集中每个颜色的差异来确定最匹配的颜色名称。 (4)定义鼠标回调函数：定义了一个名为 draw_function() 的回调函数，用于处理鼠标事件。当用户双击鼠标左键时，该函数会获取鼠标点击位置的 RGB 值，并将其保存到全局变量中。 (5)主循环：在主循环中，首先检查是否有点击事件发生。如果发生点击事件，则在图像上绘制矩形框和显示颜色名称。然后，根据颜色的亮度值，选择合适的文本颜色来显示颜色名称。循环将继续运行，直到用户按下键盘上的 Esc 键。 (7)显示图像和关闭窗口：使用 cv2.imshow() 函数显示带有颜色信息的图像，并使用 cv2.destroyAllWindows() 函数关闭窗口。 三、实验内容和步骤(1)实验内容 用python编写程序，实现颜色检测的程序：读取一张图片，当用户在图片上双击鼠标左键时，程序会提取该位置的像素颜色，并根据颜色的RGB值在图片上显示颜色名称。 测试程序 (2)实验步骤 导入库 定义变量和函数 主函数 具体步骤： 1. 导入库pandas用于读取颜色名称数据，cv2用于图像处理。 12import pandas as pdimport cv2 2. 定义变量和函数 imageUrl：指定要读取的图片路径。 clicked：记录是否有鼠标双击事件发生。 redValue、greenValue、blueValue：记录选定位置的像素颜色的RGB值。 xPosition、yPosition：记录鼠标双击位置的坐标。 colorNameDataFrame：使用pandas读取颜色名称数据，并进行必要的处理。 getColorName()函数：根据给定的RGB值，从颜色名称数据中找到最接近的颜色名称。 draw_function()函数：处理鼠标双击事件的回调函数，记录选定位置的像素颜色的RGB值。1234567891011121314151617181920212223242526272829303132imageUrl = &#x27;E:\\image.png&#x27;clicked = FalseredValue = 0greenValue = 0blueValue = 0xPosition = 0yPosition = 0colorNameDataFrame = pd.read_csv(&#x27;数据挖掘\\数据挖掘_实验部分\\实验6：颜色检测实验_Color Detection\\Dataset\\wikipedia_color_names.csv&#x27;)colorNameDataFrame.drop(colorNameDataFrame.iloc[:,5:8], inplace=True, axis=1)colorNameDataFrame.rename(columns=&#123;&#x27;Hex (24 bit)&#x27;:&#x27;Hex&#x27;, &#x27;Red (8 bit)&#x27;:&#x27;Red&#x27;, &#x27;Green (8 bit)&#x27;:&#x27;Green&#x27;, &#x27;Blue (8 bit)&#x27;:&#x27;Blue&#x27;&#125;, inplace=True)image = cv2.imread(imageUrl)def getColorName(red,green,blue): minimumValue = 10000 for i in range(len(colorNameDataFrame)): rgbValue = abs(red- int(colorNameDataFrame.loc[i,&quot;Red&quot;])) + abs(green- int(colorNameDataFrame.loc[i,&quot;Green&quot;]))+ abs(blue- int(colorNameDataFrame.loc[i,&quot;Blue&quot;])) if(rgbValue &lt;= minimumValue): minimumValue = rgbValue colorName = colorNameDataFrame.loc[i,&quot;Name&quot;] return colorNamedef draw_function(event, x,y, flags, param): if event == cv2.EVENT_LBUTTONDBLCLK: global blueValue, greenValue, redValue, xPosition, yPosition, clicked clicked = True xPosition = x yPosition = y blueValue, greenValue, redValue = image[yPosition, xPosition] blueValue = int(blueValue) greenValue = int(greenValue) redValue = int(redValue) 代码解析： getColorName()函数： 初始化变量：将 minimumValue 初始化为一个较大的值，以便在比较过程中更新最小差异值。初始化 colorName 为空字符串，用于保存最匹配的颜色名称。 遍历颜色名称数据集：使用 for 循环遍历颜色名称数据集的每一行。 计算差异值：对于每一行，将给定的 RGB 值与数据集中对应的 RGB 值进行差值计算。差值计算使用绝对值函数 abs() 来确保计算结果为正数。 更新最小差异值和颜色名称：如果计算得到的差异值小于等于当前的最小差异值 minimumValue，则更新最小差异值为当前差异值，并将对应的颜色名称保存到 colorName 中。 返回颜色名称：完成遍历后，返回最匹配的颜色名称 draw_function()函数： 检查事件类型：通过判断 event 是否等于 cv2.EVENT_LBUTTONDBLCLK，确定当前事件是否为鼠标双击事件。 更新全局变量：如果是鼠标双击事件，将全局变量 clicked 设置为 True，表示鼠标已被点击。同时更新全局变量 xPosition 和 yPosition，记录鼠标点击位置的坐标。 获取像素值：通过访问图像 image 的像素值，获取鼠标点击位置 (xPosition, yPosition) 处的 RGB 值，并将其保存到全局变量 blueValue、greenValue 和 redValue 中。 转换数据类型：将获取的 RGB 值转换为整数类型，以便后续处理。 3. 主函数12345678910111213141516171819if __name__ == &#x27;__main__&#x27;: cv2.namedWindow(&#x27;Color Name&#x27;) cv2.setMouseCallback(&#x27;Color Name&#x27;, draw_function) while (1): if (clicked): cv2.rectangle(image, (20, 20), (950, 60), (blueValue, greenValue, redValue), -1) colorName = &#x27;Selected color name is:-&#x27; + getColorName(redValue, greenValue, blueValue) cv2.putText(image, colorName, (50, 50), 2, 0.75, (255, 255, 255), 1, cv2.FONT_ITALIC) minimumValue = abs(redValue + greenValue + blueValue) if (minimumValue &gt;= 600): cv2.putText(image, colorName, (50, 50), 2, 0.75, (0, 0, 0), 1, cv2.FONT_ITALIC) clicked = False cv2.imshow(&quot;Color Name&quot;, image) # Break the loop when user hits &#x27;esc&#x27; key if cv2.waitKey(20) &amp; 0xFF == 27: break cv2.destroyAllWindows() 代码解析： 创建窗口和绑定鼠标回调函数： 使用cv2.namedWindow()创建名为”Color Name”的窗口。 使用cv2.setMouseCallback()绑定鼠标回调函数。 进入循环： 如果发生了鼠标双击事件（clicked为True），根据选定位置的RGB值在图片上绘制矩形和颜色名称。 调用getColorName()函数获取选定颜色的名称，并在图片上显示。 如果颜色的RGB值的绝对值之和大于等于600，将颜色名称的文字颜色设置为黑色。 将处理后的图片显示在窗口中。 如果用户按下了ESC键，退出循环 (3)完整程序代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import pandas as pdimport cv2imageUrl = &#x27;E:\\image.png&#x27;clicked = FalseredValue = 0greenValue = 0blueValue = 0xPosition = 0yPosition = 0colorNameDataFrame = pd.read_csv(&#x27;数据挖掘\\数据挖掘_实验部分\\实验6：颜色检测实验_Color Detection\\Dataset\\wikipedia_color_names.csv&#x27;)colorNameDataFrame.drop(colorNameDataFrame.iloc[:,5:8], inplace=True, axis=1)colorNameDataFrame.rename(columns=&#123;&#x27;Hex (24 bit)&#x27;:&#x27;Hex&#x27;, &#x27;Red (8 bit)&#x27;:&#x27;Red&#x27;, &#x27;Green (8 bit)&#x27;:&#x27;Green&#x27;, &#x27;Blue (8 bit)&#x27;:&#x27;Blue&#x27;&#125;, inplace=True)image = cv2.imread(imageUrl)def getColorName(red,green,blue): minimumValue = 10000 for i in range(len(colorNameDataFrame)): rgbValue = abs(red- int(colorNameDataFrame.loc[i,&quot;Red&quot;])) + abs(green- int(colorNameDataFrame.loc[i,&quot;Green&quot;]))+ abs(blue- int(colorNameDataFrame.loc[i,&quot;Blue&quot;])) if(rgbValue &lt;= minimumValue): minimumValue = rgbValue colorName = colorNameDataFrame.loc[i,&quot;Name&quot;] return colorNamedef draw_function(event, x,y, flags, param): if event == cv2.EVENT_LBUTTONDBLCLK: global blueValue, greenValue, redValue, xPosition, yPosition, clicked clicked = True xPosition = x yPosition = y blueValue, greenValue, redValue = image[yPosition, xPosition] blueValue = int(blueValue) greenValue = int(greenValue) redValue = int(redValue)if __name__ == &#x27;__main__&#x27;: cv2.namedWindow(&#x27;Color Name&#x27;) cv2.setMouseCallback(&#x27;Color Name&#x27;, draw_function) while (1): if (clicked): cv2.rectangle(image, (20, 20), (950, 60), (blueValue, greenValue, redValue), -1) colorName = &#x27;Selected color name is:-&#x27; + getColorName(redValue, greenValue, blueValue) cv2.putText(image, colorName, (50, 50), 2, 0.75, (255, 255, 255), 1, cv2.FONT_ITALIC) minimumValue = abs(redValue + greenValue + blueValue) if (minimumValue &gt;= 600): cv2.putText(image, colorName, (50, 50), 2, 0.75, (0, 0, 0), 1, cv2.FONT_ITALIC) clicked = False cv2.imshow(&quot;Color Name&quot;, image) # Break the loop when user hits &#x27;esc&#x27; key if cv2.waitKey(20) &amp; 0xFF == 27: break cv2.destroyAllWindows() 四、实验结果程序的运行结果与演示如下图所示：可以看到，输入的图片是vscode界面，当双击蓝色部分时，程序左上角出现了以蓝色为背景的文字“Selected color name is:-St. Patrick’s blue”。而下方双击绿色部分，则显示绿色背景的文字“Selected color name is:-Old moss green”。 五、实验分析该程序的稳定性较强，但在用户体验方面仍有改进之处：可以把双击某部分改成鼠标停留在哪就显示该处颜色。这样在用户体验上可能会更好。 实验五一、实验目的(1) 编写程序，基于机器学习和深度学习实现手写体的识别。(2) 对实现的三个模型进行评估。(3) 写出实验报告。 二、实验原理(1)支持向量机（SVM）： 支持向量机是一种监督学习算法，用于二分类和多分类问题。在手写体识别任务中，S和VM可以被用来将手写数字图像分为不同的类别。SVM通过寻找一个最优的超平面来将不同类别的数据点分开。对于手写数字识别，每个图像被表示为一组特征向量，并与相应的标签（数字类别）相关联。SVM通过学习一个决策边界，使得不同类别的图像在特征空间中被最大化地分离。 (2)K最近邻算法（K Nearest Neighbors）： K最近邻算法是一种基于实例的学习方法，用于分类和回归问题。对于手写体识别任务，K最近邻算法可以用于根据与目标图像最相似的K个训练样本的标签来预测目标图像的类别。算法通过计算目标图像与所有训练图像之间的距离（如欧氏距离）来确定最相似的训练样本，然后根据K个最相似样本的标签进行投票来确定目标图像的类别。 (3) 随机森林分类器（Random Forest Classifier）： 随机森林是一种集成学习方法，它由多个决策树组成。每个决策树都是基于不同的训练样本和特征子集构建的。在手写体识别任务中，随机森林分类器可以通过将图像的特征输入到每个决策树中，并将决策树的预测结果进行投票来确定图像的类别。随机森林具有良好的泛化能力和抗过拟合能力，并且在处理高维特征空间和大规模数据集时表现良好 三、实验内容和步骤(1)实验内容 用python编写程序，通过SVM、K Nearest Neighbors、Random Forest Classifier分别实现手写体的识别模型 分别评估模型 (2)实验步骤 基于K Nearest Neighbors实现 基于SVM实现 基于Random Forest Classifier实现 具体步骤： 1. 基于K Nearest Neighbors实现1.1 相关库的导入12345678910import sysimport numpy as npimport picklefrom sklearn import model_selectionfrom sklearn.neighbors import KNeighborsClassifierfrom sklearn.metrics import accuracy_score, confusion_matrixfrom MNIST_Dataset_Loader.mnist_loader import MNISTimport matplotlib.pyplot as pltfrom matplotlib import stylestyle.use(&#x27;ggplot&#x27;) 1.2 数据加载和准备1234567891011121314print(&#x27;\\nLoading MNIST Data...&#x27;)# data = MNIST(&#x27;./python-mnist/data/&#x27;)data = MNIST(&#x27;E:\\MNIST_Dataset_Loader\\dataset&#x27;)print(&#x27;\\nLoading Training Data...&#x27;)img_train, labels_train = data.load_training()train_img = np.array(img_train)train_labels = np.array(labels_train)print(&#x27;\\nLoading Testing Data...&#x27;)img_test, labels_test = data.load_testing()test_img = np.array(img_test)test_labels = np.array(labels_test) 代码解析： MNIST数据集是一个广泛使用的手写数字数据集，包含了大量的手写数字图像和相应的标签。 使用MNIST数据加载器加载训练数据和测试数据，并将其转换为NumPy数组。 1.3 创建和训练KNN分类器1234567891011121314151617#FeaturesX = train_img#Labelsy = train_labelsprint(&#x27;\\nPreparing Classifier Training and Validation Data...&#x27;)X_train, X_test, y_train, y_test = model_selection.train_test_split(X,y,test_size=0.1)print(&#x27;\\nKNN Classifier with n_neighbors = 5, algorithm = auto, n_jobs = 10&#x27;)print(&#x27;\\nPickling the Classifier for Future Use...&#x27;)clf = KNeighborsClassifier(n_neighbors=5,algorithm=&#x27;auto&#x27;,n_jobs=10)clf.fit(X_train,y_train)with open(&#x27;MNIST_KNN.pickle&#x27;,&#x27;wb&#x27;) as f: pickle.dump(clf, f) 代码解析： 使用train_test_split函数将训练数据划分为训练集和验证集。 使用KNeighborsClassifier类创建一个K最近邻分类器。 将训练图像作为特征（X）和对应的标签（y）传递给分类器，使用训练集对KNN分类器进行训练。 将训练好的分类器保存到文件中，以便将来使用。 1.4 验证和评估分类器在这部分代码中，首先使用pickle.load函数从文件中加载之前保存的KNN分类器对象。具体步骤如下： 打开文件MNIST_KNN.pickle，以二进制读取模式进行操作。&#39;rb&#39;表示以二进制读取模式打开文件。 使用pickle.load函数从文件中加载KNN分类器对象，并将其赋值给变量clf。具体代码如下：12pickle_in = open(&#x27;MNIST_KNN.pickle&#x27;,&#x27;rb&#x27;)clf = pickle.load(pickle_in) 接下来，先进行对已训练分类器的性能在验证数据集上的评估和预测： 代码解析： 计算已训练分类器在验证数据集上的准确率。通过调用clf.score(X_test, y_test)方法，得到分类器在验证数据集上的准确率，将其赋值给变量confidence。 使用已训练分类器对验证数据集进行预测。通过调用clf.predict(X_test)方法，得到分类器对验证数据集的预测结果，将其赋值给变量y_pred。 计算预测结果的准确率。通过调用accuracy_score(y_test, y_pred)方法，计算分类器的预测准确率，将其赋值给变量accuracy。 创建并显示验证数据集的混淆矩阵。通过调用confusion_matrix(y_test, y_pred)方法，得到验证数据集的混淆矩阵，然后使用plt.matshow等函数绘制混淆矩阵的可视化。 具体代码如下： 12345678910111213141516171819202122232425print(&#x27;\\nCalculating Accuracy of trained Classifier...&#x27;)confidence = clf.score(X_test,y_test)print(&#x27;\\nMaking Predictions on Validation Data...&#x27;)y_pred = clf.predict(X_test)print(&#x27;\\nCalculating Accuracy of Predictions...&#x27;)accuracy = accuracy_score(y_test, y_pred)print(&#x27;\\nCreating Confusion Matrix...&#x27;)conf_mat = confusion_matrix(y_test,y_pred)print(&#x27;\\nKNN Trained Classifier Confidence: &#x27;,confidence)print(&#x27;\\nPredicted Values: &#x27;,y_pred)print(&#x27;\\nAccuracy of Classifier on Validation Image Data: &#x27;,accuracy)print(&#x27;\\nConfusion Matrix: \\n&#x27;,conf_mat)# Plot Confusion Matrix Data as a Matrixplt.matshow(conf_mat)plt.title(&#x27;Confusion Matrix for Validation Data&#x27;)plt.colorbar()plt.ylabel(&#x27;True label&#x27;)plt.xlabel(&#x27;Predicted label&#x27;)plt.show() 输出结果：KNN Trained Classifier Confidence: 0.9738333333333333Predicted Values: [7 0 0 ... 8 2 1]Accuracy of Classifier on Validation Image Data: 0.9738333333333333Confusion Matrix: [[568 0 0 0 0 0 1 1 0 0] [ 0 674 1 0 1 0 0 1 0 0] [ 1 6 585 1 1 1 2 9 0 0] [ 0 3 3 616 0 4 0 6 5 2] [ 0 3 0 0 564 0 1 1 0 14] [ 1 1 0 6 0 509 4 0 1 3] [ 2 3 0 0 0 8 605 0 0 0] [ 2 5 3 0 0 0 0 599 0 6] [ 0 9 0 6 2 5 1 0 547 7] [ 0 2 0 1 1 2 0 7 1 576]] 然后进行对已训练分类器的性能在测试数据集上的评估和预测： 代码解析： 使用已训练分类器对测试数据集进行预测。通过调用clf.predict(test_img)方法，得到分类器对测试数据集的预测结果，将其赋值给变量test_labels_pred。 计算已训练分类器在测试数据集上的准确率。通过调用accuracy_score(test_labels, test_labels_pred)方法，计算分类器在测试数据集上的预测准确率，将其赋值给变量acc。 创建并显示测试数据集的混淆矩阵。通过调用confusion_matrix(test_labels, test_labels_pred)方法，得到测试数据集的混淆矩阵，然后使用plt.matshow等函数绘制混淆矩阵的可视化。 具体代码： 123456789101112131415161718192021print(&#x27;\\nMaking Predictions on Test Input Images...&#x27;)test_labels_pred = clf.predict(test_img)print(&#x27;\\nCalculating Accuracy of Trained Classifier on Test Data... &#x27;)acc = accuracy_score(test_labels,test_labels_pred)print(&#x27;\\n Creating Confusion Matrix for Test Data...&#x27;)conf_mat_test = confusion_matrix(test_labels,test_labels_pred)print(&#x27;\\nPredicted Labels for Test Images: &#x27;,test_labels_pred)print(&#x27;\\nAccuracy of Classifier on Test Images: &#x27;,acc)print(&#x27;\\nConfusion Matrix for Test Data: \\n&#x27;,conf_mat_test)# Plot Confusion Matrix for Test Dataplt.matshow(conf_mat_test)plt.title(&#x27;Confusion Matrix for Test Data&#x27;)plt.colorbar()plt.ylabel(&#x27;True label&#x27;)plt.xlabel(&#x27;Predicted label&#x27;)plt.axis(&#x27;off&#x27;)plt.show() 输出结果：Predicted Labels for Test Images: [7 2 1 ... 4 5 6]Accuracy of Classifier on Test Images: 0.9675Confusion Matrix for Test Data: [[ 973 1 1 0 0 1 3 1 0 0] [ 0 1131 2 0 0 0 2 0 0 0] [ 11 8 989 2 1 0 1 16 4 0] [ 0 3 2 972 1 16 1 7 4 4] [ 3 6 0 0 944 0 4 2 1 22] [ 5 0 0 13 2 861 4 1 2 4] [ 5 4 0 0 3 2 944 0 0 0] [ 0 23 4 0 3 0 0 987 0 11] [ 7 3 5 13 6 15 4 5 911 5] [ 5 6 3 8 8 2 1 11 2 963]] 1.5 显示预测结果随机选择一些测试图像，将原始标签和预测标签显示在图像上，以便观察分类器的预测效果。 具体代码如下： 1234567# Show the Test Images with Original and Predicted Labelsa = np.random.randint(1,50,20)for i in a: two_d = (np.reshape(test_img[i], (28, 28)) * 255).astype(np.uint8) plt.title(&#x27;Original Label: &#123;0&#125; Predicted Label: &#123;1&#125;&#x27;.format(test_labels[i],test_labels_pred[i])) plt.imshow(two_d, interpolation=&#x27;nearest&#x27;,cmap=&#x27;gray&#x27;) plt.show() 输出效果如下： 2. 基于SVM实现2.1 相关库的导入123456789import sysimport numpy as npimport picklefrom sklearn import model_selection, svm, preprocessingfrom sklearn.metrics import accuracy_score,confusion_matrixfrom MNIST_Dataset_Loader.mnist_loader import MNISTimport matplotlib.pyplot as pltfrom matplotlib import stylestyle.use(&#x27;ggplot&#x27;) 2.2 数据加载和准备12345678910111213# Load MNIST Dataprint(&#x27;\\nLoading MNIST Data...&#x27;)data = MNIST(&#x27;E:\\MNIST_Dataset_Loader\\dataset&#x27;)print(&#x27;\\nLoading Training Data...&#x27;)img_train, labels_train = data.load_training()train_img = np.array(img_train)train_labels = np.array(labels_train)print(&#x27;\\nLoading Testing Data...&#x27;)img_test, labels_test = data.load_testing()test_img = np.array(img_test)test_labels = np.array(labels_test) 代码解析： MNIST数据集是一个广泛使用的手写数字数据集，包含了大量的手写数字图像和相应的标签。 使用MNIST数据加载器加载训练数据和测试数据，并将其转换为NumPy数组。 2.3 创建和训练SVM分类器12345678910111213141516171819#FeaturesX = train_img#Labelsy = train_labels# Prepare Classifier Training and Testing Dataprint(&#x27;\\nPreparing Classifier Training and Validation Data...&#x27;)X_train, X_test, y_train, y_test = model_selection.train_test_split(X,y,test_size=0.1)# Pickle the Classifier for Future Useprint(&#x27;\\nSVM Classifier with gamma = 0.1; Kernel = polynomial&#x27;)print(&#x27;\\nPickling the Classifier for Future Use...&#x27;)clf = svm.SVC(gamma=0.1, kernel=&#x27;poly&#x27;)clf.fit(X_train,y_train)with open(&#x27;MNIST_SVM.pickle&#x27;,&#x27;wb&#x27;) as f: pickle.dump(clf, f) 代码解析： 使用train_test_split函数将训练数据划分为训练集和验证集。 使用svm.SVC类创建一个SVM分类器。 将训练图像作为特征（X）和对应的标签（y）传递给分类器，使用训练集对SVM分类器进行训练。 将训练好的分类器保存到文件中，以便将来使用。 2.4 验证和评估分类器在这部分代码中，首先使用pickle.load函数从文件中加载之前保存的SVM分类器对象。具体步骤如下： 打开文件MNIST_KNN.pickle，以二进制读取模式进行操作。&#39;rb&#39;表示以二进制读取模式打开文件。 使用pickle.load函数从文件中加载KNN分类器对象，并将其赋值给变量clf。具体代码如下：12pickle_in = open(&#x27;MNIST_KNN.pickle&#x27;,&#x27;rb&#x27;)clf = pickle.load(pickle_in) 接下来，先进行对已训练分类器的性能在验证数据集上的评估和预测： 代码解析： 计算已训练分类器在验证数据集上的准确率。通过调用clf.score(X_test, y_test)方法，得到分类器在验证数据集上的准确率，将其赋值给变量confidence。 使用已训练分类器对验证数据集进行预测。通过调用clf.predict(X_test)方法，得到分类器对验证数据集的预测结果，将其赋值给变量y_pred。 计算预测结果的准确率。通过调用accuracy_score(y_test, y_pred)方法，计算分类器的预测准确率，将其赋值给变量accuracy。 创建并显示验证数据集的混淆矩阵。通过调用confusion_matrix(y_test, y_pred)方法，得到验证数据集的混淆矩阵，然后使用plt.matshow等函数绘制混淆矩阵的可视化。 具体代码如下： 12345678910111213141516171819202122232425print(&#x27;\\nCalculating Accuracy of trained Classifier...&#x27;)confidence = clf.score(X_test,y_test)print(&#x27;\\nMaking Predictions on Validation Data...&#x27;)y_pred = clf.predict(X_test)print(&#x27;\\nCalculating Accuracy of Predictions...&#x27;)accuracy = accuracy_score(y_test, y_pred)print(&#x27;\\nCreating Confusion Matrix...&#x27;)conf_mat = confusion_matrix(y_test,y_pred)print(&#x27;\\nKNN Trained Classifier Confidence: &#x27;,confidence)print(&#x27;\\nPredicted Values: &#x27;,y_pred)print(&#x27;\\nAccuracy of Classifier on Validation Image Data: &#x27;,accuracy)print(&#x27;\\nConfusion Matrix: \\n&#x27;,conf_mat)# Plot Confusion Matrix Data as a Matrixplt.matshow(conf_mat)plt.title(&#x27;Confusion Matrix for Validation Data&#x27;)plt.colorbar()plt.ylabel(&#x27;True label&#x27;)plt.xlabel(&#x27;Predicted label&#x27;)plt.show() 输出结果：SVM Trained Classifier Accuracy: 0.9808333333333333Predicted Values: [3 3 3 ... 1 8 7]Accuracy of Classifier on Validation Images: 0.9808333333333333Confusion Matrix: [[599 0 2 0 0 1 2 0 0 0] [ 0 677 4 2 0 0 1 0 1 0] [ 1 1 585 1 0 0 1 6 1 1] [ 2 0 4 593 0 3 0 1 3 2] [ 1 0 1 0 560 0 0 0 2 4] [ 0 1 1 1 0 524 2 0 4 1] [ 3 0 0 0 1 2 545 0 0 0] [ 0 3 2 1 2 2 0 665 1 4] [ 3 2 1 5 1 4 3 0 545 2] [ 1 1 0 4 3 2 0 4 0 592]] 然后进行对已训练分类器的性能在测试数据集上的评估和预测： 代码解析： 使用已训练分类器对测试数据集进行预测。通过调用clf.predict(test_img)方法，得到分类器对测试数据集的预测结果，将其赋值给变量test_labels_pred。 计算已训练分类器在测试数据集上的准确率。通过调用accuracy_score(test_labels, test_labels_pred)方法，计算分类器在测试数据集上的预测准确率，将其赋值给变量acc。 创建并显示测试数据集的混淆矩阵。通过调用confusion_matrix(test_labels, test_labels_pred)方法，得到测试数据集的混淆矩阵，然后使用plt.matshow等函数绘制混淆矩阵的可视化。 具体代码： 123456789101112131415161718192021print(&#x27;\\nMaking Predictions on Test Input Images...&#x27;)test_labels_pred = clf.predict(test_img)print(&#x27;\\nCalculating Accuracy of Trained Classifier on Test Data... &#x27;)acc = accuracy_score(test_labels,test_labels_pred)print(&#x27;\\n Creating Confusion Matrix for Test Data...&#x27;)conf_mat_test = confusion_matrix(test_labels,test_labels_pred)print(&#x27;\\nPredicted Labels for Test Images: &#x27;,test_labels_pred)print(&#x27;\\nAccuracy of Classifier on Test Images: &#x27;,acc)print(&#x27;\\nConfusion Matrix for Test Data: \\n&#x27;,conf_mat_test)# Plot Confusion Matrix for Test Dataplt.matshow(conf_mat_test)plt.title(&#x27;Confusion Matrix for Test Data&#x27;)plt.colorbar()plt.ylabel(&#x27;True label&#x27;)plt.xlabel(&#x27;Predicted label&#x27;)plt.axis(&#x27;off&#x27;)plt.show() 输出结果：Predicted Labels for Test Images: [7 2 1 ... 4 5 6]Accuracy of Classifier on Test Images: 0.9783Confusion Matrix for Test Data: [[ 972 0 1 1 0 3 1 0 2 0] [ 0 1127 2 1 0 0 3 0 2 0] [ 5 1 1007 0 2 0 4 7 6 0] [ 0 2 2 985 0 7 0 4 6 4] [ 2 0 2 0 966 0 3 0 0 9] [ 2 0 2 11 1 863 4 1 5 3] [ 5 5 1 0 3 6 936 0 2 0] [ 0 10 9 1 1 0 0 1001 0 6] [ 6 0 1 3 2 4 2 3 951 2] [ 2 7 1 5 10 3 1 2 3 975]] 2.5 显示预测结果随机选择一些测试图像，将原始标签和预测标签显示在图像上，以便观察分类器的预测效果。 具体代码如下： 1234567# Show the Test Images with Original and Predicted Labelsa = np.random.randint(1,40,15)for i in a: two_d = (np.reshape(test_img[i], (28, 28)) * 255).astype(np.uint8) plt.title(&#x27;Original Label: &#123;0&#125; Predicted Label: &#123;1&#125;&#x27;.format(test_labels[i],test_labels_pred[i])) plt.imshow(two_d, interpolation=&#x27;nearest&#x27;,cmap=&#x27;gray&#x27;) plt.show() 输出效果如下： 3. 基于Random Forest Classifier实现3.1 相关库的导入12345678910import sysimport numpy as npimport picklefrom sklearn import model_selectionfrom sklearn.ensemble import RandomForestClassifierfrom sklearn.metrics import accuracy_score, confusion_matrixfrom MNIST_Dataset_Loader.mnist_loader import MNISTimport matplotlib.pyplot as pltfrom matplotlib import stylestyle.use(&#x27;ggplot&#x27;) 3.2 数据加载和准备1234567891011121314print(&#x27;\\nLoading MNIST Data...&#x27;)# data = MNIST(&#x27;./python-mnist/data/&#x27;)data = MNIST(&#x27;E:\\MNIST_Dataset_Loader\\dataset&#x27;)print(&#x27;\\nLoading Training Data...&#x27;)img_train, labels_train = data.load_training()train_img = np.array(img_train)train_labels = np.array(labels_train)print(&#x27;\\nLoading Testing Data...&#x27;)img_test, labels_test = data.load_testing()test_img = np.array(img_test)test_labels = np.array(labels_test) 代码解析： MNIST数据集是一个广泛使用的手写数字数据集，包含了大量的手写数字图像和相应的标签。 使用MNIST数据加载器加载训练数据和测试数据，并将其转换为NumPy数组。 3.3 创建和训练RFC分类器1234567891011121314151617#FeaturesX = train_img#Labelsy = train_labelsprint(&#x27;\\nPreparing Classifier Training and Validation Data...&#x27;)X_train, X_test, y_train, y_test = model_selection.train_test_split(X,y,test_size=0.1)print(&#x27;\\nKNN Classifier with n_neighbors = 5, algorithm = auto, n_jobs = 10&#x27;)print(&#x27;\\nPickling the Classifier for Future Use...&#x27;)clf = KNeighborsClassifier(n_neighbors=5,algorithm=&#x27;auto&#x27;,n_jobs=10)clf.fit(X_train,y_train)with open(&#x27;MNIST_KNN.pickle&#x27;,&#x27;wb&#x27;) as f: pickle.dump(clf, f) 代码解析： 使用train_test_split函数将训练数据划分为训练集和验证集。 使用KNeighborsClassifier类创建一个K最近邻分类器。 将训练图像作为特征（X）和对应的标签（y）传递给分类器，使用训练集对KNN分类器进行训练。 将训练好的分类器保存到文件中，以便将来使用。 3.4 验证和评估分类器在这部分代码中，首先使用pickle.load函数从文件中加载之前保存的KNN分类器对象。具体步骤如下： 打开文件MNIST_KNN.pickle，以二进制读取模式进行操作。&#39;rb&#39;表示以二进制读取模式打开文件。 使用pickle.load函数从文件中加载KNN分类器对象，并将其赋值给变量clf。具体代码如下：12pickle_in = open(&#x27;MNIST_KNN.pickle&#x27;,&#x27;rb&#x27;)clf = pickle.load(pickle_in) 接下来，先进行对已训练分类器的性能在验证数据集上的评估和预测： 代码解析： 计算已训练分类器在验证数据集上的准确率。通过调用clf.score(X_test, y_test)方法，得到分类器在验证数据集上的准确率，将其赋值给变量confidence。 使用已训练分类器对验证数据集进行预测。通过调用clf.predict(X_test)方法，得到分类器对验证数据集的预测结果，将其赋值给变量y_pred。 计算预测结果的准确率。通过调用accuracy_score(y_test, y_pred)方法，计算分类器的预测准确率，将其赋值给变量accuracy。 创建并显示验证数据集的混淆矩阵。通过调用confusion_matrix(y_test, y_pred)方法，得到验证数据集的混淆矩阵，然后使用plt.matshow等函数绘制混淆矩阵的可视化。 具体代码如下： 12345678910111213141516171819202122232425print(&#x27;\\nCalculating Accuracy of trained Classifier...&#x27;)confidence = clf.score(X_test,y_test)print(&#x27;\\nMaking Predictions on Validation Data...&#x27;)y_pred = clf.predict(X_test)print(&#x27;\\nCalculating Accuracy of Predictions...&#x27;)accuracy = accuracy_score(y_test, y_pred)print(&#x27;\\nCreating Confusion Matrix...&#x27;)conf_mat = confusion_matrix(y_test,y_pred)print(&#x27;\\nKNN Trained Classifier Confidence: &#x27;,confidence)print(&#x27;\\nPredicted Values: &#x27;,y_pred)print(&#x27;\\nAccuracy of Classifier on Validation Image Data: &#x27;,accuracy)print(&#x27;\\nConfusion Matrix: \\n&#x27;,conf_mat)# Plot Confusion Matrix Data as a Matrixplt.matshow(conf_mat)plt.title(&#x27;Confusion Matrix for Validation Data&#x27;)plt.colorbar()plt.ylabel(&#x27;True label&#x27;)plt.xlabel(&#x27;Predicted label&#x27;)plt.show() 输出结果：RFC Trained Classifier Confidence: 0.9695Predicted Values: [6 0 8 ... 7 3 1]Accuracy of Classifier on Validation Image Data: 0.9695Confusion Matrix: [[568 0 1 1 1 0 1 0 9 0] [ 0 692 1 1 2 0 0 1 0 0] [ 1 1 586 2 2 0 2 4 2 0] [ 3 0 7 572 2 4 1 2 6 1] [ 0 0 2 0 579 1 2 1 2 8] [ 1 0 0 11 3 520 3 0 2 4] [ 3 3 1 0 0 4 569 0 2 0] [ 0 4 6 0 4 0 0 561 1 2] [ 0 6 4 5 4 6 3 0 577 6] [ 5 1 0 6 6 0 0 2 1 593]] 然后进行对已训练分类器的性能在测试数据集上的评估和预测： 代码解析： 使用已训练分类器对测试数据集进行预测。通过调用clf.predict(test_img)方法，得到分类器对测试数据集的预测结果，将其赋值给变量test_labels_pred。 计算已训练分类器在测试数据集上的准确率。通过调用accuracy_score(test_labels, test_labels_pred)方法，计算分类器在测试数据集上的预测准确率，将其赋值给变量acc。 创建并显示测试数据集的混淆矩阵。通过调用confusion_matrix(test_labels, test_labels_pred)方法，得到测试数据集的混淆矩阵，然后使用plt.matshow等函数绘制混淆矩阵的可视化。 具体代码： 123456789101112131415161718192021print(&#x27;\\nMaking Predictions on Test Input Images...&#x27;)test_labels_pred = clf.predict(test_img)print(&#x27;\\nCalculating Accuracy of Trained Classifier on Test Data... &#x27;)acc = accuracy_score(test_labels,test_labels_pred)print(&#x27;\\n Creating Confusion Matrix for Test Data...&#x27;)conf_mat_test = confusion_matrix(test_labels,test_labels_pred)print(&#x27;\\nPredicted Labels for Test Images: &#x27;,test_labels_pred)print(&#x27;\\nAccuracy of Classifier on Test Images: &#x27;,acc)print(&#x27;\\nConfusion Matrix for Test Data: \\n&#x27;,conf_mat_test)# Plot Confusion Matrix for Test Dataplt.matshow(conf_mat_test)plt.title(&#x27;Confusion Matrix for Test Data&#x27;)plt.colorbar()plt.ylabel(&#x27;True label&#x27;)plt.xlabel(&#x27;Predicted label&#x27;)plt.axis(&#x27;off&#x27;)plt.show() 输出结果：Predicted Labels for Test Images: [7 2 1 ... 4 5 6]Accuracy of Classifier on Test Images: 0.9677Confusion Matrix for Test Data: [[ 968 0 0 0 0 2 5 1 4 0] [ 0 1124 3 3 1 2 1 0 1 0] [ 6 0 996 6 3 0 4 10 7 0] [ 0 0 11 971 0 8 0 9 7 4] [ 1 0 3 0 950 0 4 1 2 21] [ 4 0 1 9 3 859 5 2 8 1] [ 5 3 0 0 4 3 940 0 3 0] [ 1 3 17 1 0 0 0 991 3 12] [ 7 0 5 10 6 6 4 3 918 15] [ 6 6 3 13 10 3 1 3 4 960]] 3.5 显示预测结果随机选择一些测试图像，将原始标签和预测标签显示在图像上，以便观察分类器的预测效果。 具体代码如下： 1234567# Show the Test Images with Original and Predicted Labelsa = np.random.randint(1,50,20)for i in a: two_d = (np.reshape(test_img[i], (28, 28)) * 255).astype(np.uint8) plt.title(&#x27;Original Label: &#123;0&#125; Predicted Label: &#123;1&#125;&#x27;.format(test_labels[i],test_labels_pred[i])) plt.imshow(two_d, interpolation=&#x27;nearest&#x27;,cmap=&#x27;gray&#x27;) plt.show() 输出效果如下： 四、实验结果分别使用了K Nearest Neighbors、SVM以及Random Forest Classifier模型实现了手写体的识别。对比他们在测试集上的表现：K Nearest Neighbors：Accuracy of Classifier on Test Images: 0.9675SVM：Accuracy of Classifier on Test Images: 0.9783Random Forest Classifier：Accuracy of Classifier on Test Images: 0.9677由上述数据得出，SVM模型在手写体识别的测试集上具有最高的准确率。 五、实验分析此次实验，在三个模型上进行了手写体识别的准确率的评估，但在模型考察上较为单一，往后可以考虑用更多评价指标来对模型进行评估，以此获得更加全面的模型报告。 实验六一、实验目的(1)目的是建立一个模型，可以根据蘑菇的特征预测蘑菇的食用性。(2) 写出实验报告。 二、实验原理(1)支持向量机（SVM）： 支持向量机是一种监督学习算法，用于二分类和多分类问题。在手写体识别任务中，S和VM可以被用来将手写数字图像分为不同的类别。SVM通过寻找一个最优的超平面来将不同类别的数据点分开。对于手写数字识别，每个图像被表示为一组特征向量，并与相应的标签（数字类别）相关联。SVM通过学习一个决策边界，使得不同类别的图像在特征空间中被最大化地分离。 (2)K最近邻算法（K Nearest Neighbors）： K最近邻算法是一种基于实例的学习方法，用于分类和回归问题。对于手写体识别任务，K最近邻算法可以用于根据与目标图像最相似的K个训练样本的标签来预测目标图像的类别。算法通过计算目标图像与所有训练图像之间的距离（如欧氏距离）来确定最相似的训练样本，然后根据K个最相似样本的标签进行投票来确定目标图像的类别。 (3) 随机森林分类器（Random Forest Classifier）： 随机森林是一种集成学习方法，它由多个决策树组成。每个决策树都是基于不同的训练样本和特征子集构建的。在手写体识别任务中，随机森林分类器可以通过将图像的特征输入到每个决策树中，并将决策树的预测结果进行投票来确定图像的类别。随机森林具有良好的泛化能力和抗过拟合能力，并且在处理高维特征空间和大规模数据集时表现良好 三、实验内容和步骤(1)实验内容 用python编写程序，通过SVM、K Nearest Neighbors、Random Forest Classifier分别实现根据蘑菇的特征预测蘑菇的食用性 分别评估模型 (2)实验步骤 相关库的导入 预处理和数据分析 机器学习模型 具体步骤： 1. 相关库的导入12345678910111213141516171819202122232425262728293031323334353637383940import os #paths to fileimport numpy as np # linear algebraimport pandas as pd # data processingimport warnings# warning filter#ploting librariesimport matplotlib.pyplot as plt import seaborn as sns#feature engineeringfrom sklearn.preprocessing import OneHotEncoderfrom sklearn.preprocessing import LabelEncoder#train test splitfrom sklearn.model_selection import train_test_split#metricsfrom sklearn.metrics import f1_scorefrom sklearn.metrics import accuracy_scorefrom sklearn.metrics import recall_scorefrom sklearn.metrics import precision_scorefrom sklearn.model_selection import cross_validate#cross validationfrom sklearn.model_selection import cross_val_score as CVS#ML modelsfrom xgboost import XGBClassifierfrom sklearn.tree import DecisionTreeClassifierfrom sklearn.ensemble import RandomForestClassifierfrom sklearn.linear_model import LogisticRegressionfrom sklearn.svm import SVC#default theme and settingssns.set(context=&#x27;notebook&#x27;, style=&#x27;darkgrid&#x27;, palette=&#x27;deep&#x27;, font=&#x27;sans-serif&#x27;, font_scale=1, color_codes=False, rc=None)pd.set_option(&#x27;display.max_columns&#x27;, None)#warning handlewarnings.filterwarnings(&quot;always&quot;)warnings.filterwarnings(&quot;ignore&quot;) 2.预处理和数据分析2.1 导入数据与查看12Mushroom_df = pd.read_csv(Mushroom_path)Mushroom_df.head() 输出： 2.2 数据维度1&quot;Data Shape (row, col): &#123;&#125;&quot;.format(Mushroom_df.shape) 输出：Data Shape (row, col): (8124, 23) 2.3 数据基本信息1Mushroom_df.info() 输出： 2.4 缺失值处查看12#missing valuesMushroom_df.isnull().sum() 输出：可见，该数据集并无缺失值。 2.5 查看数据分布情况代码将遍历每一列并打印该列的值分布情况 1234M_cols = Mushroom_df.columns.to_list()print(&quot;Value Distribution:\\n&quot;)for col in M_cols: print(col,&quot;\\n&quot;,Mushroom_df[col].value_counts(),&quot;\\n\\n&quot;) 输出： 2.6 数据可视化Target PlotTarget Plot: 这是一种数据可视化技术，通常用于显示目标变量（也称为响应变量或因变量）的分布。帮助理解数据的平衡或不平衡，并可能影响选择的建模策略。 具体代码： 123456789total = float(len(Mushroom_df[M_cols[0]]))plt.figure(figsize=(6,6))sns.set(style=&quot;darkgrid&quot;)ax = sns.countplot(Mushroom_df[M_cols[0]])for p in ax.patches: height = p.get_height() ax.text(p.get_x()+p.get_width()/2.,height + 3,&#x27;&#123;:1.2f&#125;&#x27;.format(height/total),ha=&quot;center&quot;)plt.title(&quot;Target Plot&quot;, fontsize = 20)plt.show() 代码解析： total = float(len(Mushroom_df[M_cols[0]])): 这行代码计算了目标变量的总实例数。 plt.figure(figsize=(6,6)): 这行代码设置了图形的大小。 sns.set(style=&quot;darkgrid&quot;): 这行代码设置了 seaborn 图形的样式。 ax = sns.countplot(Mushroom_df[M_cols[0]]): 这行代码创建了一个 countplot，显示了目标变量的每个类别的实例数量。 for p in ax.patches: ...: 这个循环在每个条形图上方添加了一个文本，显示了该类别的实例数量占总实例数的百分比。 plt.title(&quot;Target Plot&quot;, fontsize = 20): 这行代码设置了图形的标题和字体大小。 plt.show(): 这行代码显示了图形。 输出： Univariate Plots Univariate Plots: 单变量图是一种数据可视化技术，用于显示单个变量（特征）的分布。这可以包括直方图、箱线图、密度图等。这些图可以帮助理解变量的中心趋势（如平均值或中位数）、离散度（如范围或四分位数范围）、形状（如偏度或峰度）以及任何潜在的异常值。 具体代码： 1234567for col in M_cols[1:]: plt.figure(figsize=(10,4)) sns.countplot(x=col , data=Mushroom_df ,palette=&#x27;icefire&#x27;) plt.title(col, fontsize=14) plt.show() print(&quot;% of total:&quot;) print(round((Mushroom_df[col].value_counts()/Mushroom_df.shape[0]),4)*100) 代码解析： for col in M_cols[1:]: ...: 这个循环对 M_cols 列表中的每个元素（除了第一个元素）执行以下操作。 plt.figure(figsize=(10,4)): 这行代码设置了图形的大小。 sns.countplot(x=col , data=Mushroom_df ,palette=&#39;icefire&#39;): 这行代码创建了一个 countplot，显示了给定特征的每个类别的实例数量。 plt.title(col, fontsize=14): 这行代码设置了图形的标题和字体大小。 plt.show(): 这行代码显示了图形。 print(&quot;% of total:&quot;): 这行代码打印了一个字符串，表示接下来的数字是总数的百分比。 print(round((Mushroom_df[col].value_counts()/Mushroom_df.shape[0]),4)*100): 这行代码计算了每个类别的实例数量占总实例数的百分比，并打印了结果。 上述代码创建了一系列的单变量图，显示每个特征的分布，并打印了每个类别的实例数量占总实例数的百分比，以下列出部分输出： 单变量分析（Unvariate Analisys）： cap-shape - 数据集中的大多数蘑菇都有凸形（45%）或平坦（38.8%）的帽子。 cap-surface - 最常见的帽子表面是鳞状的（39.93%），几乎没有沟槽（0.05%）。 cap-color - 数据集中超过一半的蘑菇有棕色（28.11%）或灰色（22.65%）的帽子颜色，我们还有8种其他颜色出现的频率较低。 bruises - 数据集中的大多数蘑菇都没有瘀伤（58.44%）。 odor - 最常见的气味（超过70%）要么没有气味（43.43%），要么有恶臭（26.59%）。 gill-attachment - 我们的数据中几乎所有的蘑菇都有自由的菌褶附着（约97.5%），所以这一列在我们的分析中几乎是无用的。 gill-spacing - 我们数据集中超过85%的蘑菇有紧密的菌褶间距，所以它在我们的分析中几乎没有影响。 gill-size - 我们数据集中的大多数蘑菇有宽的（69.08%）菌褶大小，其他的是窄的。 gill-color - 我们数据集中超过一半的蘑菇有浅黄色（21.27%）、粉红色（18.37%）或白色（22.65%）的菌褶颜色，我们还有9种其他颜色出现的频率较低。 stalk-shape - 我们数据集中的大多数蘑菇有锥形的（56.72%），其他的是扩大的。 stalk-root - 最常见的柄根（超过75%）要么是球状的（46.48%）要么是丝状的（30.53%）。 stalk-surface-above-ring - 最常见的环上柄表面（超过90%）要么是光滑的（63.71%）要么是丝状的（29.2%）。 stalk-surface-below-ring - 最常见的环下柄表面（几乎90%）要么是光滑的（60.76%）要么是丝状的（28.36%），与stalk-surface-above-ring几乎没有区别。 stalk-color-above-ring - 我们数据集中超过一半的蘑菇有白色（54.95%）的柄颜色，我们还有8种其他颜色出现的频率较低。 stalk-color-below-ring - 我们数据集中超过一半的蘑菇有白色（53.96%）的柄颜色，我们还有8种其他颜色出现的频率较低，与stalk-color-above-ring几乎没有区别。 veil-type - 所有蘑菇的面纱类型都是部分的，所以这一列在我们的分析中几乎是无用的。 veil-color - 几乎所有的蘑菇面纱颜色都是白色（97.54%），所以这一列在我们的分析中几乎是无用的。 ring-number - 几乎所有的蘑菇环数都是一个（92.17%），所以这一列在我们的分析中几乎是无用的。 ring-type - 我们数据集中超过98%的蘑菇有吊坠（48.84%）、短暂的（34.17%）或大的（15.95%）环类型。 spore-print-color - 最常见的颜色是白色（29.39%）、棕色（24.22%）、黑色（23.04%）和巧克力色（20.09%），其他颜色不重要。 population - 最常见的种群（超过70%）要么是多个（49.73%）要么是孤立的（21.07%）。 habitat - 最常见的栖息地（超过65%）要么是森林（38.75%）要么是草地（26.44%）。 Multivariate PlotsMultivariate Plots: 多变量图是一种数据可视化技术，用于显示两个或更多变量之间的关系。这可以包括散点图、相关矩阵、平行坐标图等。这些图可以帮助你理解变量之间的关系，例如它们是否有相关性或是否存在任何群集或异常值。 在本处，将对每个属性，结合目标类别（p，e）进行绘制柱状图。 具体代码： 123456for col in M_cols[1:]: plt.figure(figsize=(30,20)) plt.subplot(2,3,1) sns.countplot(x=col ,hue=&#x27;class&#x27;, data=Mushroom_df ,palette=&#x27;viridis_r&#x27;) plt.xlabel(col, fontsize=20) plt.legend(loc=&#x27;upper left&#x27;) 代码解析： for col in M_cols[1:]: ...: 这个循环对 M_cols 列表中的每个元素（除了第一个元素）执行以下操作。 plt.figure(figsize=(30,20)): 这行代码设置了图形的大小。 plt.subplot(2,3,1): 这行代码创建了一个子图，它是一个2行3列的网格中的第一个图。 sns.countplot(x=col ,hue=&#39;class&#39;, data=Mushroom_df ,palette=&#39;viridis_r&#39;): 这行代码创建了一个 countplot，显示了给定特征的每个类别的实例数量，并使用颜色来区分目标变量的类别。 plt.xlabel(col, fontsize=20): 这行代码设置了图形的 x 轴标签和字体大小。 plt.legend(loc=&#39;upper left&#39;): 这行代码添加了一个图例，并设置了它的位置。 上述代码创建了一系列的多变量条形图，显示每个特征与目标变量之间的关系，以下列出部分输出： 特征与目标变量关系的分析具体代码： 1[ pd.pivot_table(Mushroom_df, index=[col,&quot;class&quot;], aggfunc = &#123;col:np.count_nonzero&#125;) for col in M_cols[1:]] 代码解析： for col in M_cols[1:]: ...: 这个循环对 M_cols 列表中的每个元素（除了第一个元素）执行以下操作。 pd.pivot_table(Mushroom_df, index=[col,&quot;class&quot;], aggfunc = &#123;col:np.count_nonzero&#125;): 这行代码创建了一个透视表，其中行索引是给定特征和目标变量的类别，聚合函数是非零计数。 输出： 特征与目标变量分析（Multivariate Analisys）： cap-shape - 我们数据集中的大多数瘤状蘑菇都是有毒的。 cap-surface - 大多数纤维状帽面的蘑菇是可食用的。 cap-color - 大多数白色帽子的蘑菇是可食用的，而大多数黄色帽子的蘑菇是有毒的。 bruises - 有瘀伤的蘑菇通常是可食用的，而无瘀伤的蘑菇通常是相反的。 odor - 无气味的蘑菇大多是可食用的，而所有恶臭的蘑菇都是有毒的。 gill-attachment - 附着的菌褶几乎总是可食用的。 gill-spacing - 密集的菌褶几乎总是可食用的。 gill-size - 窄的菌褶大小的蘑菇几乎总是有毒的。 gill-color - 浅黄色菌褶颜色的蘑菇总是有毒的。 stalk-shape - 在有毒或可食用方面，每个值之间的差异不大。 stalk-root - 通常，柄根数据缺失的蘑菇通常是有毒的。 stalk-surface-above-ring - 通常，丝状的蘑菇是有毒的，光滑的通常是可食用的。 stalk-surface-below-ring - 与stalk-surface-above-ring大致相同。 stalk-color-above-ring - 通常，白色柄色的蘑菇是可食用的，粉红色的大多数是有毒的。 stalk-color-below-ring - 与stalk-color-above-ring大致相同。 veil-type - 所有蘑菇的面纱类型都是部分的，所以这一列在我们的分析中几乎是无用的。 veil-color - 几乎所有的蘑菇面纱颜色都是**白色 (97.54%)**，所以这一列在我们的分析中几乎是无用的。 ring-number - 几乎所有的蘑菇环数都是**一个 (92.17%)**，所以这一列在我们的分析中几乎是无用的。 ring-type - 吊坠环型的蘑菇大多是可食用的，短暂的大多是有毒的，大环型的都是有毒的。 spore-print-color - 棕色和黑色的几乎完全是可食用的，而白色和**巧克力色 (20.09%)**的大多数是有毒的。 population - 通常，多个种群的蘑菇大多是有毒的。 habitat - 在森林或草地生长的蘑菇大多是可食用的。 2.7 特征工程根据以上分析，不需要以下列，因此将删除它们：“鳃附着”、“茎形状”、“环下茎表面”、“圈下茎颜色”、“面纱类型”、“纱颜色”、”环编号“。所以现在将创建新的特征变量X，不包括上述列： 具体代码： 123456Del_cols = [&#x27;class&#x27;,&#x27;gill-attachment&#x27;, &#x27;stalk-shape&#x27;, &#x27;stalk-surface-below-ring&#x27;, &#x27;stalk-color-below-ring&#x27;, &#x27;veil-type&#x27;, &#x27;veil-color&#x27;, &#x27;ring-number&#x27;] X =Mushroom_df.copy()for col in Del_cols: X = X.drop(col, axis = 1)X=pd.get_dummies(X,columns=X.columns,drop_first=True)X.head(2) 输出： 创建目标变量y，并将其转换为相应格式（0、1） 1234y = Mushroom_df[&#x27;class&#x27;]Encoder_y=LabelEncoder()y = Encoder_y.fit_transform(y)y 输出：array([1, 0, 0, ..., 0, 1, 0]) 3. 机器学习模型前言：将“X”作为特征，将“y”作为“类”——想要预测的目标值。这是一个分类问题，所以使用分类的方法。训练集和测试集的遍历为75:25 将使用的模型：逻辑回归（Logistic Regression）决策树分类器（Decision Tree Classifier）随机森林回归器（Random Forest Regressor）XGBoost分类器（XGBoost Classifier）支持向量机（Support Vector Machines） 数据建模过程：1.导入模型2.训练模型3.预测4.分类指标评估 分类评分指标：准确度：$$Accuracy&#x3D;\\frac{TP+TN}{TP+TN+FP+FN}$$ 精确性：$$Precision&#x3D;\\frac{TP}{TP+FP}$$召回度：$$Recall&#x3D;\\frac{TP}{TP+FN}$$f1分数：-介于0和1之间的数字，即精度和查全率的调和平均值。$$F_1&#x3D;2\\frac{precisionrecall}{precison+recall}$$ 3.1 划分数据集1X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.75, random_state = 101) 为了提高评估方法的准确性，需要使用交叉验证方法，对每个模型使用该方法，并构建一个分类报告，用于对模型的最终排名进行排名和确定。具体代码： 12345678910def cross_val(model_name,model,X,y,cv): scores = CVS(model, X, y, cv=cv) print(f&#x27;&#123;model_name&#125; Scores:&#x27;) for i in scores: print(round(i,2)) print(f&#x27;Average &#123;model_name&#125; score: &#123;round(scores.mean(),4)&#125;&#x27;)index = [&#x27;Valid1&#x27;,&#x27;Valid2&#x27;,&#x27;Valid3&#x27;,&#x27;Valid4&#x27;,&#x27;Valid5&#x27;]scoring = [&#x27;accuracy&#x27;,&#x27;precision&#x27;, &#x27;recall&#x27;,&#x27;f1&#x27;] 3.2 逻辑回归（Logistic Regression）具体代码： 123456789101112131415161718192021#modelLR = LogisticRegression()#cross validationLR_report = pd.DataFrame(cross_validate(LR, X, y, scoring=scoring))#getting required score methodsLR_report = LR_report.iloc[:,2:]#naming the columnsLR_report.columns = scoring#naming the indexLR_report.index = index#final result collectionmodel_1 = []#Classification reportprint(&quot;Clasification report:\\n&quot;)print(LR_report,&quot;\\n\\n&quot;)print(&quot;Mean Scores:\\n&quot;)for score in scoring: print(f&quot;\\t&#123;score&#125;: &#123;round(LR_report[score].mean(),4)&#125;&quot;) model_1.append(round(LR_report[score].mean(),4)) 代码解析： LR = LogisticRegression(): 创建一个逻辑回归模型的实例。 LR_report = pd.DataFrame(cross_validate(LR, X, y, scoring=scoring)): 使用交叉验证来评估模型的性能。cross_validate 函数返回一个字典，其中包含每次交叉验证的结果。这个字典被转换成一个 DataFrame。 LR_report = LR_report.iloc[:,2:]: 选择DataFrame 中的一部分列。 LR_report.columns = scoring 和 LR_report.index = index: 设置了DataFrame 的列名和行名。 model_1 = []: 创建一个空列表，用于收集模型的平均分数。 最后，打印每个评分指标的结果，并计算它们的平均值。这些平均值被添加到了 model_1 列表中。 输出： 预测结果保存： 12345#sample prediction for csv fileLR.fit(X_train, y_train)#trainingy_predict = LR.predict(X_test)#predictingLogistic_Regression=pd.DataFrame(&#123;&#x27;y_test&#x27;:y_test,&#x27;prediction&#x27;:y_predict&#125;)#df for camparisonLogistic_Regression.to_csv(&quot;Logistic Regression.csv&quot;)#export to csv 3.3 决策树分类器（Decision Tree Classifier）具体代码： 123456789101112131415161718192021#modelDT = DecisionTreeClassifier()#cross validationDT_report = pd.DataFrame(cross_validate(DT, X, y, scoring=scoring))#getting required score methodsDT_report = DT_report.iloc[:,2:]#naming the columnsDT_report.columns = scoring#naming the indexDT_report.index = index#final result collectionmodel_2 = []#Classification reportprint(&quot;Clasification report:\\n&quot;)print(DT_report,&quot;\\n\\n&quot;)print(&quot;Mean Scores:\\n&quot;)for score in scoring: print(f&quot;\\t&#123;score&#125;: &#123;round(DT_report[score].mean(),4)&#125;&quot;) model_2.append(round(DT_report[score].mean(),4)) 代码解析： DT = DecisionTreeClassifier(): 创建一个决策树分类器的实例。 DT_report = pd.DataFrame(cross_validate(DT, X, y, scoring=scoring)): 使用交叉验证来评估模型的性能。cross_validate 函数返回一个字典，其中包含了每次交叉验证的结果。这个字典被转换成一个 DataFrame。 DT_report = DT_report.iloc[:,2:]: 选择 DataFrame 中的一部分列。 DT_report.columns = scoring 和 DT_report.index = index: 设置 DataFrame 的列名和行名。 model_2 = []: 创建一个空列表，用于收集模型的平均分数。 最后，打印每个评分指标的结果，并计算它们的平均值。这些平均值被添加到了 model_2 列表中。 输出： 预测结果保存： 12345#sample prediction for csv fileDT.fit(X_train, y_train)#trainingy_predict = DT.predict(X_test)#predictingDecision_Tree=pd.DataFrame(&#123;&#x27;y_test&#x27;:y_test,&#x27;prediction&#x27;:y_predict&#125;)#df for camparisonDecision_Tree.to_csv(&quot;Decision Tree.csv&quot;)#export to csv 3.4 随机森林回归器（Random Forest Regressor）具体代码： 123456789101112131415161718192021#modelRF = RandomForestClassifier()#cross validationRF_report = pd.DataFrame(cross_validate(RF, X, y, scoring=scoring))#getting required score methodsRF_report = RF_report.iloc[:,2:]#naming the columnsRF_report.columns = scoring#naming the indexRF_report.index = index#final result collectionmodel_3 = []#Classification reportprint(&quot;Clasification report:\\n&quot;)print(RF_report,&quot;\\n\\n&quot;)print(&quot;Mean Scores:\\n&quot;)for score in scoring: print(f&quot;\\t&#123;score&#125;: &#123;round(RF_report[score].mean(),4)&#125;&quot;) model_3.append(round(RF_report[score].mean(),4)) 代码解析： RF = RandomForestClassifier(): 创建一个随机森林分类器的实例。 RF_report = pd.DataFrame(cross_validate(RF, X, y, scoring=scoring)): 使用交叉验证来评估模型的性能。cross_validate 函数返回一个字典，其中包含每次交叉验证的结果。这个字典被转换成一个 DataFrame。 RF_report = RF_report.iloc[:,2:]: 选择 DataFrame 中的一部分列。 RF_report.columns = scoring 和 RF_report.index = index: 设置DataFrame 的列名和行名。 model_3 = []: 创建一个空列表，用于收集模型的平均分数。 最后，这段代码打印每个评分指标的结果，并计算它们的平均值。这些平均值被添加到了 model_3列表中。 输出： 预测结果保存： 12345#sample prediction for csv fileRF.fit(X_train, y_train)#trainingy_predict = RF.predict(X_test)#predictingRandom_Forest = pd.DataFrame(&#123;&#x27;y_test&#x27;:y_test,&#x27;prediction&#x27;:y_predict&#125;)#df for camparisonRandom_Forest.to_csv(&quot;Random Forest.csv&quot;)#export to csv 3.5 XGBoost分类器（XGBoost Classifier）具体代码： 123456789101112131415161718192021#modelXGB = XGBClassifier()#cross validationXGB_report = pd.DataFrame(cross_validate(XGB, X, y, scoring=scoring))#getting required score methodsXGB_report = XGB_report.iloc[:,2:]#naming the columnsXGB_report.columns = scoring#naming the indexXGB_report.index = index#final result collectionmodel_4 = []#Classification reportprint(&quot;Clasification report:\\n&quot;)print(XGB_report,&quot;\\n\\n&quot;)print(&quot;Mean Scores:\\n&quot;)for score in scoring: print(f&quot;\\t&#123;score&#125;: &#123;round(XGB_report[score].mean(),4)&#125;&quot;) model_4.append(round(XGB_report[score].mean(),4)) 代码解析： XGB = XGBClassifier(): 创建一个XGBoost分类器的实例。 XGB_report = pd.DataFrame(cross_validate(XGB, X, y, scoring=scoring)): 使用交叉验证来评估模型的性能。cross_validate 函数返回一个字典，其中包含每次交叉验证的结果。这个字典被转换成一个 DataFrame。 XGB_report = XGB_report.iloc[:,2:]:选择 DataFrame 中的一部分列。 XGB_report.columns = scoring 和 XGB_report.index = index: 设置DataFrame 的列名和行名。 model_4 = []: 创建一个空列表，用于收集模型的平均分数。 最后，这段代码打印每个评分指标的结果，并计算它们的平均值。这些平均值被添加到了 model_4 列表中。 输出： 预测结果保存： 12345#sample prediction for csv fileXGB.fit(X_train, y_train)#trainingy_predict = XGB.predict(X_test)#predictingXGBoost=pd.DataFrame(&#123;&#x27;y_test&#x27;:y_test,&#x27;prediction&#x27;:y_predict&#125;)#df for camparisonXGBoost.to_csv(&quot;XGBoost.csv&quot;)#export to csv 3.6 支持向量机（Support Vector Machines）具体代码： 12345678910111213141516171819202122#modelSVM = SVC(kernel = &#x27;linear&#x27;)#cross validationSVM_report = pd.DataFrame(cross_validate(SVM, X, y, scoring=scoring))#getting required score methodsSVM_report = SVM_report.iloc[:,2:]#naming the columnsSVM_report.columns = scoring#naming the indexSVM_report.index = index#final result collectionmodel_5 = []#Classification reportprint(&quot;Clasification report:\\n&quot;)print(SVM_report,&quot;\\n\\n&quot;)print(&quot;Mean Scores:\\n&quot;)for score in scoring: print(f&quot;\\t&#123;score&#125;: &#123;round(SVM_report[score].mean(),4)&#125;&quot;) model_5.append(round(SVM_report[score].mean(),4)) 代码解析： SVM = SVC(kernel = &#39;linear&#39;): 创建一个支持向量机的实例。这里使用的是线性核函数。 SVM_report = pd.DataFrame(cross_validate(SVM, X, y, scoring=scoring)): 使用交叉验证来评估模型的性能。cross_validate 函数返回一个字典，其中包含每次交叉验证的结果。这个字典被转换成一个 DataFrame。 SVM_report = SVM_report.iloc[:,2:]:选择 DataFrame 中的一部分列。 SVM_report.columns = scoring 和 SVM_report.index = index: 设置DataFrame 的列名和行名。 model_5 = []: 这行代码创建一个空列表，用于收集模型的平均分数。 最后，这段代码打印每个评分指标的结果，并计算它们的平均值。这些平均值被添加到了 model_5 列表中。 输出： 预测结果保存： 12345#sample prediction for csv fileSVM.fit(X_train, y_train)#trainingy_predict = SVM.predict(X_test)#predictingSupport_Vector_Machines=pd.DataFrame(&#123;&#x27;y_test&#x27;:y_test,&#x27;prediction&#x27;:y_predict&#125;)#df for camparisonSupport_Vector_Machines.to_csv(&quot;Support Vector Machines.csv&quot;)#export to csv 四、实验结果通过上述步骤，获得了上述模型的相关性能，现在对它们进行比较，将它们并排显示，并比较不同模型的表现。 123456789Models = pd.DataFrame(&#123; &#x27;Logistic Regression&#x27;: np.array(model_1), &#x27;Decision Tree&#x27;: np.array(model_2), &#x27;Random Forest&#x27;: np.array(model_3), &#x27;XGBoost&#x27;: np.array(model_4), &#x27;Support Vector Machines&#x27;: np.array(model_5)&#125;)Models.index = scoring#Models.sort_values(by=&#x27;Score&#x27;, ascending=False)Models 输出：由以上报告可以得出，在本数据集上，Logistic Regression模型以及XGBoost模型表现得较为优秀。 具体排名：ranking:accuracy - 1. XGBoost 2. Logistic Regression 3. Random Forest 4. Decision Tree 5. Support Vector Machines precision - 1. XGBoost 2. Logistic Regression 3. Random Forest 4. Decision Tree 5. Support Vector Machines recall - 1. Logistic Regression 2. Random Forest 3. Decision Tree 4. XGBoost 5. Support Vector Machines f1 - 1. XGBoost 2. Logistic Regression 3. Random Forest 4. Decision Tree 5. Support Vector Machines final ranking: XGBoost Logistic Regression Random Forest Decision Tree Support Vector Machines 五、实验分析此次实验，针对本数据集使用了多个模型进行训练以及评估，同时也采用了包括accuracy、precision、recall、f1等多种模型评估指标，使得本次实验的模型对比较为全面，也更为严谨。","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"数据挖掘","slug":"课程笔记/数据挖掘","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"},{"name":"实验报告","slug":"课程笔记/数据挖掘/实验报告","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"}],"tags":[]},{"title":"","slug":"课程笔记/数据挖掘/实验报告/实验六 蘑菇识别项目Mushroom Classification Project_","date":"2023-06-04T12:23:38.547Z","updated":"2023-09-20T08:42:18.850Z","comments":true,"path":"2023/06/5879215f93d2.html","link":"","permalink":"http://example.com/2023/06/5879215f93d2.html","excerpt":"","text":"一、实验目的(1)目的是建立一个模型，可以根据蘑菇的特征预测蘑菇的食用性。(2) 写出实验报告。 二、实验原理(1)支持向量机（SVM）： 支持向量机是一种监督学习算法，用于二分类和多分类问题。在手写体识别任务中，S和VM可以被用来将手写数字图像分为不同的类别。SVM通过寻找一个最优的超平面来将不同类别的数据点分开。对于手写数字识别，每个图像被表示为一组特征向量，并与相应的标签（数字类别）相关联。SVM通过学习一个决策边界，使得不同类别的图像在特征空间中被最大化地分离。 (2)K最近邻算法（K Nearest Neighbors）： K最近邻算法是一种基于实例的学习方法，用于分类和回归问题。对于手写体识别任务，K最近邻算法可以用于根据与目标图像最相似的K个训练样本的标签来预测目标图像的类别。算法通过计算目标图像与所有训练图像之间的距离（如欧氏距离）来确定最相似的训练样本，然后根据K个最相似样本的标签进行投票来确定目标图像的类别。 (3) 随机森林分类器（Random Forest Classifier）： 随机森林是一种集成学习方法，它由多个决策树组成。每个决策树都是基于不同的训练样本和特征子集构建的。在手写体识别任务中，随机森林分类器可以通过将图像的特征输入到每个决策树中，并将决策树的预测结果进行投票来确定图像的类别。随机森林具有良好的泛化能力和抗过拟合能力，并且在处理高维特征空间和大规模数据集时表现良好 三、实验内容和步骤(1)实验内容 用python编写程序，通过SVM、K Nearest Neighbors、Random Forest Classifier分别实现根据蘑菇的特征预测蘑菇的食用性 分别评估模型 (2)实验步骤 相关库的导入 预处理和数据分析 机器学习模型 具体步骤： 1. 相关库的导入12345678910111213141516171819202122232425262728293031323334353637383940import os #paths to fileimport numpy as np # linear algebraimport pandas as pd # data processingimport warnings# warning filter#ploting librariesimport matplotlib.pyplot as plt import seaborn as sns#feature engineeringfrom sklearn.preprocessing import OneHotEncoderfrom sklearn.preprocessing import LabelEncoder#train test splitfrom sklearn.model_selection import train_test_split#metricsfrom sklearn.metrics import f1_scorefrom sklearn.metrics import accuracy_scorefrom sklearn.metrics import recall_scorefrom sklearn.metrics import precision_scorefrom sklearn.model_selection import cross_validate#cross validationfrom sklearn.model_selection import cross_val_score as CVS#ML modelsfrom xgboost import XGBClassifierfrom sklearn.tree import DecisionTreeClassifierfrom sklearn.ensemble import RandomForestClassifierfrom sklearn.linear_model import LogisticRegressionfrom sklearn.svm import SVC#default theme and settingssns.set(context=&#x27;notebook&#x27;, style=&#x27;darkgrid&#x27;, palette=&#x27;deep&#x27;, font=&#x27;sans-serif&#x27;, font_scale=1, color_codes=False, rc=None)pd.set_option(&#x27;display.max_columns&#x27;, None)#warning handlewarnings.filterwarnings(&quot;always&quot;)warnings.filterwarnings(&quot;ignore&quot;) 2.预处理和数据分析2.1 导入数据与查看12Mushroom_df = pd.read_csv(Mushroom_path)Mushroom_df.head() 输出： 2.2 数据维度1&quot;Data Shape (row, col): &#123;&#125;&quot;.format(Mushroom_df.shape) 输出：Data Shape (row, col): (8124, 23) 2.3 数据基本信息1Mushroom_df.info() 输出： 2.4 缺失值处查看12#missing valuesMushroom_df.isnull().sum() 输出：可见，该数据集并无缺失值。 2.5 查看数据分布情况代码将遍历每一列并打印该列的值分布情况 1234M_cols = Mushroom_df.columns.to_list()print(&quot;Value Distribution:\\n&quot;)for col in M_cols: print(col,&quot;\\n&quot;,Mushroom_df[col].value_counts(),&quot;\\n\\n&quot;) 输出： 2.6 数据可视化Target PlotTarget Plot: 这是一种数据可视化技术，通常用于显示目标变量（也称为响应变量或因变量）的分布。帮助理解数据的平衡或不平衡，并可能影响选择的建模策略。 具体代码： 123456789total = float(len(Mushroom_df[M_cols[0]]))plt.figure(figsize=(6,6))sns.set(style=&quot;darkgrid&quot;)ax = sns.countplot(Mushroom_df[M_cols[0]])for p in ax.patches: height = p.get_height() ax.text(p.get_x()+p.get_width()/2.,height + 3,&#x27;&#123;:1.2f&#125;&#x27;.format(height/total),ha=&quot;center&quot;)plt.title(&quot;Target Plot&quot;, fontsize = 20)plt.show() 代码解析： total = float(len(Mushroom_df[M_cols[0]])): 这行代码计算了目标变量的总实例数。 plt.figure(figsize=(6,6)): 这行代码设置了图形的大小。 sns.set(style=&quot;darkgrid&quot;): 这行代码设置了 seaborn 图形的样式。 ax = sns.countplot(Mushroom_df[M_cols[0]]): 这行代码创建了一个 countplot，显示了目标变量的每个类别的实例数量。 for p in ax.patches: ...: 这个循环在每个条形图上方添加了一个文本，显示了该类别的实例数量占总实例数的百分比。 plt.title(&quot;Target Plot&quot;, fontsize = 20): 这行代码设置了图形的标题和字体大小。 plt.show(): 这行代码显示了图形。 输出： Univariate Plots Univariate Plots: 单变量图是一种数据可视化技术，用于显示单个变量（特征）的分布。这可以包括直方图、箱线图、密度图等。这些图可以帮助理解变量的中心趋势（如平均值或中位数）、离散度（如范围或四分位数范围）、形状（如偏度或峰度）以及任何潜在的异常值。 具体代码： 1234567for col in M_cols[1:]: plt.figure(figsize=(10,4)) sns.countplot(x=col , data=Mushroom_df ,palette=&#x27;icefire&#x27;) plt.title(col, fontsize=14) plt.show() print(&quot;% of total:&quot;) print(round((Mushroom_df[col].value_counts()/Mushroom_df.shape[0]),4)*100) 代码解析： for col in M_cols[1:]: ...: 这个循环对 M_cols 列表中的每个元素（除了第一个元素）执行以下操作。 plt.figure(figsize=(10,4)): 这行代码设置了图形的大小。 sns.countplot(x=col , data=Mushroom_df ,palette=&#39;icefire&#39;): 这行代码创建了一个 countplot，显示了给定特征的每个类别的实例数量。 plt.title(col, fontsize=14): 这行代码设置了图形的标题和字体大小。 plt.show(): 这行代码显示了图形。 print(&quot;% of total:&quot;): 这行代码打印了一个字符串，表示接下来的数字是总数的百分比。 print(round((Mushroom_df[col].value_counts()/Mushroom_df.shape[0]),4)*100): 这行代码计算了每个类别的实例数量占总实例数的百分比，并打印了结果。 上述代码创建了一系列的单变量图，显示每个特征的分布，并打印了每个类别的实例数量占总实例数的百分比，以下列出部分输出： 单变量分析（Unvariate Analisys）： cap-shape - 数据集中的大多数蘑菇都有凸形（45%）或平坦（38.8%）的帽子。 cap-surface - 最常见的帽子表面是鳞状的（39.93%），几乎没有沟槽（0.05%）。 cap-color - 数据集中超过一半的蘑菇有棕色（28.11%）或灰色（22.65%）的帽子颜色，我们还有8种其他颜色出现的频率较低。 bruises - 数据集中的大多数蘑菇都没有瘀伤（58.44%）。 odor - 最常见的气味（超过70%）要么没有气味（43.43%），要么有恶臭（26.59%）。 gill-attachment - 我们的数据中几乎所有的蘑菇都有自由的菌褶附着（约97.5%），所以这一列在我们的分析中几乎是无用的。 gill-spacing - 我们数据集中超过85%的蘑菇有紧密的菌褶间距，所以它在我们的分析中几乎没有影响。 gill-size - 我们数据集中的大多数蘑菇有宽的（69.08%）菌褶大小，其他的是窄的。 gill-color - 我们数据集中超过一半的蘑菇有浅黄色（21.27%）、粉红色（18.37%）或白色（22.65%）的菌褶颜色，我们还有9种其他颜色出现的频率较低。 stalk-shape - 我们数据集中的大多数蘑菇有锥形的（56.72%），其他的是扩大的。 stalk-root - 最常见的柄根（超过75%）要么是球状的（46.48%）要么是丝状的（30.53%）。 stalk-surface-above-ring - 最常见的环上柄表面（超过90%）要么是光滑的（63.71%）要么是丝状的（29.2%）。 stalk-surface-below-ring - 最常见的环下柄表面（几乎90%）要么是光滑的（60.76%）要么是丝状的（28.36%），与stalk-surface-above-ring几乎没有区别。 stalk-color-above-ring - 我们数据集中超过一半的蘑菇有白色（54.95%）的柄颜色，我们还有8种其他颜色出现的频率较低。 stalk-color-below-ring - 我们数据集中超过一半的蘑菇有白色（53.96%）的柄颜色，我们还有8种其他颜色出现的频率较低，与stalk-color-above-ring几乎没有区别。 veil-type - 所有蘑菇的面纱类型都是部分的，所以这一列在我们的分析中几乎是无用的。 veil-color - 几乎所有的蘑菇面纱颜色都是白色（97.54%），所以这一列在我们的分析中几乎是无用的。 ring-number - 几乎所有的蘑菇环数都是一个（92.17%），所以这一列在我们的分析中几乎是无用的。 ring-type - 我们数据集中超过98%的蘑菇有吊坠（48.84%）、短暂的（34.17%）或大的（15.95%）环类型。 spore-print-color - 最常见的颜色是白色（29.39%）、棕色（24.22%）、黑色（23.04%）和巧克力色（20.09%），其他颜色不重要。 population - 最常见的种群（超过70%）要么是多个（49.73%）要么是孤立的（21.07%）。 habitat - 最常见的栖息地（超过65%）要么是森林（38.75%）要么是草地（26.44%）。 Multivariate PlotsMultivariate Plots: 多变量图是一种数据可视化技术，用于显示两个或更多变量之间的关系。这可以包括散点图、相关矩阵、平行坐标图等。这些图可以帮助你理解变量之间的关系，例如它们是否有相关性或是否存在任何群集或异常值。 在本处，将对每个属性，结合目标类别（p，e）进行绘制柱状图。 具体代码： 123456for col in M_cols[1:]: plt.figure(figsize=(30,20)) plt.subplot(2,3,1) sns.countplot(x=col ,hue=&#x27;class&#x27;, data=Mushroom_df ,palette=&#x27;viridis_r&#x27;) plt.xlabel(col, fontsize=20) plt.legend(loc=&#x27;upper left&#x27;) 代码解析： for col in M_cols[1:]: ...: 这个循环对 M_cols 列表中的每个元素（除了第一个元素）执行以下操作。 plt.figure(figsize=(30,20)): 这行代码设置了图形的大小。 plt.subplot(2,3,1): 这行代码创建了一个子图，它是一个2行3列的网格中的第一个图。 sns.countplot(x=col ,hue=&#39;class&#39;, data=Mushroom_df ,palette=&#39;viridis_r&#39;): 这行代码创建了一个 countplot，显示了给定特征的每个类别的实例数量，并使用颜色来区分目标变量的类别。 plt.xlabel(col, fontsize=20): 这行代码设置了图形的 x 轴标签和字体大小。 plt.legend(loc=&#39;upper left&#39;): 这行代码添加了一个图例，并设置了它的位置。 上述代码创建了一系列的多变量条形图，显示每个特征与目标变量之间的关系，以下列出部分输出： 特征与目标变量关系的分析具体代码： 1[ pd.pivot_table(Mushroom_df, index=[col,&quot;class&quot;], aggfunc = &#123;col:np.count_nonzero&#125;) for col in M_cols[1:]] 代码解析： for col in M_cols[1:]: ...: 这个循环对 M_cols 列表中的每个元素（除了第一个元素）执行以下操作。 pd.pivot_table(Mushroom_df, index=[col,&quot;class&quot;], aggfunc = &#123;col:np.count_nonzero&#125;): 这行代码创建了一个透视表，其中行索引是给定特征和目标变量的类别，聚合函数是非零计数。 输出： 特征与目标变量分析（Multivariate Analisys）： cap-shape - 我们数据集中的大多数瘤状蘑菇都是有毒的。 cap-surface - 大多数纤维状帽面的蘑菇是可食用的。 cap-color - 大多数白色帽子的蘑菇是可食用的，而大多数黄色帽子的蘑菇是有毒的。 bruises - 有瘀伤的蘑菇通常是可食用的，而无瘀伤的蘑菇通常是相反的。 odor - 无气味的蘑菇大多是可食用的，而所有恶臭的蘑菇都是有毒的。 gill-attachment - 附着的菌褶几乎总是可食用的。 gill-spacing - 密集的菌褶几乎总是可食用的。 gill-size - 窄的菌褶大小的蘑菇几乎总是有毒的。 gill-color - 浅黄色菌褶颜色的蘑菇总是有毒的。 stalk-shape - 在有毒或可食用方面，每个值之间的差异不大。 stalk-root - 通常，柄根数据缺失的蘑菇通常是有毒的。 stalk-surface-above-ring - 通常，丝状的蘑菇是有毒的，光滑的通常是可食用的。 stalk-surface-below-ring - 与stalk-surface-above-ring大致相同。 stalk-color-above-ring - 通常，白色柄色的蘑菇是可食用的，粉红色的大多数是有毒的。 stalk-color-below-ring - 与stalk-color-above-ring大致相同。 veil-type - 所有蘑菇的面纱类型都是部分的，所以这一列在我们的分析中几乎是无用的。 veil-color - 几乎所有的蘑菇面纱颜色都是**白色 (97.54%)**，所以这一列在我们的分析中几乎是无用的。 ring-number - 几乎所有的蘑菇环数都是**一个 (92.17%)**，所以这一列在我们的分析中几乎是无用的。 ring-type - 吊坠环型的蘑菇大多是可食用的，短暂的大多是有毒的，大环型的都是有毒的。 spore-print-color - 棕色和黑色的几乎完全是可食用的，而白色和**巧克力色 (20.09%)**的大多数是有毒的。 population - 通常，多个种群的蘑菇大多是有毒的。 habitat - 在森林或草地生长的蘑菇大多是可食用的。 2.7 特征工程根据以上分析，不需要以下列，因此将删除它们：“鳃附着”、“茎形状”、“环下茎表面”、“圈下茎颜色”、“面纱类型”、“纱颜色”、”环编号“。所以现在将创建新的特征变量X，不包括上述列： 具体代码： 123456Del_cols = [&#x27;class&#x27;,&#x27;gill-attachment&#x27;, &#x27;stalk-shape&#x27;, &#x27;stalk-surface-below-ring&#x27;, &#x27;stalk-color-below-ring&#x27;, &#x27;veil-type&#x27;, &#x27;veil-color&#x27;, &#x27;ring-number&#x27;] X =Mushroom_df.copy()for col in Del_cols: X = X.drop(col, axis = 1)X=pd.get_dummies(X,columns=X.columns,drop_first=True)X.head(2) 输出： 创建目标变量y，并将其转换为相应格式（0、1） 1234y = Mushroom_df[&#x27;class&#x27;]Encoder_y=LabelEncoder()y = Encoder_y.fit_transform(y)y 输出：array([1, 0, 0, ..., 0, 1, 0]) 3. 机器学习模型前言：将“X”作为特征，将“y”作为“类”——想要预测的目标值。这是一个分类问题，所以使用分类的方法。训练集和测试集的遍历为75:25 将使用的模型：逻辑回归（Logistic Regression）决策树分类器（Decision Tree Classifier）随机森林回归器（Random Forest Regressor）XGBoost分类器（XGBoost Classifier）支持向量机（Support Vector Machines） 数据建模过程：1.导入模型2.训练模型3.预测4.分类指标评估 分类评分指标：准确度：$$Accuracy&#x3D;\\frac{TP+TN}{TP+TN+FP+FN}$$ 精确性：$$Precision&#x3D;\\frac{TP}{TP+FP}$$召回度：$$Recall&#x3D;\\frac{TP}{TP+FN}$$f1分数：-介于0和1之间的数字，即精度和查全率的调和平均值。$$F_1&#x3D;2\\frac{precisionrecall}{precison+recall}$$ 3.1 划分数据集1X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.75, random_state = 101) 为了提高评估方法的准确性，需要使用交叉验证方法，对每个模型使用该方法，并构建一个分类报告，用于对模型的最终排名进行排名和确定。具体代码： 12345678910def cross_val(model_name,model,X,y,cv): scores = CVS(model, X, y, cv=cv) print(f&#x27;&#123;model_name&#125; Scores:&#x27;) for i in scores: print(round(i,2)) print(f&#x27;Average &#123;model_name&#125; score: &#123;round(scores.mean(),4)&#125;&#x27;)index = [&#x27;Valid1&#x27;,&#x27;Valid2&#x27;,&#x27;Valid3&#x27;,&#x27;Valid4&#x27;,&#x27;Valid5&#x27;]scoring = [&#x27;accuracy&#x27;,&#x27;precision&#x27;, &#x27;recall&#x27;,&#x27;f1&#x27;] 3.2 逻辑回归（Logistic Regression）具体代码： 123456789101112131415161718192021#modelLR = LogisticRegression()#cross validationLR_report = pd.DataFrame(cross_validate(LR, X, y, scoring=scoring))#getting required score methodsLR_report = LR_report.iloc[:,2:]#naming the columnsLR_report.columns = scoring#naming the indexLR_report.index = index#final result collectionmodel_1 = []#Classification reportprint(&quot;Clasification report:\\n&quot;)print(LR_report,&quot;\\n\\n&quot;)print(&quot;Mean Scores:\\n&quot;)for score in scoring: print(f&quot;\\t&#123;score&#125;: &#123;round(LR_report[score].mean(),4)&#125;&quot;) model_1.append(round(LR_report[score].mean(),4)) 代码解析： LR = LogisticRegression(): 创建一个逻辑回归模型的实例。 LR_report = pd.DataFrame(cross_validate(LR, X, y, scoring=scoring)): 使用交叉验证来评估模型的性能。cross_validate 函数返回一个字典，其中包含每次交叉验证的结果。这个字典被转换成一个 DataFrame。 LR_report = LR_report.iloc[:,2:]: 选择DataFrame 中的一部分列。 LR_report.columns = scoring 和 LR_report.index = index: 设置了DataFrame 的列名和行名。 model_1 = []: 创建一个空列表，用于收集模型的平均分数。 最后，打印每个评分指标的结果，并计算它们的平均值。这些平均值被添加到了 model_1 列表中。 输出： 预测结果保存： 12345#sample prediction for csv fileLR.fit(X_train, y_train)#trainingy_predict = LR.predict(X_test)#predictingLogistic_Regression=pd.DataFrame(&#123;&#x27;y_test&#x27;:y_test,&#x27;prediction&#x27;:y_predict&#125;)#df for camparisonLogistic_Regression.to_csv(&quot;Logistic Regression.csv&quot;)#export to csv 3.3 决策树分类器（Decision Tree Classifier）具体代码： 123456789101112131415161718192021#modelDT = DecisionTreeClassifier()#cross validationDT_report = pd.DataFrame(cross_validate(DT, X, y, scoring=scoring))#getting required score methodsDT_report = DT_report.iloc[:,2:]#naming the columnsDT_report.columns = scoring#naming the indexDT_report.index = index#final result collectionmodel_2 = []#Classification reportprint(&quot;Clasification report:\\n&quot;)print(DT_report,&quot;\\n\\n&quot;)print(&quot;Mean Scores:\\n&quot;)for score in scoring: print(f&quot;\\t&#123;score&#125;: &#123;round(DT_report[score].mean(),4)&#125;&quot;) model_2.append(round(DT_report[score].mean(),4)) 代码解析： DT = DecisionTreeClassifier(): 创建一个决策树分类器的实例。 DT_report = pd.DataFrame(cross_validate(DT, X, y, scoring=scoring)): 使用交叉验证来评估模型的性能。cross_validate 函数返回一个字典，其中包含了每次交叉验证的结果。这个字典被转换成一个 DataFrame。 DT_report = DT_report.iloc[:,2:]: 选择 DataFrame 中的一部分列。 DT_report.columns = scoring 和 DT_report.index = index: 设置 DataFrame 的列名和行名。 model_2 = []: 创建一个空列表，用于收集模型的平均分数。 最后，打印每个评分指标的结果，并计算它们的平均值。这些平均值被添加到了 model_2 列表中。 输出： 预测结果保存： 12345#sample prediction for csv fileDT.fit(X_train, y_train)#trainingy_predict = DT.predict(X_test)#predictingDecision_Tree=pd.DataFrame(&#123;&#x27;y_test&#x27;:y_test,&#x27;prediction&#x27;:y_predict&#125;)#df for camparisonDecision_Tree.to_csv(&quot;Decision Tree.csv&quot;)#export to csv 3.4 随机森林回归器（Random Forest Regressor）具体代码： 123456789101112131415161718192021#modelRF = RandomForestClassifier()#cross validationRF_report = pd.DataFrame(cross_validate(RF, X, y, scoring=scoring))#getting required score methodsRF_report = RF_report.iloc[:,2:]#naming the columnsRF_report.columns = scoring#naming the indexRF_report.index = index#final result collectionmodel_3 = []#Classification reportprint(&quot;Clasification report:\\n&quot;)print(RF_report,&quot;\\n\\n&quot;)print(&quot;Mean Scores:\\n&quot;)for score in scoring: print(f&quot;\\t&#123;score&#125;: &#123;round(RF_report[score].mean(),4)&#125;&quot;) model_3.append(round(RF_report[score].mean(),4)) 代码解析： RF = RandomForestClassifier(): 创建一个随机森林分类器的实例。 RF_report = pd.DataFrame(cross_validate(RF, X, y, scoring=scoring)): 使用交叉验证来评估模型的性能。cross_validate 函数返回一个字典，其中包含每次交叉验证的结果。这个字典被转换成一个 DataFrame。 RF_report = RF_report.iloc[:,2:]: 选择 DataFrame 中的一部分列。 RF_report.columns = scoring 和 RF_report.index = index: 设置DataFrame 的列名和行名。 model_3 = []: 创建一个空列表，用于收集模型的平均分数。 最后，这段代码打印每个评分指标的结果，并计算它们的平均值。这些平均值被添加到了 model_3列表中。 输出： 预测结果保存： 12345#sample prediction for csv fileRF.fit(X_train, y_train)#trainingy_predict = RF.predict(X_test)#predictingRandom_Forest = pd.DataFrame(&#123;&#x27;y_test&#x27;:y_test,&#x27;prediction&#x27;:y_predict&#125;)#df for camparisonRandom_Forest.to_csv(&quot;Random Forest.csv&quot;)#export to csv 3.5 XGBoost分类器（XGBoost Classifier）具体代码： 123456789101112131415161718192021#modelXGB = XGBClassifier()#cross validationXGB_report = pd.DataFrame(cross_validate(XGB, X, y, scoring=scoring))#getting required score methodsXGB_report = XGB_report.iloc[:,2:]#naming the columnsXGB_report.columns = scoring#naming the indexXGB_report.index = index#final result collectionmodel_4 = []#Classification reportprint(&quot;Clasification report:\\n&quot;)print(XGB_report,&quot;\\n\\n&quot;)print(&quot;Mean Scores:\\n&quot;)for score in scoring: print(f&quot;\\t&#123;score&#125;: &#123;round(XGB_report[score].mean(),4)&#125;&quot;) model_4.append(round(XGB_report[score].mean(),4)) 代码解析： XGB = XGBClassifier(): 创建一个XGBoost分类器的实例。 XGB_report = pd.DataFrame(cross_validate(XGB, X, y, scoring=scoring)): 使用交叉验证来评估模型的性能。cross_validate 函数返回一个字典，其中包含每次交叉验证的结果。这个字典被转换成一个 DataFrame。 XGB_report = XGB_report.iloc[:,2:]:选择 DataFrame 中的一部分列。 XGB_report.columns = scoring 和 XGB_report.index = index: 设置DataFrame 的列名和行名。 model_4 = []: 创建一个空列表，用于收集模型的平均分数。 最后，这段代码打印每个评分指标的结果，并计算它们的平均值。这些平均值被添加到了 model_4 列表中。 输出： 预测结果保存： 12345#sample prediction for csv fileXGB.fit(X_train, y_train)#trainingy_predict = XGB.predict(X_test)#predictingXGBoost=pd.DataFrame(&#123;&#x27;y_test&#x27;:y_test,&#x27;prediction&#x27;:y_predict&#125;)#df for camparisonXGBoost.to_csv(&quot;XGBoost.csv&quot;)#export to csv 3.6 支持向量机（Support Vector Machines）具体代码： 12345678910111213141516171819202122#modelSVM = SVC(kernel = &#x27;linear&#x27;)#cross validationSVM_report = pd.DataFrame(cross_validate(SVM, X, y, scoring=scoring))#getting required score methodsSVM_report = SVM_report.iloc[:,2:]#naming the columnsSVM_report.columns = scoring#naming the indexSVM_report.index = index#final result collectionmodel_5 = []#Classification reportprint(&quot;Clasification report:\\n&quot;)print(SVM_report,&quot;\\n\\n&quot;)print(&quot;Mean Scores:\\n&quot;)for score in scoring: print(f&quot;\\t&#123;score&#125;: &#123;round(SVM_report[score].mean(),4)&#125;&quot;) model_5.append(round(SVM_report[score].mean(),4)) 代码解析： SVM = SVC(kernel = &#39;linear&#39;): 创建一个支持向量机的实例。这里使用的是线性核函数。 SVM_report = pd.DataFrame(cross_validate(SVM, X, y, scoring=scoring)): 使用交叉验证来评估模型的性能。cross_validate 函数返回一个字典，其中包含每次交叉验证的结果。这个字典被转换成一个 DataFrame。 SVM_report = SVM_report.iloc[:,2:]:选择 DataFrame 中的一部分列。 SVM_report.columns = scoring 和 SVM_report.index = index: 设置DataFrame 的列名和行名。 model_5 = []: 这行代码创建一个空列表，用于收集模型的平均分数。 最后，这段代码打印每个评分指标的结果，并计算它们的平均值。这些平均值被添加到了 model_5 列表中。 输出： 预测结果保存： 12345#sample prediction for csv fileSVM.fit(X_train, y_train)#trainingy_predict = SVM.predict(X_test)#predictingSupport_Vector_Machines=pd.DataFrame(&#123;&#x27;y_test&#x27;:y_test,&#x27;prediction&#x27;:y_predict&#125;)#df for camparisonSupport_Vector_Machines.to_csv(&quot;Support Vector Machines.csv&quot;)#export to csv 四、实验结果通过上述步骤，获得了上述模型的相关性能，现在对它们进行比较，将它们并排显示，并比较不同模型的表现。 123456789Models = pd.DataFrame(&#123; &#x27;Logistic Regression&#x27;: np.array(model_1), &#x27;Decision Tree&#x27;: np.array(model_2), &#x27;Random Forest&#x27;: np.array(model_3), &#x27;XGBoost&#x27;: np.array(model_4), &#x27;Support Vector Machines&#x27;: np.array(model_5)&#125;)Models.index = scoring#Models.sort_values(by=&#x27;Score&#x27;, ascending=False)Models 输出：由以上报告可以得出，在本数据集上，Logistic Regression模型以及XGBoost模型表现得较为优秀。 具体排名：ranking:accuracy - 1. XGBoost 2. Logistic Regression 3. Random Forest 4. Decision Tree 5. Support Vector Machines precision - 1. XGBoost 2. Logistic Regression 3. Random Forest 4. Decision Tree 5. Support Vector Machines recall - 1. Logistic Regression 2. Random Forest 3. Decision Tree 4. XGBoost 5. Support Vector Machines f1 - 1. XGBoost 2. Logistic Regression 3. Random Forest 4. Decision Tree 5. Support Vector Machines final ranking: XGBoost Logistic Regression Random Forest Decision Tree Support Vector Machines 五、实验分析此次实验，针对本数据集使用了多个模型进行训练以及评估，同时也采用了包括accuracy、precision、recall、f1等多种模型评估指标，使得本次实验的模型对比较为全面，也更为严谨。","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"数据挖掘","slug":"课程笔记/数据挖掘","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"},{"name":"实验报告","slug":"课程笔记/数据挖掘/实验报告","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"}],"tags":[]},{"title":"","slug":"课程笔记/数据挖掘/实验报告/实验五 手写体识别实验(Handwritten Digit Recognition)","date":"2023-06-04T10:34:34.136Z","updated":"2023-09-20T08:42:18.847Z","comments":true,"path":"2023/06/d3cad4e9c8fb.html","link":"","permalink":"http://example.com/2023/06/d3cad4e9c8fb.html","excerpt":"","text":"一、实验目的(1) 编写程序，基于机器学习和深度学习实现手写体的识别。(2) 对实现的三个模型进行评估。(3) 写出实验报告。 二、实验原理(1)支持向量机（SVM）： 支持向量机是一种监督学习算法，用于二分类和多分类问题。在手写体识别任务中，S和VM可以被用来将手写数字图像分为不同的类别。SVM通过寻找一个最优的超平面来将不同类别的数据点分开。对于手写数字识别，每个图像被表示为一组特征向量，并与相应的标签（数字类别）相关联。SVM通过学习一个决策边界，使得不同类别的图像在特征空间中被最大化地分离。 (2)K最近邻算法（K Nearest Neighbors）： K最近邻算法是一种基于实例的学习方法，用于分类和回归问题。对于手写体识别任务，K最近邻算法可以用于根据与目标图像最相似的K个训练样本的标签来预测目标图像的类别。算法通过计算目标图像与所有训练图像之间的距离（如欧氏距离）来确定最相似的训练样本，然后根据K个最相似样本的标签进行投票来确定目标图像的类别。 (3) 随机森林分类器（Random Forest Classifier）： 随机森林是一种集成学习方法，它由多个决策树组成。每个决策树都是基于不同的训练样本和特征子集构建的。在手写体识别任务中，随机森林分类器可以通过将图像的特征输入到每个决策树中，并将决策树的预测结果进行投票来确定图像的类别。随机森林具有良好的泛化能力和抗过拟合能力，并且在处理高维特征空间和大规模数据集时表现良好 三、实验内容和步骤(1)实验内容 用python编写程序，通过SVM、K Nearest Neighbors、Random Forest Classifier分别实现手写体的识别模型 分别评估模型 (2)实验步骤 基于K Nearest Neighbors实现 基于SVM实现 基于Random Forest Classifier实现 具体步骤： 1. 基于K Nearest Neighbors实现1.1 相关库的导入12345678910import sysimport numpy as npimport picklefrom sklearn import model_selectionfrom sklearn.neighbors import KNeighborsClassifierfrom sklearn.metrics import accuracy_score, confusion_matrixfrom MNIST_Dataset_Loader.mnist_loader import MNISTimport matplotlib.pyplot as pltfrom matplotlib import stylestyle.use(&#x27;ggplot&#x27;) 1.2 数据加载和准备1234567891011121314print(&#x27;\\nLoading MNIST Data...&#x27;)# data = MNIST(&#x27;./python-mnist/data/&#x27;)data = MNIST(&#x27;E:\\MNIST_Dataset_Loader\\dataset&#x27;)print(&#x27;\\nLoading Training Data...&#x27;)img_train, labels_train = data.load_training()train_img = np.array(img_train)train_labels = np.array(labels_train)print(&#x27;\\nLoading Testing Data...&#x27;)img_test, labels_test = data.load_testing()test_img = np.array(img_test)test_labels = np.array(labels_test) 代码解析： MNIST数据集是一个广泛使用的手写数字数据集，包含了大量的手写数字图像和相应的标签。 使用MNIST数据加载器加载训练数据和测试数据，并将其转换为NumPy数组。 1.3 创建和训练KNN分类器1234567891011121314151617#FeaturesX = train_img#Labelsy = train_labelsprint(&#x27;\\nPreparing Classifier Training and Validation Data...&#x27;)X_train, X_test, y_train, y_test = model_selection.train_test_split(X,y,test_size=0.1)print(&#x27;\\nKNN Classifier with n_neighbors = 5, algorithm = auto, n_jobs = 10&#x27;)print(&#x27;\\nPickling the Classifier for Future Use...&#x27;)clf = KNeighborsClassifier(n_neighbors=5,algorithm=&#x27;auto&#x27;,n_jobs=10)clf.fit(X_train,y_train)with open(&#x27;MNIST_KNN.pickle&#x27;,&#x27;wb&#x27;) as f: pickle.dump(clf, f) 代码解析： 使用train_test_split函数将训练数据划分为训练集和验证集。 使用KNeighborsClassifier类创建一个K最近邻分类器。 将训练图像作为特征（X）和对应的标签（y）传递给分类器，使用训练集对KNN分类器进行训练。 将训练好的分类器保存到文件中，以便将来使用。 1.4 验证和评估分类器在这部分代码中，首先使用pickle.load函数从文件中加载之前保存的KNN分类器对象。具体步骤如下： 打开文件MNIST_KNN.pickle，以二进制读取模式进行操作。&#39;rb&#39;表示以二进制读取模式打开文件。 使用pickle.load函数从文件中加载KNN分类器对象，并将其赋值给变量clf。具体代码如下：12pickle_in = open(&#x27;MNIST_KNN.pickle&#x27;,&#x27;rb&#x27;)clf = pickle.load(pickle_in) 接下来，先进行对已训练分类器的性能在验证数据集上的评估和预测： 代码解析： 计算已训练分类器在验证数据集上的准确率。通过调用clf.score(X_test, y_test)方法，得到分类器在验证数据集上的准确率，将其赋值给变量confidence。 使用已训练分类器对验证数据集进行预测。通过调用clf.predict(X_test)方法，得到分类器对验证数据集的预测结果，将其赋值给变量y_pred。 计算预测结果的准确率。通过调用accuracy_score(y_test, y_pred)方法，计算分类器的预测准确率，将其赋值给变量accuracy。 创建并显示验证数据集的混淆矩阵。通过调用confusion_matrix(y_test, y_pred)方法，得到验证数据集的混淆矩阵，然后使用plt.matshow等函数绘制混淆矩阵的可视化。 具体代码如下： 12345678910111213141516171819202122232425print(&#x27;\\nCalculating Accuracy of trained Classifier...&#x27;)confidence = clf.score(X_test,y_test)print(&#x27;\\nMaking Predictions on Validation Data...&#x27;)y_pred = clf.predict(X_test)print(&#x27;\\nCalculating Accuracy of Predictions...&#x27;)accuracy = accuracy_score(y_test, y_pred)print(&#x27;\\nCreating Confusion Matrix...&#x27;)conf_mat = confusion_matrix(y_test,y_pred)print(&#x27;\\nKNN Trained Classifier Confidence: &#x27;,confidence)print(&#x27;\\nPredicted Values: &#x27;,y_pred)print(&#x27;\\nAccuracy of Classifier on Validation Image Data: &#x27;,accuracy)print(&#x27;\\nConfusion Matrix: \\n&#x27;,conf_mat)# Plot Confusion Matrix Data as a Matrixplt.matshow(conf_mat)plt.title(&#x27;Confusion Matrix for Validation Data&#x27;)plt.colorbar()plt.ylabel(&#x27;True label&#x27;)plt.xlabel(&#x27;Predicted label&#x27;)plt.show() 输出结果：KNN Trained Classifier Confidence: 0.9738333333333333Predicted Values: [7 0 0 ... 8 2 1]Accuracy of Classifier on Validation Image Data: 0.9738333333333333Confusion Matrix: [[568 0 0 0 0 0 1 1 0 0] [ 0 674 1 0 1 0 0 1 0 0] [ 1 6 585 1 1 1 2 9 0 0] [ 0 3 3 616 0 4 0 6 5 2] [ 0 3 0 0 564 0 1 1 0 14] [ 1 1 0 6 0 509 4 0 1 3] [ 2 3 0 0 0 8 605 0 0 0] [ 2 5 3 0 0 0 0 599 0 6] [ 0 9 0 6 2 5 1 0 547 7] [ 0 2 0 1 1 2 0 7 1 576]] 然后进行对已训练分类器的性能在测试数据集上的评估和预测： 代码解析： 使用已训练分类器对测试数据集进行预测。通过调用clf.predict(test_img)方法，得到分类器对测试数据集的预测结果，将其赋值给变量test_labels_pred。 计算已训练分类器在测试数据集上的准确率。通过调用accuracy_score(test_labels, test_labels_pred)方法，计算分类器在测试数据集上的预测准确率，将其赋值给变量acc。 创建并显示测试数据集的混淆矩阵。通过调用confusion_matrix(test_labels, test_labels_pred)方法，得到测试数据集的混淆矩阵，然后使用plt.matshow等函数绘制混淆矩阵的可视化。 具体代码： 123456789101112131415161718192021print(&#x27;\\nMaking Predictions on Test Input Images...&#x27;)test_labels_pred = clf.predict(test_img)print(&#x27;\\nCalculating Accuracy of Trained Classifier on Test Data... &#x27;)acc = accuracy_score(test_labels,test_labels_pred)print(&#x27;\\n Creating Confusion Matrix for Test Data...&#x27;)conf_mat_test = confusion_matrix(test_labels,test_labels_pred)print(&#x27;\\nPredicted Labels for Test Images: &#x27;,test_labels_pred)print(&#x27;\\nAccuracy of Classifier on Test Images: &#x27;,acc)print(&#x27;\\nConfusion Matrix for Test Data: \\n&#x27;,conf_mat_test)# Plot Confusion Matrix for Test Dataplt.matshow(conf_mat_test)plt.title(&#x27;Confusion Matrix for Test Data&#x27;)plt.colorbar()plt.ylabel(&#x27;True label&#x27;)plt.xlabel(&#x27;Predicted label&#x27;)plt.axis(&#x27;off&#x27;)plt.show() 输出结果：Predicted Labels for Test Images: [7 2 1 ... 4 5 6]Accuracy of Classifier on Test Images: 0.9675Confusion Matrix for Test Data: [[ 973 1 1 0 0 1 3 1 0 0] [ 0 1131 2 0 0 0 2 0 0 0] [ 11 8 989 2 1 0 1 16 4 0] [ 0 3 2 972 1 16 1 7 4 4] [ 3 6 0 0 944 0 4 2 1 22] [ 5 0 0 13 2 861 4 1 2 4] [ 5 4 0 0 3 2 944 0 0 0] [ 0 23 4 0 3 0 0 987 0 11] [ 7 3 5 13 6 15 4 5 911 5] [ 5 6 3 8 8 2 1 11 2 963]] 1.5 显示预测结果随机选择一些测试图像，将原始标签和预测标签显示在图像上，以便观察分类器的预测效果。 具体代码如下： 1234567# Show the Test Images with Original and Predicted Labelsa = np.random.randint(1,50,20)for i in a: two_d = (np.reshape(test_img[i], (28, 28)) * 255).astype(np.uint8) plt.title(&#x27;Original Label: &#123;0&#125; Predicted Label: &#123;1&#125;&#x27;.format(test_labels[i],test_labels_pred[i])) plt.imshow(two_d, interpolation=&#x27;nearest&#x27;,cmap=&#x27;gray&#x27;) plt.show() 输出效果如下： 2. 基于SVM实现2.1 相关库的导入123456789import sysimport numpy as npimport picklefrom sklearn import model_selection, svm, preprocessingfrom sklearn.metrics import accuracy_score,confusion_matrixfrom MNIST_Dataset_Loader.mnist_loader import MNISTimport matplotlib.pyplot as pltfrom matplotlib import stylestyle.use(&#x27;ggplot&#x27;) 2.2 数据加载和准备12345678910111213# Load MNIST Dataprint(&#x27;\\nLoading MNIST Data...&#x27;)data = MNIST(&#x27;E:\\MNIST_Dataset_Loader\\dataset&#x27;)print(&#x27;\\nLoading Training Data...&#x27;)img_train, labels_train = data.load_training()train_img = np.array(img_train)train_labels = np.array(labels_train)print(&#x27;\\nLoading Testing Data...&#x27;)img_test, labels_test = data.load_testing()test_img = np.array(img_test)test_labels = np.array(labels_test) 代码解析： MNIST数据集是一个广泛使用的手写数字数据集，包含了大量的手写数字图像和相应的标签。 使用MNIST数据加载器加载训练数据和测试数据，并将其转换为NumPy数组。 2.3 创建和训练SVM分类器12345678910111213141516171819#FeaturesX = train_img#Labelsy = train_labels# Prepare Classifier Training and Testing Dataprint(&#x27;\\nPreparing Classifier Training and Validation Data...&#x27;)X_train, X_test, y_train, y_test = model_selection.train_test_split(X,y,test_size=0.1)# Pickle the Classifier for Future Useprint(&#x27;\\nSVM Classifier with gamma = 0.1; Kernel = polynomial&#x27;)print(&#x27;\\nPickling the Classifier for Future Use...&#x27;)clf = svm.SVC(gamma=0.1, kernel=&#x27;poly&#x27;)clf.fit(X_train,y_train)with open(&#x27;MNIST_SVM.pickle&#x27;,&#x27;wb&#x27;) as f: pickle.dump(clf, f) 代码解析： 使用train_test_split函数将训练数据划分为训练集和验证集。 使用svm.SVC类创建一个SVM分类器。 将训练图像作为特征（X）和对应的标签（y）传递给分类器，使用训练集对SVM分类器进行训练。 将训练好的分类器保存到文件中，以便将来使用。 2.4 验证和评估分类器在这部分代码中，首先使用pickle.load函数从文件中加载之前保存的SVM分类器对象。具体步骤如下： 打开文件MNIST_KNN.pickle，以二进制读取模式进行操作。&#39;rb&#39;表示以二进制读取模式打开文件。 使用pickle.load函数从文件中加载KNN分类器对象，并将其赋值给变量clf。具体代码如下：12pickle_in = open(&#x27;MNIST_KNN.pickle&#x27;,&#x27;rb&#x27;)clf = pickle.load(pickle_in) 接下来，先进行对已训练分类器的性能在验证数据集上的评估和预测： 代码解析： 计算已训练分类器在验证数据集上的准确率。通过调用clf.score(X_test, y_test)方法，得到分类器在验证数据集上的准确率，将其赋值给变量confidence。 使用已训练分类器对验证数据集进行预测。通过调用clf.predict(X_test)方法，得到分类器对验证数据集的预测结果，将其赋值给变量y_pred。 计算预测结果的准确率。通过调用accuracy_score(y_test, y_pred)方法，计算分类器的预测准确率，将其赋值给变量accuracy。 创建并显示验证数据集的混淆矩阵。通过调用confusion_matrix(y_test, y_pred)方法，得到验证数据集的混淆矩阵，然后使用plt.matshow等函数绘制混淆矩阵的可视化。 具体代码如下： 12345678910111213141516171819202122232425print(&#x27;\\nCalculating Accuracy of trained Classifier...&#x27;)confidence = clf.score(X_test,y_test)print(&#x27;\\nMaking Predictions on Validation Data...&#x27;)y_pred = clf.predict(X_test)print(&#x27;\\nCalculating Accuracy of Predictions...&#x27;)accuracy = accuracy_score(y_test, y_pred)print(&#x27;\\nCreating Confusion Matrix...&#x27;)conf_mat = confusion_matrix(y_test,y_pred)print(&#x27;\\nKNN Trained Classifier Confidence: &#x27;,confidence)print(&#x27;\\nPredicted Values: &#x27;,y_pred)print(&#x27;\\nAccuracy of Classifier on Validation Image Data: &#x27;,accuracy)print(&#x27;\\nConfusion Matrix: \\n&#x27;,conf_mat)# Plot Confusion Matrix Data as a Matrixplt.matshow(conf_mat)plt.title(&#x27;Confusion Matrix for Validation Data&#x27;)plt.colorbar()plt.ylabel(&#x27;True label&#x27;)plt.xlabel(&#x27;Predicted label&#x27;)plt.show() 输出结果：SVM Trained Classifier Accuracy: 0.9808333333333333Predicted Values: [3 3 3 ... 1 8 7]Accuracy of Classifier on Validation Images: 0.9808333333333333Confusion Matrix: [[599 0 2 0 0 1 2 0 0 0] [ 0 677 4 2 0 0 1 0 1 0] [ 1 1 585 1 0 0 1 6 1 1] [ 2 0 4 593 0 3 0 1 3 2] [ 1 0 1 0 560 0 0 0 2 4] [ 0 1 1 1 0 524 2 0 4 1] [ 3 0 0 0 1 2 545 0 0 0] [ 0 3 2 1 2 2 0 665 1 4] [ 3 2 1 5 1 4 3 0 545 2] [ 1 1 0 4 3 2 0 4 0 592]] 然后进行对已训练分类器的性能在测试数据集上的评估和预测： 代码解析： 使用已训练分类器对测试数据集进行预测。通过调用clf.predict(test_img)方法，得到分类器对测试数据集的预测结果，将其赋值给变量test_labels_pred。 计算已训练分类器在测试数据集上的准确率。通过调用accuracy_score(test_labels, test_labels_pred)方法，计算分类器在测试数据集上的预测准确率，将其赋值给变量acc。 创建并显示测试数据集的混淆矩阵。通过调用confusion_matrix(test_labels, test_labels_pred)方法，得到测试数据集的混淆矩阵，然后使用plt.matshow等函数绘制混淆矩阵的可视化。 具体代码： 123456789101112131415161718192021print(&#x27;\\nMaking Predictions on Test Input Images...&#x27;)test_labels_pred = clf.predict(test_img)print(&#x27;\\nCalculating Accuracy of Trained Classifier on Test Data... &#x27;)acc = accuracy_score(test_labels,test_labels_pred)print(&#x27;\\n Creating Confusion Matrix for Test Data...&#x27;)conf_mat_test = confusion_matrix(test_labels,test_labels_pred)print(&#x27;\\nPredicted Labels for Test Images: &#x27;,test_labels_pred)print(&#x27;\\nAccuracy of Classifier on Test Images: &#x27;,acc)print(&#x27;\\nConfusion Matrix for Test Data: \\n&#x27;,conf_mat_test)# Plot Confusion Matrix for Test Dataplt.matshow(conf_mat_test)plt.title(&#x27;Confusion Matrix for Test Data&#x27;)plt.colorbar()plt.ylabel(&#x27;True label&#x27;)plt.xlabel(&#x27;Predicted label&#x27;)plt.axis(&#x27;off&#x27;)plt.show() 输出结果：Predicted Labels for Test Images: [7 2 1 ... 4 5 6]Accuracy of Classifier on Test Images: 0.9783Confusion Matrix for Test Data: [[ 972 0 1 1 0 3 1 0 2 0] [ 0 1127 2 1 0 0 3 0 2 0] [ 5 1 1007 0 2 0 4 7 6 0] [ 0 2 2 985 0 7 0 4 6 4] [ 2 0 2 0 966 0 3 0 0 9] [ 2 0 2 11 1 863 4 1 5 3] [ 5 5 1 0 3 6 936 0 2 0] [ 0 10 9 1 1 0 0 1001 0 6] [ 6 0 1 3 2 4 2 3 951 2] [ 2 7 1 5 10 3 1 2 3 975]] 2.5 显示预测结果随机选择一些测试图像，将原始标签和预测标签显示在图像上，以便观察分类器的预测效果。 具体代码如下： 1234567# Show the Test Images with Original and Predicted Labelsa = np.random.randint(1,40,15)for i in a: two_d = (np.reshape(test_img[i], (28, 28)) * 255).astype(np.uint8) plt.title(&#x27;Original Label: &#123;0&#125; Predicted Label: &#123;1&#125;&#x27;.format(test_labels[i],test_labels_pred[i])) plt.imshow(two_d, interpolation=&#x27;nearest&#x27;,cmap=&#x27;gray&#x27;) plt.show() 输出效果如下： 3. 基于Random Forest Classifier实现3.1 相关库的导入12345678910import sysimport numpy as npimport picklefrom sklearn import model_selectionfrom sklearn.ensemble import RandomForestClassifierfrom sklearn.metrics import accuracy_score, confusion_matrixfrom MNIST_Dataset_Loader.mnist_loader import MNISTimport matplotlib.pyplot as pltfrom matplotlib import stylestyle.use(&#x27;ggplot&#x27;) 3.2 数据加载和准备1234567891011121314print(&#x27;\\nLoading MNIST Data...&#x27;)# data = MNIST(&#x27;./python-mnist/data/&#x27;)data = MNIST(&#x27;E:\\MNIST_Dataset_Loader\\dataset&#x27;)print(&#x27;\\nLoading Training Data...&#x27;)img_train, labels_train = data.load_training()train_img = np.array(img_train)train_labels = np.array(labels_train)print(&#x27;\\nLoading Testing Data...&#x27;)img_test, labels_test = data.load_testing()test_img = np.array(img_test)test_labels = np.array(labels_test) 代码解析： MNIST数据集是一个广泛使用的手写数字数据集，包含了大量的手写数字图像和相应的标签。 使用MNIST数据加载器加载训练数据和测试数据，并将其转换为NumPy数组。 3.3 创建和训练RFC分类器1234567891011121314151617#FeaturesX = train_img#Labelsy = train_labelsprint(&#x27;\\nPreparing Classifier Training and Validation Data...&#x27;)X_train, X_test, y_train, y_test = model_selection.train_test_split(X,y,test_size=0.1)print(&#x27;\\nKNN Classifier with n_neighbors = 5, algorithm = auto, n_jobs = 10&#x27;)print(&#x27;\\nPickling the Classifier for Future Use...&#x27;)clf = KNeighborsClassifier(n_neighbors=5,algorithm=&#x27;auto&#x27;,n_jobs=10)clf.fit(X_train,y_train)with open(&#x27;MNIST_KNN.pickle&#x27;,&#x27;wb&#x27;) as f: pickle.dump(clf, f) 代码解析： 使用train_test_split函数将训练数据划分为训练集和验证集。 使用KNeighborsClassifier类创建一个K最近邻分类器。 将训练图像作为特征（X）和对应的标签（y）传递给分类器，使用训练集对KNN分类器进行训练。 将训练好的分类器保存到文件中，以便将来使用。 3.4 验证和评估分类器在这部分代码中，首先使用pickle.load函数从文件中加载之前保存的KNN分类器对象。具体步骤如下： 打开文件MNIST_KNN.pickle，以二进制读取模式进行操作。&#39;rb&#39;表示以二进制读取模式打开文件。 使用pickle.load函数从文件中加载KNN分类器对象，并将其赋值给变量clf。具体代码如下：12pickle_in = open(&#x27;MNIST_KNN.pickle&#x27;,&#x27;rb&#x27;)clf = pickle.load(pickle_in) 接下来，先进行对已训练分类器的性能在验证数据集上的评估和预测： 代码解析： 计算已训练分类器在验证数据集上的准确率。通过调用clf.score(X_test, y_test)方法，得到分类器在验证数据集上的准确率，将其赋值给变量confidence。 使用已训练分类器对验证数据集进行预测。通过调用clf.predict(X_test)方法，得到分类器对验证数据集的预测结果，将其赋值给变量y_pred。 计算预测结果的准确率。通过调用accuracy_score(y_test, y_pred)方法，计算分类器的预测准确率，将其赋值给变量accuracy。 创建并显示验证数据集的混淆矩阵。通过调用confusion_matrix(y_test, y_pred)方法，得到验证数据集的混淆矩阵，然后使用plt.matshow等函数绘制混淆矩阵的可视化。 具体代码如下： 12345678910111213141516171819202122232425print(&#x27;\\nCalculating Accuracy of trained Classifier...&#x27;)confidence = clf.score(X_test,y_test)print(&#x27;\\nMaking Predictions on Validation Data...&#x27;)y_pred = clf.predict(X_test)print(&#x27;\\nCalculating Accuracy of Predictions...&#x27;)accuracy = accuracy_score(y_test, y_pred)print(&#x27;\\nCreating Confusion Matrix...&#x27;)conf_mat = confusion_matrix(y_test,y_pred)print(&#x27;\\nKNN Trained Classifier Confidence: &#x27;,confidence)print(&#x27;\\nPredicted Values: &#x27;,y_pred)print(&#x27;\\nAccuracy of Classifier on Validation Image Data: &#x27;,accuracy)print(&#x27;\\nConfusion Matrix: \\n&#x27;,conf_mat)# Plot Confusion Matrix Data as a Matrixplt.matshow(conf_mat)plt.title(&#x27;Confusion Matrix for Validation Data&#x27;)plt.colorbar()plt.ylabel(&#x27;True label&#x27;)plt.xlabel(&#x27;Predicted label&#x27;)plt.show() 输出结果：RFC Trained Classifier Confidence: 0.9695Predicted Values: [6 0 8 ... 7 3 1]Accuracy of Classifier on Validation Image Data: 0.9695Confusion Matrix: [[568 0 1 1 1 0 1 0 9 0] [ 0 692 1 1 2 0 0 1 0 0] [ 1 1 586 2 2 0 2 4 2 0] [ 3 0 7 572 2 4 1 2 6 1] [ 0 0 2 0 579 1 2 1 2 8] [ 1 0 0 11 3 520 3 0 2 4] [ 3 3 1 0 0 4 569 0 2 0] [ 0 4 6 0 4 0 0 561 1 2] [ 0 6 4 5 4 6 3 0 577 6] [ 5 1 0 6 6 0 0 2 1 593]] 然后进行对已训练分类器的性能在测试数据集上的评估和预测： 代码解析： 使用已训练分类器对测试数据集进行预测。通过调用clf.predict(test_img)方法，得到分类器对测试数据集的预测结果，将其赋值给变量test_labels_pred。 计算已训练分类器在测试数据集上的准确率。通过调用accuracy_score(test_labels, test_labels_pred)方法，计算分类器在测试数据集上的预测准确率，将其赋值给变量acc。 创建并显示测试数据集的混淆矩阵。通过调用confusion_matrix(test_labels, test_labels_pred)方法，得到测试数据集的混淆矩阵，然后使用plt.matshow等函数绘制混淆矩阵的可视化。 具体代码： 123456789101112131415161718192021print(&#x27;\\nMaking Predictions on Test Input Images...&#x27;)test_labels_pred = clf.predict(test_img)print(&#x27;\\nCalculating Accuracy of Trained Classifier on Test Data... &#x27;)acc = accuracy_score(test_labels,test_labels_pred)print(&#x27;\\n Creating Confusion Matrix for Test Data...&#x27;)conf_mat_test = confusion_matrix(test_labels,test_labels_pred)print(&#x27;\\nPredicted Labels for Test Images: &#x27;,test_labels_pred)print(&#x27;\\nAccuracy of Classifier on Test Images: &#x27;,acc)print(&#x27;\\nConfusion Matrix for Test Data: \\n&#x27;,conf_mat_test)# Plot Confusion Matrix for Test Dataplt.matshow(conf_mat_test)plt.title(&#x27;Confusion Matrix for Test Data&#x27;)plt.colorbar()plt.ylabel(&#x27;True label&#x27;)plt.xlabel(&#x27;Predicted label&#x27;)plt.axis(&#x27;off&#x27;)plt.show() 输出结果：Predicted Labels for Test Images: [7 2 1 ... 4 5 6]Accuracy of Classifier on Test Images: 0.9677Confusion Matrix for Test Data: [[ 968 0 0 0 0 2 5 1 4 0] [ 0 1124 3 3 1 2 1 0 1 0] [ 6 0 996 6 3 0 4 10 7 0] [ 0 0 11 971 0 8 0 9 7 4] [ 1 0 3 0 950 0 4 1 2 21] [ 4 0 1 9 3 859 5 2 8 1] [ 5 3 0 0 4 3 940 0 3 0] [ 1 3 17 1 0 0 0 991 3 12] [ 7 0 5 10 6 6 4 3 918 15] [ 6 6 3 13 10 3 1 3 4 960]] 3.5 显示预测结果随机选择一些测试图像，将原始标签和预测标签显示在图像上，以便观察分类器的预测效果。 具体代码如下： 1234567# Show the Test Images with Original and Predicted Labelsa = np.random.randint(1,50,20)for i in a: two_d = (np.reshape(test_img[i], (28, 28)) * 255).astype(np.uint8) plt.title(&#x27;Original Label: &#123;0&#125; Predicted Label: &#123;1&#125;&#x27;.format(test_labels[i],test_labels_pred[i])) plt.imshow(two_d, interpolation=&#x27;nearest&#x27;,cmap=&#x27;gray&#x27;) plt.show() 输出效果如下： 四、实验结果分别使用了K Nearest Neighbors、SVM以及Random Forest Classifier模型实现了手写体的识别。对比他们在测试集上的表现：K Nearest Neighbors：Accuracy of Classifier on Test Images: 0.9675SVM：Accuracy of Classifier on Test Images: 0.9783Random Forest Classifier：Accuracy of Classifier on Test Images: 0.9677由上述数据得出，SVM模型在手写体识别的测试集上具有最高的准确率。 五、实验分析此次实验，在三个模型上进行了手写体识别的准确率的评估，但在模型考察上较为单一，往后可以考虑用更多评价指标来对模型进行评估，以此获得更加全面的模型报告。","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"数据挖掘","slug":"课程笔记/数据挖掘","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"},{"name":"实验报告","slug":"课程笔记/数据挖掘/实验报告","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"}],"tags":[]},{"title":"","slug":"课程笔记/数据挖掘/实验报告/实验四 颜色检测实验_Color Detection","date":"2023-06-04T08:36:03.176Z","updated":"2023-09-20T08:42:18.847Z","comments":true,"path":"2023/06/60d9fd126048.html","link":"","permalink":"http://example.com/2023/06/60d9fd126048.html","excerpt":"","text":"一、实验目的(1) 编写程序，实现对图片上颜色的检测。(2) 写出实验报告。 二、实验原理(1)导入所需的库：代码中导入了 pandas 和 cv2 库。pandas 用于读取颜色名称数据集，cv2 用于处理图像。 (2)读取图像和颜色名称数据集：使用 cv2.imread() 函数读取图像文件，并使用 pandas 的 read_csv() 函数读取颜色名称数据集。 (3)定义函数获取颜色名称：定义了一个名为 getColorName() 的函数，用于根据 RGB 值获取对应的颜色名称。该函数通过计算 RGB 值与数据集中每个颜色的差异来确定最匹配的颜色名称。 (4)定义鼠标回调函数：定义了一个名为 draw_function() 的回调函数，用于处理鼠标事件。当用户双击鼠标左键时，该函数会获取鼠标点击位置的 RGB 值，并将其保存到全局变量中。 (5)主循环：在主循环中，首先检查是否有点击事件发生。如果发生点击事件，则在图像上绘制矩形框和显示颜色名称。然后，根据颜色的亮度值，选择合适的文本颜色来显示颜色名称。循环将继续运行，直到用户按下键盘上的 Esc 键。 (7)显示图像和关闭窗口：使用 cv2.imshow() 函数显示带有颜色信息的图像，并使用 cv2.destroyAllWindows() 函数关闭窗口。 三、实验内容和步骤(1)实验内容 用python编写程序，实现颜色检测的程序：读取一张图片，当用户在图片上双击鼠标左键时，程序会提取该位置的像素颜色，并根据颜色的RGB值在图片上显示颜色名称。 测试程序 (2)实验步骤 导入库 定义变量和函数 主函数 具体步骤： 1. 导入库pandas用于读取颜色名称数据，cv2用于图像处理。 12import pandas as pdimport cv2 2. 定义变量和函数 imageUrl：指定要读取的图片路径。 clicked：记录是否有鼠标双击事件发生。 redValue、greenValue、blueValue：记录选定位置的像素颜色的RGB值。 xPosition、yPosition：记录鼠标双击位置的坐标。 colorNameDataFrame：使用pandas读取颜色名称数据，并进行必要的处理。 getColorName()函数：根据给定的RGB值，从颜色名称数据中找到最接近的颜色名称。 draw_function()函数：处理鼠标双击事件的回调函数，记录选定位置的像素颜色的RGB值。1234567891011121314151617181920212223242526272829303132imageUrl = &#x27;E:\\image.png&#x27;clicked = FalseredValue = 0greenValue = 0blueValue = 0xPosition = 0yPosition = 0colorNameDataFrame = pd.read_csv(&#x27;数据挖掘\\数据挖掘_实验部分\\实验6：颜色检测实验_Color Detection\\Dataset\\wikipedia_color_names.csv&#x27;)colorNameDataFrame.drop(colorNameDataFrame.iloc[:,5:8], inplace=True, axis=1)colorNameDataFrame.rename(columns=&#123;&#x27;Hex (24 bit)&#x27;:&#x27;Hex&#x27;, &#x27;Red (8 bit)&#x27;:&#x27;Red&#x27;, &#x27;Green (8 bit)&#x27;:&#x27;Green&#x27;, &#x27;Blue (8 bit)&#x27;:&#x27;Blue&#x27;&#125;, inplace=True)image = cv2.imread(imageUrl)def getColorName(red,green,blue): minimumValue = 10000 for i in range(len(colorNameDataFrame)): rgbValue = abs(red- int(colorNameDataFrame.loc[i,&quot;Red&quot;])) + abs(green- int(colorNameDataFrame.loc[i,&quot;Green&quot;]))+ abs(blue- int(colorNameDataFrame.loc[i,&quot;Blue&quot;])) if(rgbValue &lt;= minimumValue): minimumValue = rgbValue colorName = colorNameDataFrame.loc[i,&quot;Name&quot;] return colorNamedef draw_function(event, x,y, flags, param): if event == cv2.EVENT_LBUTTONDBLCLK: global blueValue, greenValue, redValue, xPosition, yPosition, clicked clicked = True xPosition = x yPosition = y blueValue, greenValue, redValue = image[yPosition, xPosition] blueValue = int(blueValue) greenValue = int(greenValue) redValue = int(redValue) 代码解析： getColorName()函数： 初始化变量：将 minimumValue 初始化为一个较大的值，以便在比较过程中更新最小差异值。初始化 colorName 为空字符串，用于保存最匹配的颜色名称。 遍历颜色名称数据集：使用 for 循环遍历颜色名称数据集的每一行。 计算差异值：对于每一行，将给定的 RGB 值与数据集中对应的 RGB 值进行差值计算。差值计算使用绝对值函数 abs() 来确保计算结果为正数。 更新最小差异值和颜色名称：如果计算得到的差异值小于等于当前的最小差异值 minimumValue，则更新最小差异值为当前差异值，并将对应的颜色名称保存到 colorName 中。 返回颜色名称：完成遍历后，返回最匹配的颜色名称 draw_function()函数： 检查事件类型：通过判断 event 是否等于 cv2.EVENT_LBUTTONDBLCLK，确定当前事件是否为鼠标双击事件。 更新全局变量：如果是鼠标双击事件，将全局变量 clicked 设置为 True，表示鼠标已被点击。同时更新全局变量 xPosition 和 yPosition，记录鼠标点击位置的坐标。 获取像素值：通过访问图像 image 的像素值，获取鼠标点击位置 (xPosition, yPosition) 处的 RGB 值，并将其保存到全局变量 blueValue、greenValue 和 redValue 中。 转换数据类型：将获取的 RGB 值转换为整数类型，以便后续处理。 3. 主函数12345678910111213141516171819if __name__ == &#x27;__main__&#x27;: cv2.namedWindow(&#x27;Color Name&#x27;) cv2.setMouseCallback(&#x27;Color Name&#x27;, draw_function) while (1): if (clicked): cv2.rectangle(image, (20, 20), (950, 60), (blueValue, greenValue, redValue), -1) colorName = &#x27;Selected color name is:-&#x27; + getColorName(redValue, greenValue, blueValue) cv2.putText(image, colorName, (50, 50), 2, 0.75, (255, 255, 255), 1, cv2.FONT_ITALIC) minimumValue = abs(redValue + greenValue + blueValue) if (minimumValue &gt;= 600): cv2.putText(image, colorName, (50, 50), 2, 0.75, (0, 0, 0), 1, cv2.FONT_ITALIC) clicked = False cv2.imshow(&quot;Color Name&quot;, image) # Break the loop when user hits &#x27;esc&#x27; key if cv2.waitKey(20) &amp; 0xFF == 27: break cv2.destroyAllWindows() 代码解析： 创建窗口和绑定鼠标回调函数： 使用cv2.namedWindow()创建名为”Color Name”的窗口。 使用cv2.setMouseCallback()绑定鼠标回调函数。 进入循环： 如果发生了鼠标双击事件（clicked为True），根据选定位置的RGB值在图片上绘制矩形和颜色名称。 调用getColorName()函数获取选定颜色的名称，并在图片上显示。 如果颜色的RGB值的绝对值之和大于等于600，将颜色名称的文字颜色设置为黑色。 将处理后的图片显示在窗口中。 如果用户按下了ESC键，退出循环 (3)完整程序代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import pandas as pdimport cv2imageUrl = &#x27;E:\\image.png&#x27;clicked = FalseredValue = 0greenValue = 0blueValue = 0xPosition = 0yPosition = 0colorNameDataFrame = pd.read_csv(&#x27;数据挖掘\\数据挖掘_实验部分\\实验6：颜色检测实验_Color Detection\\Dataset\\wikipedia_color_names.csv&#x27;)colorNameDataFrame.drop(colorNameDataFrame.iloc[:,5:8], inplace=True, axis=1)colorNameDataFrame.rename(columns=&#123;&#x27;Hex (24 bit)&#x27;:&#x27;Hex&#x27;, &#x27;Red (8 bit)&#x27;:&#x27;Red&#x27;, &#x27;Green (8 bit)&#x27;:&#x27;Green&#x27;, &#x27;Blue (8 bit)&#x27;:&#x27;Blue&#x27;&#125;, inplace=True)image = cv2.imread(imageUrl)def getColorName(red,green,blue): minimumValue = 10000 for i in range(len(colorNameDataFrame)): rgbValue = abs(red- int(colorNameDataFrame.loc[i,&quot;Red&quot;])) + abs(green- int(colorNameDataFrame.loc[i,&quot;Green&quot;]))+ abs(blue- int(colorNameDataFrame.loc[i,&quot;Blue&quot;])) if(rgbValue &lt;= minimumValue): minimumValue = rgbValue colorName = colorNameDataFrame.loc[i,&quot;Name&quot;] return colorNamedef draw_function(event, x,y, flags, param): if event == cv2.EVENT_LBUTTONDBLCLK: global blueValue, greenValue, redValue, xPosition, yPosition, clicked clicked = True xPosition = x yPosition = y blueValue, greenValue, redValue = image[yPosition, xPosition] blueValue = int(blueValue) greenValue = int(greenValue) redValue = int(redValue)if __name__ == &#x27;__main__&#x27;: cv2.namedWindow(&#x27;Color Name&#x27;) cv2.setMouseCallback(&#x27;Color Name&#x27;, draw_function) while (1): if (clicked): cv2.rectangle(image, (20, 20), (950, 60), (blueValue, greenValue, redValue), -1) colorName = &#x27;Selected color name is:-&#x27; + getColorName(redValue, greenValue, blueValue) cv2.putText(image, colorName, (50, 50), 2, 0.75, (255, 255, 255), 1, cv2.FONT_ITALIC) minimumValue = abs(redValue + greenValue + blueValue) if (minimumValue &gt;= 600): cv2.putText(image, colorName, (50, 50), 2, 0.75, (0, 0, 0), 1, cv2.FONT_ITALIC) clicked = False cv2.imshow(&quot;Color Name&quot;, image) # Break the loop when user hits &#x27;esc&#x27; key if cv2.waitKey(20) &amp; 0xFF == 27: break cv2.destroyAllWindows() 四、实验结果程序的运行结果与演示如下图所示：可以看到，输入的图片是vscode界面，当双击蓝色部分时，程序左上角出现了以蓝色为背景的文字“Selected color name is:-St. Patrick’s blue”。而下方双击绿色部分，则显示绿色背景的文字“Selected color name is:-Old moss green”。 五、实验分析该程序的稳定性较强，但在用户体验方面仍有改进之处：可以把双击某部分改成鼠标停留在哪就显示该处颜色。这样在用户体验上可能会更好。","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"数据挖掘","slug":"课程笔记/数据挖掘","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"},{"name":"实验报告","slug":"课程笔记/数据挖掘/实验报告","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"}],"tags":[]},{"title":"","slug":"课程笔记/数据挖掘/实验报告/实验三 心脏病预测（Smart Health Disease）朴素贝叶斯","date":"2023-06-04T07:23:43.350Z","updated":"2023-09-20T08:42:18.847Z","comments":true,"path":"2023/06/4c83db3bac28.html","link":"","permalink":"http://example.com/2023/06/4c83db3bac28.html","excerpt":"","text":"一、实验目的(1) 编写程序，实现心脏病的预测模型的建立。(2) 对多个模型，依据混淆矩阵进行评估度量。(3) 写出实验报告。 二、实验原理(1)数据预处理：首先，对心脏病数据集进行数据预处理，包括特征选择、缺失值处理、数据标准化等操作，以准备数据集用于模型训练和测试。 (2)模型训练：选择了多个机器学习算法，包括SVM、朴素贝叶斯、逻辑回归、决策树、随机森林、LightGBM和XGBoost。对于每个算法，使用训练集对模型进行训练，调整算法参数以获得最佳性能。 (3)模型评估：使用测试集对训练好的模型进行预测，并计算评估指标：混淆矩阵。 (4)结果分析：根据实验结果，对不同算法的预测性能进行比较和分析，以确定哪种算法在心脏病预测任务中表现最好 三、实验内容和步骤(1)实验内容 数据预处理：对心脏病数据集进行特征选择、缺失值处理、数据标准化等预处理操作。 模型训练：使用SVM、朴素贝叶斯、逻辑回归、决策树、随机森林、LightGBM和XGBoost等算法进行模型训练。 模型评估：使用测试集对训练好的模型进行预测，并计算评估指标，混淆矩阵。 结果比较和分析：对不同算法的预测性能进行比较和分析，以确定最佳的模型。 结论：总结实验结果，给出针对心脏病预测任务的最佳模型选择和建议。 (2)实验步骤 导入数据并判断是否有缺省值 数据预处理 模型训练与评估 具体步骤： 1. 导入数据并判断是否有缺省值具体代码如下： 1234567891011121314151617181920import pandas as pd# import warnings filterfrom warnings import simplefilter# ignore all future warningssimplefilter(action=&#x27;ignore&#x27;, category = FutureWarning)# import warnings filterfrom warnings import simplefilter# ignore all future warningssimplefilter(action=&#x27;ignore&#x27;, category = FutureWarning)df = pd.read_csv(&#x27;cleveland.csv&#x27;, header = None)df.columns = [&#x27;age&#x27;, &#x27;sex&#x27;, &#x27;cp&#x27;, &#x27;trestbps&#x27;, &#x27;chol&#x27;, &#x27;fbs&#x27;, &#x27;restecg&#x27;, &#x27;thalach&#x27;, &#x27;exang&#x27;, &#x27;oldpeak&#x27;, &#x27;slope&#x27;, &#x27;ca&#x27;, &#x27;thal&#x27;, &#x27;target&#x27;]### 1 = male, 0 = femaledf.isnull().sum() 输出结果： 查看每个目标阶层的年龄和性别分布具体代码如下： 12345678910111213df[&#x27;target&#x27;] = df.target.map(&#123;0: 0, 1: 1, 2: 1, 3: 1, 4: 1&#125;)df[&#x27;sex&#x27;] = df.sex.map(&#123;0: &#x27;female&#x27;, 1: &#x27;male&#x27;&#125;)df[&#x27;thal&#x27;] = df.thal.fillna(df.thal.mean())df[&#x27;ca&#x27;] = df.ca.fillna(df.ca.mean())import matplotlib.pyplot as pltimport seaborn as sns# distribution of target vs agesns.set_context(&quot;paper&quot;, font_scale = 2, rc = &#123;&quot;font.size&quot;: 20,&quot;axes.titlesize&quot;: 25,&quot;axes.labelsize&quot;: 20&#125;) sns.catplot(kind = &#x27;count&#x27;, data = df, x = &#x27;age&#x27;, hue = &#x27;target&#x27;, order = df[&#x27;age&#x27;].sort_values().unique())plt.title(&#x27;Variation of Age for each target class&#x27;)plt.show() 输出结果： 具体代码如下： 12345# barplot of age vs sex with hue = targetsns.catplot(kind = &#x27;bar&#x27;, data = df, y = &#x27;age&#x27;, x = &#x27;sex&#x27;, hue = &#x27;target&#x27;)plt.title(&#x27;Distribution of age vs sex with the target class&#x27;)plt.show() 输出结果： 2. 数据预处理12345678910################################## data preprocessingX = df.iloc[:, :-1].valuesy = df.iloc[:, -1].valuesfrom sklearn.model_selection import train_test_splitX_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 0)from sklearn.preprocessing import StandardScaler as sssc = ss()X_train = sc.fit_transform(X_train)X_test = sc.transform(X_test) 代码解析： 数据划分：使用train_test_split函数将数据集df划分为训练集和测试集。X是除了最后一列外的所有特征，y是最后一列的目标变量。通过设置test_size参数为0.2，将数据集划分为80%的训练集和20%的测试集。random_state参数用于设定随机种子，以确保每次划分结果的一致性。 特征缩放：使用StandardScaler类进行特征缩放。sc对象是StandardScaler的实例。首先，fit_transform方法在训练集上进行拟合和转换，计算每个特征的均值和标准差，并将训练集进行标准化处理。然后，使用transform方法将测试集按照相同的均值和标准差进行标准化处理。 通过数据划分和特征缩放，可以将原始数据集划分为训练集和测试集，并对特征进行标准化处理，以便在后续的模型训练和评估中使用。这些步骤有助于确保模型在相同的数据范围内进行训练和测试，提高模型的性能和泛化能力。 3. 模型训练与评估应用以下模型进行训练，并且使用混淆矩阵进行模型评估与度量以下模型将具体使用$$accuracy&#x3D;\\frac{TP+TN}{TP+TN+FP+FN}$$作为模型的评估度量混淆矩阵如下图所示： 3.1 SVM(支持向量机)代码解析： 模型训练：使用SVC类创建一个SVM分类器对象。kernel=&#39;rbf&#39;参数指定了使用径向基函数作为核函数。然后，使用fit方法将训练集的特征X_train和标签y_train作为输入，对分类器进行训练。 预测测试集结果：使用训练好的分类器对测试集的特征X_test进行预测，使用predict方法得到预测的类别标签y_pred。 混淆矩阵：使用confusion_matrix函数计算测试集预测结果的混淆矩阵。 预测训练集结果和混淆矩阵：类似地，使用训练好的分类器对训练集的特征X_train进行预测，得到预测的类别标签y_pred_train。然后使用confusion_matrix函数计算训练集预测结果的混淆矩阵。 具体代码如下： 1234567891011121314151617######################################### SVM #############################################################from sklearn.svm import SVCclassifier = SVC(kernel = &#x27;rbf&#x27;)classifier.fit(X_train, y_train)# Predicting the Test set resultsy_pred = classifier.predict(X_test)from sklearn.metrics import confusion_matrixcm_test = confusion_matrix(y_pred, y_test)y_pred_train = classifier.predict(X_train)cm_train = confusion_matrix(y_pred_train, y_train)print()print(&#x27;Accuracy for training set for svm = &#123;&#125;&#x27;.format((cm_train[0][0] + cm_train[1][1])/len(y_train)))print(&#x27;Accuracy for test set for svm = &#123;&#125;&#x27;.format((cm_test[0][0] + cm_test[1][1])/len(y_test))) 输出结果：Accuracy for training set for svm = 0.9256198347107438 Accuracy for test set for svm = 0.8032786885245902 3.2 Naive Bayes(朴素贝叶斯)代码解析： 数据准备：使用df.iloc[:, :-1].values将数据集中除了最后一列之外的所有特征赋值给X，将最后一列的标签赋值给y。 数据划分：使用train_test_split函数将数据集划分为训练集和测试集。通过设置test_size参数为0.2，将数据集划分为80%的训练集和20%的测试集。random_state参数用于设定随机种子，以确保每次划分结果的一致性。划分后的训练集特征赋值给X_train，训练集标签赋值给y_train，测试集特征赋值给X_test，测试集标签赋值给y_test。 模型训练：使用GaussianNB类创建一个朴素贝叶斯分类器对象，即高斯朴素贝叶斯分类器。然后，使用fit方法将训练集的特征X_train和标签y_train作为输入，对分类器进行训练。 预测测试集结果：使用训练好的分类器对测试集的特征X_test进行预测，使用predict方法得到预测的类别标签y_pred。 混淆矩阵：使用confusion_matrix函数计算测试集预测结果的混淆矩阵。 预测训练集结果和混淆矩阵：类似地，使用训练好的分类器对训练集的特征X_train进行预测，得到预测的类别标签y_pred_train。然后使用confusion_matrix函数计算训练集预测结果的混淆矩阵。 具体代码如下： 1234567891011121314151617181920212223242526######################################### Naive Bayes #############################################################X = df.iloc[:, :-1].valuesy = df.iloc[:, -1].valuesfrom sklearn.model_selection import train_test_splitX_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 0)from sklearn.naive_bayes import GaussianNBclassifier = GaussianNB()classifier.fit(X_train, y_train)# Predicting the Test set resultsy_pred = classifier.predict(X_test)from sklearn.metrics import confusion_matrixcm_test = confusion_matrix(y_pred, y_test)y_pred_train = classifier.predict(X_train)cm_train = confusion_matrix(y_pred_train, y_train)print()print(&#x27;Accuracy for training set for Naive Bayes = &#123;&#125;&#x27;.format((cm_train[0][0] + cm_train[1][1])/len(y_train)))print(&#x27;Accuracy for test set for Naive Bayes = &#123;&#125;&#x27;.format((cm_test[0][0] + cm_test[1][1])/len(y_test))) 输出结果：Accuracy for training set for Naive Bayes = 0.8677685950413223Accuracy for test set for Naive Bayes = 0.7868852459016393 3.3 Logistic Regression(逻辑回归)代码解析： 数据准备：使用df.iloc[:, :-1].values将数据集中除了最后一列之外的所有特征赋值给X，将最后一列的标签赋值给y。 数据划分：使用train_test_split函数将数据集划分为训练集和测试集。通过设置test_size参数为0.2，将数据集划分为80%的训练集和20%的测试集。random_state参数用于设定随机种子，以确保每次划分结果的一致性。划分后的训练集特征赋值给X_train，训练集标签赋值给y_train，测试集特征赋值给X_test，测试集标签赋值给y_test。 模型训练：使用LogisticRegression类创建一个逻辑回归分类器对象。然后，使用fit方法将训练集的特征X_train和标签y_train作为输入，对分类器进行训练。 预测测试集结果：使用训练好的分类器对测试集的特征X_test进行预测，使用predict方法得到预测的类别标签y_pred。 混淆矩阵：使用confusion_matrix函数计算测试集预测结果的混淆矩阵。 预测训练集结果和混淆矩阵：类似地，使用训练好的分类器对训练集的特征X_train进行预测，得到预测的类别标签y_pred_train。然后使用confusion_matrix函数计算训练集预测结果的混淆矩阵。 具体代码如下： 1234567891011121314151617181920212223242526######################################### Logistic Regression #############################################################X = df.iloc[:, :-1].valuesy = df.iloc[:, -1].valuesfrom sklearn.model_selection import train_test_splitX_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 0)from sklearn.linear_model import LogisticRegressionclassifier = LogisticRegression()classifier.fit(X_train, y_train)# Predicting the Test set resultsy_pred = classifier.predict(X_test)from sklearn.metrics import confusion_matrixcm_test = confusion_matrix(y_pred, y_test)y_pred_train = classifier.predict(X_train)cm_train = confusion_matrix(y_pred_train, y_train)print()print(&#x27;Accuracy for training set for Logistic Regression = &#123;&#125;&#x27;.format((cm_train[0][0] + cm_train[1][1])/len(y_train)))print(&#x27;Accuracy for test set for Logistic Regression = &#123;&#125;&#x27;.format((cm_test[0][0] + cm_test[1][1])/len(y_test))) 输出结果：Accuracy for training set for Logistic Regression = 0.8677685950413223Accuracy for test set for Logistic Regression = 0.8032786885245902 3.4 Decision Tree(决策树)代码解析： 数据准备：使用df.iloc[:, :-1].values将数据集中除了最后一列之外的所有特征赋值给X，将最后一列的标签赋值给y。 数据划分：使用train_test_split函数将数据集划分为训练集和测试集。通过设置test_size参数为0.2，将数据集划分为80%的训练集和20%的测试集。random_state参数用于设定随机种子，以确保每次划分结果的一致性。划分后的训练集特征赋值给X_train，训练集标签赋值给y_train，测试集特征赋值给X_test，测试集标签赋值给y_test。 模型训练：使用DecisionTreeClassifier类创建一个决策树分类器对象。然后，使用fit方法将训练集的特征X_train和标签y_train作为输入，对分类器进行训练。 预测测试集结果：使用训练好的分类器对测试集的特征X_test进行预测，使用predict方法得到预测的类别标签y_pred。 混淆矩阵：使用confusion_matrix函数计算测试集预测结果的混淆矩阵。 预测训练集结果和混淆矩阵：类似地，使用训练好的分类器对训练集的特征X_train进行预测，得到预测的类别标签y_pred_train。然后使用confusion_matrix函数计算训练集预测结果的混淆矩阵。 具体代码如下： 12345678910111213141516171819202122232425######################################### Decision Tree #############################################################X = df.iloc[:, :-1].valuesy = df.iloc[:, -1].valuesfrom sklearn.model_selection import train_test_splitX_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 0)from sklearn.tree import DecisionTreeClassifierclassifier = DecisionTreeClassifier()classifier.fit(X_train, y_train)# Predicting the Test set resultsy_pred = classifier.predict(X_test)from sklearn.metrics import confusion_matrixcm_test = confusion_matrix(y_pred, y_test)y_pred_train = classifier.predict(X_train)cm_train = confusion_matrix(y_pred_train, y_train)print()print(&#x27;Accuracy for training set for Decision Tree = &#123;&#125;&#x27;.format((cm_train[0][0] + cm_train[1][1])/len(y_train)))print(&#x27;Accuracy for test set for Decision Tree = &#123;&#125;&#x27;.format((cm_test[0][0] + cm_test[1][1])/len(y_test))) 输出结果：Accuracy for training set for Decision Tree = 1.0Accuracy for test set for Decision Tree = 0.8032786885245902 3.5 Random Forest(随机森林)代码解析： 数据准备：使用df.iloc[:, :-1].values将数据集中除了最后一列之外的所有特征赋值给X，将最后一列的标签赋值给y。 数据划分：使用train_test_split函数将数据集划分为训练集和测试集。通过设置test_size参数为0.2，将数据集划分为80%的训练集和20%的测试集。random_state参数用于设定随机种子，以确保每次划分结果的一致性。划分后的训练集特征赋值给X_train，训练集标签赋值给y_train，测试集特征赋值给X_test，测试集标签赋值给y_test。 模型训练：使用RandomForestClassifier类创建一个随机森林分类器对象。通过设置n_estimators参数为10，指定随机森林中树的数量为10。然后，使用fit方法将训练集的特征X_train和标签y_train作为输入，对分类器进行训练。 预测测试集结果：使用训练好的分类器对测试集的特征X_test进行预测，使用predict方法得到预测的类别标签y_pred。 混淆矩阵：使用confusion_matrix函数计算测试集预测结果的混淆矩阵。 预测训练集结果和混淆矩阵：类似地，使用训练好的分类器对训练集的特征X_train进行预测，得到预测的类别标签y_pred_train。然后使用confusion_matrix函数计算训练集预测结果的混淆矩阵。 具体代码如下： 12345678910111213141516171819202122232425######################################### Random Forest #############################################################X = df.iloc[:, :-1].valuesy = df.iloc[:, -1].valuesfrom sklearn.model_selection import train_test_splitX_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 0)from sklearn.ensemble import RandomForestClassifierclassifier = RandomForestClassifier(n_estimators = 10)classifier.fit(X_train, y_train)# Predicting the Test set resultsy_pred = classifier.predict(X_test)from sklearn.metrics import confusion_matrixcm_test = confusion_matrix(y_pred, y_test)y_pred_train = classifier.predict(X_train)cm_train = confusion_matrix(y_pred_train, y_train)print()print(&#x27;Accuracy for training set for Random Forest = &#123;&#125;&#x27;.format((cm_train[0][0] + cm_train[1][1])/len(y_train)))print(&#x27;Accuracy for test set for Random Forest = &#123;&#125;&#x27;.format((cm_test[0][0] + cm_test[1][1])/len(y_test))) 输出结果：Accuracy for training set for Random Forest = 0.9834710743801653Accuracy for test set for Random Forest = 0.7049180327868853 3.6 LightGBM代码解析： 数据准备：使用lgb.Dataset函数将训练集的特征X_train和标签y_train组成LightGBM需要的数据集对象d_train。 参数设置：定义一个空字典params用于设置LightGBM的参数。 模型训练：使用lgb.train函数训练LightGBM模型。传入参数params表示模型的参数设置，d_train表示训练数据集，100表示训练的轮数（迭代次数）。 预测测试集结果：使用训练好的模型对测试集的特征X_test进行预测，得到预测的概率值y_pred。 二值化处理：根据设定的阈值（0.5），将概率值转换为二进制的类别标签。概率值大于等于0.5的被划分为类别1，小于0.5的被划分为类别0。 混淆矩阵：使用confusion_matrix函数计算测试集预测结果的混淆矩阵。 预测训练集结果和混淆矩阵：类似地，使用训练好的模型对训练集的特征X_train进行预测，得到预测的概率值y_pred_train。然后使用confusion_matrix函数计算训练集预测结果的混淆矩阵。 具体代码如下： 12345678910111213141516171819202122232425262728293031323334################################################################################ applying lightGBMimport lightgbm as lgbd_train = lgb.Dataset(X_train, label = y_train)params = &#123;&#125;clf = lgb.train(params, d_train, 100)#Predictiony_pred = clf.predict(X_test)#convert into binary valuesfor i in range(0, len(y_pred)): if y_pred[i]&gt;= 0.5: # setting threshold to .5 y_pred[i]=1 else: y_pred[i]=0 from sklearn.metrics import confusion_matrixcm_test = confusion_matrix(y_pred, y_test)y_pred_train = clf.predict(X_train)for i in range(0, len(y_pred_train)): if y_pred_train[i]&gt;= 0.5: # setting threshold to .5 y_pred_train[i]=1 else: y_pred_train[i]=0 cm_train = confusion_matrix(y_pred_train, y_train)print()print(&#x27;Accuracy for training set for LightGBM = &#123;&#125;&#x27;.format((cm_train[0][0] + cm_train[1][1])/len(y_train)))print(&#x27;Accuracy for test set for LightGBM = &#123;&#125;&#x27;.format((cm_test[0][0] + cm_test[1][1])/len(y_test))) 输出结果：Accuracy for training set for LightGBN = 0.9958677685950413Accuracy for test set for LightGBN = 0.7704918032786885 3.7 XGBoost代码解析： 模型训练：使用XGBClassifier类创建一个XGBoost分类器对象xg。然后，使用fit方法将训练集的特征X_train和标签y_train作为输入，对分类器进行训练。 预测测试集结果：使用训练好的分类器对测试集的特征X_test进行预测，得到预测的类别标签y_pred。 混淆矩阵：使用confusion_matrix函数计算测试集预测结果的混淆矩阵。 预测训练集结果和混淆矩阵：类似地，使用训练好的分类器对训练集的特征X_train进行预测，得到预测的类别标签y_pred_train。然后使用confusion_matrix函数计算训练集预测结果的混淆矩阵。 具体代码如下： 12345678910111213141516171819202122232425262728################################################################################ applying XGBoost#from sklearn.model_selection import train_test_split#X_train, X_test, y_train, y_test = train_test_split(X, target, test_size = 0.20, random_state = 0)from xgboost import XGBClassifierxg = XGBClassifier()xg.fit(X_train, y_train)y_pred = xg.predict(X_test)from sklearn.metrics import confusion_matrixcm_test = confusion_matrix(y_pred, y_test)y_pred_train = xg.predict(X_train)for i in range(0, len(y_pred_train)): if y_pred_train[i]&gt;= 0.5: # setting threshold to .5 y_pred_train[i]=1 else: y_pred_train[i]=0cm_train = confusion_matrix(y_pred_train, y_train)print()print(&#x27;Accuracy for training set for XGBoost = &#123;&#125;&#x27;.format((cm_train[0][0] + cm_train[1][1])/len(y_train)))print(&#x27;Accuracy for test set for XGBoost = &#123;&#125;&#x27;.format((cm_test[0][0] + cm_test[1][1])/len(y_test))) 输出结果：Accuracy for training set for XGBoost = 0.987603305785124 Accuracy for test set for XGBoost &#x3D; 0.7540983606557377&#96; 四、实验结果通过对上述七个模型进行混淆矩阵评估度量，得到以下实验结果：Accuracy for training set for svm = 0.9256198347107438 Accuracy for test set for svm = 0.8032786885245902 Accuracy for training set for Naive Bayes = 0.8677685950413223Accuracy for test set for Naive Bayes = 0.7868852459016393 Accuracy for training set for Logistic Regression = 0.8677685950413223Accuracy for test set for Logistic Regression = 0.8032786885245902 Accuracy for training set for Decision Tree = 1.0Accuracy for test set for Decision Tree = 0.8032786885245902 Accuracy for training set for Random Forest = 0.9834710743801653Accuracy for test set for Random Forest = 0.7049180327868853 Accuracy for training set for LightGBN = 0.9958677685950413Accuracy for test set for LightGBN = 0.7704918032786885 Accuracy for training set for XGBoost = 0.987603305785124 Accuracy for test set for XGBoost &#x3D; 0.7540983606557377&#96;由此可得，在训练集上Decision Tree具有最高的Accuracy；而在测试集上SVM、Logistic Regression、Decision Tree具有最高的Accuracy。 五、实验分析此次实验，在多个模型上进行了优劣对比，但在模型的评估度量上只使用了混淆矩阵中的Accuracy，往后可以考虑用更多评估度量标准来对模型进行评估，评估模型的性能和可靠性。以此获得更加全面准确的模型报告。","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"数据挖掘","slug":"课程笔记/数据挖掘","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"},{"name":"实验报告","slug":"课程笔记/数据挖掘/实验报告","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"}],"tags":[]},{"title":"","slug":"课程笔记/数据挖掘/实验报告/实验一 数据预处理实验_信用卡欺诈检测","date":"2023-06-04T06:52:47.133Z","updated":"2023-09-20T08:42:18.847Z","comments":true,"path":"2023/06/6f49b06c6fae.html","link":"","permalink":"http://example.com/2023/06/6f49b06c6fae.html","excerpt":"","text":"一、实验目的(1) 编写程序，实现数据的预处理，以及检查数据的分布特征。(2) 调用有关模型，检查数据异常值，并且比较与分析模型。(3) 写出实验报告。 二、实验原理(1) 数据预测处理：现实世界中的数据库极易受到噪音数据、遗漏数据和不一致性数据的估计，为提供⾼数据质量进入并提供⾼挖掘结果的质量，产生了大数据预测处理技术。数据预测处理有多种方法：数据清理，数据集合，数据变换，数据归约等。这些数据处理技术在 数据挖掘之前使用，大大提⾼了数据挖掘模型的质量，降低了实际挖掘所需要的时间。 (2) 数据清理：数据清理示例通过填写遗漏的值，平滑噪声数据，识别、删去离群点，并解决不一致于“理”数据。 (3) 检测数据异常值：在数据挖掘的过程中，数据异常值可能会对模型的准确性和稳定性产生负面影响。因此，检测和处理数据中的异常值是数据预处理的重要步骤之一。常见的数据异常值检测方法包括孤立森林（Isolation Forest）、局部异常因子（Local Outlier Factor）和支持向量机（Support Vector Machine）等。这些方法利用数据的统计特性、密度、距离或边界来识别与大多数数据点明显不同的数据点。通过使用这些异常值检测方法，我们可以标识出数据中的异常值，并进行进一步的处理，例如删除异常值、替换为缺失值或使用其他方法进行修正。这样可以提高数据质量，减少异常值对数据挖掘模型的影响，从而获得更准确和可靠的分析结果。 三、实验内容和步骤(1)实验内容 用Python编写程序工具编写程序，实现数据清理、检查数据特征等功能，并在实验报告中写出主要的过程和采用的方法。 通过一些模型来检测数据的异常值 (2)实验步骤 导入库 读取数据 检查缺失值 检查分类数据 4.1查看数据的基本统计描述 4.2绘制交易金额分布柱状图 4.3绘制交易时间与交易量分布图 4.4抽取数据样本观察分布 4.5相关性分析 模型建立与分析 5.1数据准备 5.2模型与分析 5.3模型比较 具体步骤： 1.导入库1234567891011121314151617from warnings import filterwarnings filterwarnings(&#x27;ignore&#x27;)import numpy as np import pandas as pdimport sklearnimport scipyimport matplotlib.pyplot as pltimport seaborn as snsfrom sklearn.metrics import classification_report,accuracy_scorefrom sklearn.ensemble import IsolationForestfrom sklearn.neighbors import LocalOutlierFactorfrom sklearn.svm import OneClassSVMfrom pylab import rcParamsrcParams[&#x27;figure.figsize&#x27;] = 14, 8RANDOM_SEED = 42LABELS = [&quot;Normal&quot;, &quot;Fraud&quot;] 2.读取数据12data = pd.read_csv(&#x27;../Dataset/creditcard.csv&#x27;,sep=&#x27;,&#x27;)data.head() 结果： 3.检查缺失值1data.isnull().values.any() 输出：False说明该数据集中不存在缺失值 粗看数据分类占比 1234567count_classes = pd.value_counts(data[&#x27;Class&#x27;], sort = True)count_classes.plot(kind = &#x27;bar&#x27;, rot=0)LABELS = [&quot;Normal&quot;, &quot;Fraud&quot;]plt.title(&quot;Transaction Class Distribution&quot;)plt.xticks(range(2), LABELS)plt.xlabel(&quot;Class&quot;)plt.ylabel(&quot;Frequency&quot;) 运行结果： 4.检查分类数据4.1查看数据的基本统计描述123fraud = data[data[&#x27;Class&#x27;]==1]normal = data[data[&#x27;Class&#x27;]==0]print(fraud.shape,normal.shape) 输出被诈骗数据以及正常数据的维度：(492, 31) (284315, 31)从中看出正常数据有284315条，而被诈骗数据仅仅有492条。 查看正常数据以及被诈骗数据的基本统计量 1fraud.Amount.describe() 1normal.Amount.describe() &#96; 4.2绘制交易金额分布柱状图按类别列出的每笔交易的金额，据此分别绘制柱状图，观察数据分布。 12345678910111213f, (ax1, ax2) = plt.subplots(2, 1, sharex=True)f.suptitle(&#x27;Amount per transaction by class&#x27;)bins = 50ax1.hist(fraud.Amount, bins = bins)ax1.set_title(&#x27;Fraud&#x27;)ax2.hist(normal.Amount, bins = bins)ax2.set_title(&#x27;Normal&#x27;)plt.xlabel(&#x27;Amount ($)&#x27;)plt.ylabel(&#x27;Number of Transactions&#x27;)plt.xlim((0, 20000))plt.yscale(&#x27;log&#x27;)plt.show(); 4.3绘制交易时间与交易量分布图将检查欺诈交易是否在特定时间段内更频繁发生，用数据可视化——点状图来直观分析。 123456789f, (ax1, ax2) = plt.subplots(2, 1, sharex=True)f.suptitle(&#x27;Time of transaction vs Amount by class&#x27;)ax1.scatter(fraud.Time, fraud.Amount)ax1.set_title(&#x27;Fraud&#x27;)ax2.scatter(normal.Time, normal.Amount)ax2.set_title(&#x27;Normal&#x27;)plt.xlabel(&#x27;Time (in Seconds)&#x27;)plt.ylabel(&#x27;Amount&#x27;)plt.show() 输出的点状图如下： 4.4抽取数据样本观察分布通过在总体数据集中随机抽取一定量(10%)的样本，来观察样本中正常数据与被诈骗数据的分布情况。 1234567891011data1= data.sample(frac = 0.1,random_state=1)data1.shapeFraud = data1[data1[&#x27;Class&#x27;]==1]Valid = data1[data1[&#x27;Class&#x27;]==0]outlier_fraction = len(Fraud)/float(len(Valid))print(outlier_fraction)print(&quot;Fraud Cases : &#123;&#125;&quot;.format(len(Fraud)))print(&quot;Valid Cases : &#123;&#125;&quot;.format(len(Valid))) 输出结果如下：0.0017234102419808666 Fraud Cases : 49 Valid Cases : 28432&#96;得出样本数据中，欺诈交易数量与有效（正常）交易数量之比为0.0017234102419808666。可见欺诈交易占比之小。 4.5相关性分析通过以下代码，获取数据集中每个特征的相关性，并绘制出相关性的图像。 12345import seaborn as snscorrmat = data1.corr()top_corr_features = corrmat.indexplt.figure(figsize=(26,26))g=sns.heatmap(data[top_corr_features].corr(),annot=True,cmap=&quot;RdYlGn&quot;) 图像如下： 5.模型建立与分析5.1数据准备1234567891011columns = data1.columns.tolist()columns = [c for c in columns if c not in [&quot;Class&quot;]]target = &quot;Class&quot;state = np.random.RandomState(42)X = data1[columns]Y = data1[target]X_outliers = state.uniform(low=0, high=1, size=(X.shape[0], X.shape[1]))print(X.shape)print(Y.shape) 5.2模型与分析为了检测数据集中的异常值或离群点，将分别使用以下三个模型进行检测：孤立森林（Isolation Forest）、局部异常因子（Local Outlier Factor）与局部异常因子（Local Outlier Factor） 孤立森林（Isolation Forest）：这是一种基于树的模型，用于异常值检测。它的工作原理是随机选择一个特征，然后随机选择一个分割值，将数据分为两部分。这个过程重复进行，形成了一个“森林”。孤立森林认为那些容易被孤立的点是异常值。 局部异常因子（Local Outlier Factor）：这是一种基于邻近性的方法，用于异常值检测。它比较了一个点和其邻居的局部密度，如果一个点的局部密度远低于其邻居，那么这个点就被认为是异常值。 支持向量机（Support Vector Machine）：这是一种基于边界的方法，用于异常值检测。在这种情况下，它被配置为一个单类支持向量机（One-Class SVM），这意味着它试图找到数据的“正常”边界，然后将那些在边界之外的点视为异常值。 以下是定义了三个模型检测方法的一个字典序列： 1234567classifiers = &#123; &quot;Isolation Forest&quot;:IsolationForest(n_estimators=100, max_samples=len(X), contamination=outlier_fraction,random_state=state, verbose=0), &quot;Local Outlier Factor&quot;:LocalOutlierFactor(n_neighbors=20, algorithm=&#x27;auto&#x27;,leaf_size=30, metric=&#x27;minkowski&#x27;,p=2, metric_params=None, contamination=outlier_fraction), &quot;Support Vector Machine&quot;:OneClassSVM(kernel=&#x27;rbf&#x27;, degree=3, gamma=0.1,nu=0.05,max_iter=-1)&#125; 5.3模型比较将从模型的误差精确度、召回率、f1-score等方面对三个模型进行比较。 1234567891011121314151617181920212223n_outliers = len(Fraud)for i, (clf_name,clf) in enumerate(classifiers.items()): #Fit the data and tag outliers if clf_name == &quot;Local Outlier Factor&quot;: y_pred = clf.fit_predict(X) scores_prediction = clf.negative_outlier_factor_ elif clf_name == &quot;Support Vector Machine&quot;: clf.fit(X) y_pred = clf.predict(X) else: clf.fit(X) scores_prediction = clf.decision_function(X) y_pred = clf.predict(X) #Reshape the prediction values to 0 for Valid transactions , 1 for Fraud transactions y_pred[y_pred == 1] = 0 y_pred[y_pred == -1] = 1 n_errors = (y_pred != Y).sum() # Run Classification Metrics print(&quot;&#123;&#125;: &#123;&#125;&quot;.format(clf_name,n_errors)) print(&quot;Accuracy Score :&quot;) print(accuracy_score(Y,y_pred)) print(&quot;Classification Report :&quot;) print(classification_report(Y,y_pred)) 该代码使用前面定义的三种异常检测方法（孤立森林、局部异常因子、单类支持向量机）来预测数据集中的异常值，并计算每种方法的预测错误数、准确度和分类报告。 结论：在精确度方面，Isolation Forest为99.74%比Local Outlier Factor的99.66%和Support Vector Machine的70.09%都要高。在召回率方面，Isolation Forest模型依然是最优的，其召回率为27%，而Local Outlier Factor的召回率为2%，Support Vector Machine仅为0%。因此，整体上，Isolation Forest在确定欺诈交易方面表现得更好。 四、实验结果首先，通过检查缺失值、检查分类数据等数据预处理步骤，对数据进行一个初步处理与了解。然后，通过模型的建立与分析，对比了三种模型：solation Forest、Local Outlier Factor和Support Vector Machine，在检测异常值方面的优劣。最终，得出loslation Forest模型在确定欺诈交易方面表现得更好。 五、实验分析此次实验，在三个模型上进行了优劣对比，往后可以考虑用更多的模型来进行对比，以此来获得更加切合，表现更为优秀的模型。","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"数据挖掘","slug":"课程笔记/数据挖掘","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"},{"name":"实验报告","slug":"课程笔记/数据挖掘/实验报告","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"}],"tags":[]},{"title":"","slug":"课程笔记/数据挖掘/实验报告/实验二 King County房价预测线性回归","date":"2023-06-04T03:00:58.089Z","updated":"2023-09-20T08:42:18.847Z","comments":true,"path":"2023/06/284aeead5564.html","link":"","permalink":"http://example.com/2023/06/284aeead5564.html","excerpt":"","text":"一、实验目的(1) 编写程序，实现房价的预测模型的建立。(2) 调用建立的模型，进行未知房价地区的房价预测。(3) 写出实验报告。 二、实验原理(1)数据预处理：对原始数据进行清洗、缺失值处理、特征工程等预处理步骤，以获得可用于建模的数据集。 (2)模型选择和训练：选取多个线性回归模型作为候选模型，例如多元线性回归模型、递归特征消除、交叉验证的递归特征消除等。针对每个模型，使用训练数据集进行模型训练。 (3)模型评估：使用测试数据集评估每个模型的性能，计算评价指标如均方根误差（RMSE）、决定系数（R-squared）等，以衡量模型的预测能力。 (4)模型比较与选择：比较不同模型的性能和特点，考虑各个模型的优缺点，选择最佳的模型作为最终的房价预测模型。 三、实验内容和步骤(1)实验内容 首先，检查数据的完整性，并进行方差分析和韦尔奇T检验等统计检验，以发现数据中的显著性。研究发现，该物业的邮政编码、重建状况、地下室的存在以及物业的状况是影响物业价值的重要因素。 其次，设计了许多功能来增强线性回归建模。一些特征被重新创建为伯努利分布，用作分类数据，例如主浴室的存在。卧室和浴室等普通价值也被平方，以强调多个浴室和卧室对房地产价格的影响。 最后，以统计模型OLS方法为基线，建立了四个线性回归模型。该模型主要基于工程特性。然后，从Scikit Learn库中创建了三个模型：基本线性回归、具有递归特征消除的线性回归以及具有递归特征去除和交叉验证的线性回归。通过系数分析，确定具有递归特征消除的线性回归模型是最稳定的模型，并选择它进行最终实现。 (2)实验步骤 库和数据的导入 探索性数据分析 特征工程（Feature Engineering） 线性回归模型选择 模型导出 预测（模型的使用） 具体步骤： 1.库和数据的导入1234567891011121314151617181920import osimport pandas as pdimport numpy as npimport scipy.stats as statsimport matplotlib.pyplot as pltimport seaborn as snsimport plotly.express as pximport geopandas as gpdimport statsmodels.api as smimport statsmodels.formula.api as smffrom sklearn.model_selection import train_test_splitfrom sklearn.linear_model import LinearRegressionfrom sklearn.feature_selection import RFE, RFECVfrom sklearn import metricsimport pickle%matplotlib inlinepd.options.display.max_columns = 500pd.options.display.max_rows = 500kc_df = pd.read_csv(&quot;../../Dataset/kc_house_data_train.csv&quot;, index_col=0) 2.探索性数据分析为了便于理解，本节将对数据进行可视化，然后对数据中的实证结果进行适当的统计分析。以下是本节中回答的问题的摘要： 哪个街区拥有最有价值的房产？ 房产状况是否会影响价值？ 房产年龄和状况是否相关？ 哪些功能为房子增值？ 翻修会增加房地产价值吗？ 地下室能增加房地产价值吗？ 2.1检查数据完整性检查数据集中是否存在缺失值 1234total_null = 0for null_count in kc_df.isnull().sum(): total_null += null_countprint(f&quot;There are total &#123;total_null&#125; null values in the data&quot;) 输出：here are total 0 null values in the data说明该数据集中不存在缺失值，数据集完整。 由于数据集包含连续值和分类值的混合，许多列包含与基本统计分析无关的分类值，因此选择我们需要的列来分析数据。 12summary_features = [&quot;price&quot;, &quot;yr_built&quot;, &quot;bedrooms&quot;, &quot;bathrooms&quot;, &quot;sqft_living&quot;, &quot;sqft_lot&quot;,&quot;floors&quot;, &quot;condition&quot;, &quot;grade&quot;, &quot;sqft_living15&quot;, &quot;sqft_lot15&quot;]kc_df[summary_features].describe() 截取所需列后的数据概述如下： 2.2列分析-价格-价格有2个数量级的巨大差距。将需要进一步的分析，特别是针对销售日期。-yr_builded-数据集包含从1900年到2015年构建的构建。-间卧室-0间卧室表示单间公寓，大多数住宅包含4间或更少的卧室，并有一些极端的异常值。-浴室-惊讶地发现，有些家庭没有浴室。大多数人似乎至少有一个3&#x2F;4的浴室。-sqft_living-从小公寓到豪宅，居住区也有很大的差异。-sqft_lot-类似于上面的sqft_living。-层-有一半的楼层需要考虑，它们是不跨越房子整体的顶层。-条件-售出的平均房产售价为3.4（可能需要表面修复）。-等级-金县的平均等级为7，这意味着平均房产的销售等级略高于平均等级。-sqft_living15-相邻属性的大小往往相似（与sqft_lving的趋势相似）-sqft_lot15-与上面的sqft_ling15相似 2.3分析哪个街区拥有最高房价？通过邮政编码，对不同街区的房价进行统计分析，获取最高房价的几个街区，以下是具体实现代码： 12345678910111213141516171819202122#property values by zipcode calculationkc_top5_price = kc_df.groupby(&quot;zipcode&quot;)[&quot;price&quot;].mean().sort_values(ascending = False)[:5]kc_mean_price = kc_df.price.mean()#top5 neighborhood label for plotarea_labels = [&quot;Medina&quot;, &quot;Bellevue&quot;, &quot;Mercer Island&quot;, &quot;Madison Park&quot;, &quot;Capitol Hill&quot;]#plotting the dataplt.subplots(figsize=(8,4))sns.barplot(x=kc_top5_price.index, y=kc_top5_price, order=kc_top5_price.index, palette=&quot;Blues_d&quot;) #blue for seahawks!plt.xticks(np.arange(5), area_labels, rotation=75, size=8) #relabel x with list aboveplt.hlines(kc_mean_price, -.5 ,4.5, colors=&quot;darkgoldenrod&quot;, label=&quot;Average Price&quot;) #plot average price horizontal line#prettify graphplt.xlabel(&quot;Neighborhoods&quot;, size=14)plt.ylabel(&quot;Prices ($1mil)&quot;, size=14)plt.title(&quot;Neighborhoods with Highest Property Price&quot;, size=16, y=1.08)plt.legend() #show legend#uncomment line below to export image# plt.savefig(&quot;images/high_price_neighborhood.png&quot;,bbox_inches = &quot;tight&quot;)plt.show(); 房价最高的街区 接着，通过热力型地图，将每个地区平均房价以热力值的形式，直观地表现在地图上，颜色越深代表平均房价越高，以下是具体实现代码： 12345678910111213141516171819202122232425262728293031323334#shapefile data setupking_county = gpd.read_file(&quot;data/zipcode_shape/Zipcodes_for_King_County_and_Surrounding_Area___zipcode_area.shp&quot;)king_county[&quot;zipcode&quot;] = king_county[&quot;ZIP&quot;] #set up column for merge#kc_df price setupzip_price = kc_df.groupby(&quot;zipcode&quot;).price.mean()#plotting data setupzip_plot_df = king_county.join(zip_price, on=&quot;zipcode&quot;, how=&quot;inner&quot;)#plot setupfig, ax = plt.subplots(figsize=(12,6))zip_plot_df.plot(column=&quot;price&quot;, cmap=&quot;YlOrRd&quot;, linewidth=.25, edgecolor=&quot;.25&quot;, ax=ax)#set up colorbarcolor_bar = plt.cm.ScalarMappable(cmap=&quot;YlOrRd&quot;, norm=plt.Normalize(vmin=zip_price.min(), vmax=zip_price.max()))color_bar._A = []cbar = fig.colorbar(color_bar, fraction=0.03, pad=0.02)#set figure limit to zoom in on select neighborhoodsax.set_ylim(47.45, 47.7)ax.set_xlim(-122.35, -122.15)ax.set_xticks([-122.35, -122.15])ax.set_ylabel(&quot;Latitude&quot;, size=12)ax.set_xlabel(&quot;Longitude&quot;, size=12)#labeling few areasax.text(-122.257, 47.62, &#x27;Medina&#x27;)ax.text(-122.2, 47.57, &#x27;Bellevue&#x27;, rotation=-45)ax.text(-122.26, 47.58, &#x27;Mercer Island&#x27;)plt.title(&quot;Average Price per Zipcode Heatmap&quot;, size=14)#uncomment below to save image# plt.savefig(&quot;images/zipcode_price_heatmap.png&quot;,bbox_inches = &quot;tight&quot;)plt.show(); 平均房价的热力型地图： 通过分析每个地区（不同邮政编码）的平均房地产价值，Medina、Belleve、Mercer Island、Madison Park和Capitol Hill地区成为平均房地产价格最高的地区。这些社区的大多数房产是金县平均房产价值的两倍，麦地那的平均房产价值是金县的四倍。似乎是由于靠近华盛顿湖和大型公园，这些房产的价值越来越高。 使用前5个街区的对房地产价格进行方差分析对比前五个排名的邮政编码与平均房价之间的关系，通过ANOVA检验判断是否存在统计上的显著差异，并进行相应的输出。 12345678910alpha = 0.05#ANOVA Test Setupkc_top5 = kc_df[kc_df.zipcode.isin(kc_top5_price.index)]formula = &#x27;price~C(zipcode)&#x27;lm_top5 = smf.ols(formula, kc_top5).fit()anova_top5_table = sm.stats.anova_lm(lm_top5, typ=2)if anova_top5_table[&quot;PR(&gt;F)&quot;][0] &lt; alpha: print(&quot;Top 5 ranked zipcode have a statistically significant impact on average property value&quot;) print(&quot;Zipcdoe ANOVA F-statisic Probability: &quot;, anova_top5_table[&quot;PR(&gt;F)&quot;][0]) 输出：Top 5 ranked zipcode have a statistically significant impact on average property value Zipcdoe ANOVA F-statisic Probability: 1.2515560223110402e-19 2.4分析房产状况是否会影响价值？通过以下代码可视化不同房屋条件评分下的平均房价和中位数房价，并对比平均房价和中位数房价之间的差异。 123456789101112131415161718192021222324252627282930313233343536373839404142#-------------------Conditions Calculation--------------------------------#condition_mean = kc_df.groupby(&quot;condition&quot;)[&quot;price&quot;].mean()condition_median = kc_df.groupby(&quot;condition&quot;)[&quot;price&quot;].median()condition_score = np.arange(1,6)#--------------------------Bar Plots--------------------------------------##set subplot datafig, ax = plt.subplots(figsize=(8,4))ax2 = ax.twinx() #set ax2 on same x axis as axax3 = ax.twinx() #same as above, for hlinewidth = 0.5#barplots ax.bar(x=condition_score, height=condition_median, width=width, label=&quot;Median Price&quot;, color=&quot;midnightblue&quot;, alpha=0.8)ax2.bar(x=condition_score, height=condition_mean, width=width, label=&quot;Mean Price&quot;, color=&quot;royalblue&quot;, alpha=0.8)#horizontal line for mean priceax3.hlines(kc_mean_price, .7 ,5.3, colors=&quot;red&quot;, label=&quot;Average Price&quot;)#set ylimit to the same scale and display only 1ax.set_ylim(0,1.2*condition_mean.max())ax2.set_ylim(0,1.2*condition_mean.max())ax3.set_ylim(0,1.2*condition_mean.max())ax2.yaxis.set_visible(False) #hide the 2nd axisax3.yaxis.set_visible(False)#set legend positionsax.legend(bbox_to_anchor=(0,0,1,1), loc=&quot;upper left&quot;)ax2.legend(bbox_to_anchor=(0,-.1,1,1), loc=&quot;upper left&quot;)ax3.legend(bbox_to_anchor=(0,0,1,1), loc=&quot;upper right&quot;)#prettify graphax.set_ylabel(&quot;Average Prices ($)&quot;, size=14)ax.set_xlabel(&quot;Condition Score&quot;, size=14)plt.title(&quot;Average Property Value per Condition&quot;, size=16, y=1.08)#uncomment line below to export image# plt.savefig(&quot;images/condition_value.png&quot;,bbox_inches = &quot;tight&quot;)plt.legend()plt.show(); 输出图片如下： 物业条件统计分析𝛼 &#x3D; 0.05Null-Hypothesis：不同条件下的平均财产价值没有显著差异。Alternative Hypothesis：不同条件下的平均财产价值有显著差异。 123456789alpha = 0.05 #ANOVA Test Setupformula = &#x27;price~C(condition)&#x27;lm_condition = smf.ols(formula, kc_df).fit()anova_condition = sm.stats.anova_lm(lm_condition, typ=2)if anova_condition[&quot;PR(&gt;F)&quot;][0] &lt; alpha: print(&quot;The property condition have a statistically significant impact on average property value&quot;) print(&quot;Conditions F-statisic Probability: &quot;, anova_condition[&quot;PR(&gt;F)&quot;][0]) 输出如下：The property condition have a statistically significant impact on average property value Conditions F-statisic Probability: 6.813536869407728e-24 结论：房产条件对房地产的价格有重大影响。随着情况的恶化，平均房价和中值房价都呈上升趋势。 2.5房产的特点和升级（哪些功能为房子增值）本部分将对有&#x3D;&#x3D;地下室的房子会为房产增值吗？&#x3D;&#x3D;以及&#x3D;&#x3D;翻新是否会增加房产的价值？&#x3D;&#x3D;两个问题进行分析。通过将数据集分类成[有地下室，无地下室]以及[翻新、未翻新]继续平均房价的柱状图绘制，来直观得出上述问题的答案。以下是具体实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142#--------------------------Property Feature Calculation---------------------------------------#basement = kc_df[(kc_df[&quot;sqft_basement&quot;] &gt; 0)]basement_mean = basement.price.mean()no_basement = kc_df[(kc_df[&quot;sqft_basement&quot;] == 0)]no_basement_mean = no_basement.price.mean()#mean values to plotrenovated = kc_df[(kc_df[&quot;yr_renovated&quot;] &gt; 0)]renovated_mean = renovated.price.mean()not_renovated = kc_df[(kc_df[&quot;yr_renovated&quot;] == 0)]not_renovated_mean = not_renovated.price.mean()#prepare plot labelslabel_basement = [&quot;Basement&quot;, &quot;No basement&quot;]values_basement = [basement_mean, no_basement_mean]label_renovation = [&quot;Renovated&quot;, &quot;No Renovation&quot;]values_renovation = [renovated_mean, not_renovated_mean]#--------------------------Bar Plots--------------------------------------#fig, ax = plt.subplots(1, 2, figsize=(14,4))sns.barplot(ax=ax[0], x=label_basement, y=values_basement, palette=&quot;Blues_r&quot;)sns.barplot(ax=ax[1], x=label_renovation, y=values_renovation, palette=&quot;Blues_r&quot;)ax[0].hlines(kc_mean_price, -.5 ,1.5, colors=&quot;coral&quot;, label=&quot;Average Price&quot;) #plot average price horizontal lineax[1].hlines(kc_mean_price, -.5 ,1.5, colors=&quot;coral&quot;, label=&quot;Average Price&quot;) #plot average price horizontal line#prettify graphax[0].set_ylabel(&quot;Average Prices ($)&quot;, size=12)ax[0].set_title(&quot;Average Property Value&quot;, size=14)ax[0].set_ylim(0,1.1*renovated_mean)ax[0].legend()ax[1].set_ylabel(&quot;Average Prices ($)&quot;, size=12)ax[1].set_title(&quot;Average Property Value&quot;, size=14)ax[1].set_ylim(0,1.1*renovated_mean)ax[1].legend()plt.suptitle(&quot;Affect of Basement and Renovation on Property Value&quot;, size=16, y=1.02)#uncomment below to export image# plt.savefig(&quot;images/basement_renovation_value.png&quot;,bbox_inches = &quot;tight&quot;)plt.show(); 结果图： 房产特征统计分析$\\alpha$&#x3D;0.05地下室Null-Hypothesis：有地下室和没有地下室的房产之间的平均房产价值没有显著差异Alternative Hypothesis：有或没有地下室的房产的平均房产价值有显著差异。 翻新Null-Hypothesis：翻新或未翻新的房产的平均房产价值没有显著差异。Alternative Hypothesis：翻新或未翻新的房产之间的平均房产价值有显著差异。 123456789101112alpha = 0.05basement_p_val = stats.ttest_ind(basement.price, no_basement.price, equal_var=False)[1]print(&quot;Basement vs No Basement T-test P Value: &quot;, basement_p_val)if basement_p_val &lt; alpha: print(&quot;The P value is less than alpha, reject null-hypothesis&quot;)print(&quot;\\n&quot;) #white space for formatting outputrenovation_p_val = stats.ttest_ind(renovated.price, not_renovated.price, equal_var=False)[1]print(&quot;Renovated vs Not Renovated T-test P Value: &quot;, renovation_p_val)if renovation_p_val &lt; alpha: print(&quot;The P value is less than alpha, reject null-hypothesis&quot;) 输出如下：Basement vs No Basement T-test P Value: 1.935598808013724e-102 The P value is less than alpha, reject null-hypothesis Renovated vs Not Renovated T-test P Value: 6.478917377975333e-20 The P value is less than alpha, reject null-hypothesis 结论：地下室和翻新都为房产增加了显著的价值，翻新对房产价值的平均影响更大。 2.6探索性数据分析总结 哪个街区拥有最有价值的房产？-金县的麦地那、贝尔韦、默瑟岛、麦迪逊公园和国会山社区的平均房地产价值最高。这些地区的房地产价值与金县的平均房地产价值在统计上存在显著差异。 房产状况是否会影响价值？-房地产条件对房地产价值有统计学上的显著影响。然而，条件4&#x2F;5的平均值小于条件3&#x2F;5的平均值。这可能是由于其他因素造成的，如公寓&#x2F;合作公寓，其每栋房产的价格可能较低，但往往比私人住宅维护得更好。 哪些功能为房子增值？-翻新后的房产比未翻新的房产具有更高的价值。-基准面为特性添加了重要的值。 3.特征工程（Feature Engineering）Feature Engineering（特征工程）是指在机器学习中对原始数据中的属性进行提取、转换、选择和创建新特征的过程。它是机器学习中至关重要的一步，可以显著影响模型的性能和准确度。 在特征工程中，我们通过对原始数据进行处理和转换，提取出更具信息量和表达能力的特征，以便更好地描述数据的特性和模式。这可以通过以下几种方式实现： 特征提取（Feature Extraction）：从原始数据中提取有用的特征。例如，从文本数据中提取词袋模型、TF-IDF值或词嵌入向量作为特征；从图像数据中提取边缘、纹理或颜色直方图作为特征。 特征转换（Feature Transformation）：对原始特征进行转换或降维。例如，通过主成分分析（PCA）将高维数据转换为低维表示；使用多项式特征转换将原始特征转化为更高阶的多项式特征。 特征选择（Feature Selection）：选择对目标变量预测有重要影响的特征，剔除对模型无关的特征。这可以通过统计方法（如方差阈值、相关系数等）或基于模型的方法（如L1正则化、决策树特征重要性等）来实现。 特征创造（Feature Creation）：通过组合、衍生或生成新的特征来增强原始特征的表达能力。例如，将时间数据分解为年、月、日等组成部分；通过数值间的计算（如差值、比值）来创建新的特征。 通过精心进行特征工程，可以使模型更好地捕捉数据中的模式和规律，提高模型的准确性、鲁棒性和泛化能力。因此，特征工程是机器学习中非常重要和常用的技术之一。 功能检查在进行工程设计之前，所有功能都应该是浮点或整数。在添加到Sklearn线性回归训练之前，日期、id和价格列将被删除。 1kc_df.head() 输出结果： 翻新由于翻新对物业价值有重大影响，因此可以将此功能更新为分类功能 1kc_df[&quot;renovated&quot;] = kc_df.yr_renovated.apply(lambda x: 1 if x &gt; 0 else 0) 翻新年限翻新价值可能会随着年限而贬值，因此此功能可能会提供负相关功能 1kc_df[&quot;renovation_age&quot;] = kc_df.yr_renovated.apply(lambda x: 2020-x if x &gt; 0 else 0) 地下室创建”Basement”特征与进行装修类似。由于拥有地下室可以自动增加房产的价值，因此将其作为二元分类特征可以更好地引导模型。 1kc_df[&quot;basement&quot;] = kc_df.sqft_basement.apply(lambda x: 1 if x != 0 else 0) 主浴室拥有2个或更多浴室的房产很可能包含一个主卫生间，而对许多买家来说，主卫生间是非常理想的。虽然拥有2个浴室并不保证房产有一个主卫生间，但鉴于浴室与房价高度相关且与其他特征存在多重共线性，它可能是进行特征工程的一个好的候选。 1kc_df[&quot;master_bathroom&quot;] = kc_df.bathrooms.apply(lambda x: 1 if x &gt; 2 else 0) 家庭住宅“Family House”特征的创建与上面的”Master Bathroom”特征类似，旨在引导模型将房产区分为公寓和独立房屋。这并不是一个完美的实现，但它是一个简单的方式来区分小型公寓，例如工作室式公寓。 1kc_df[&quot;family_house&quot;] = kc_df.bedrooms.apply(lambda x: 1 if x &gt; 2 else 0) 销售年份和销售季度“Sold Year”和”Sold Quarter”特征的创建是基于原始日期列的处理。由于日期列的数据类型为字符串，为了将其处理为整数类型，将其拆分为年份和年度季度。 12kc_df[&quot;sale_year&quot;] = kc_df.date.apply(lambda x: int(x[:4])) #convert first 4 character, year, into intkc_df[&quot;sale_quarter&quot;] = kc_df.date.apply(lambda x: int(x[4:6])//3.1 + 1) #fancy math convert month, 4-5 index, to quarters in int 邮政编码伪变量“Zipcode Dummy Variables”是指将邮政编码作为虚拟变量来表示。由于邮政编码不是一种有序值，将其作为虚拟变量可以更好地表示其在模型中的影响。 12ziplist = pd.Series(kc_df[&quot;zipcode&quot;]) #make dummy columnskc_df = kc_df.merge(pd.get_dummies(ziplist), left_index=True, right_index=True) #merge dummy columns 方形卧室和浴室。“Squared Bedrooms”和”Squared Bathrooms”特征的创建是为了增强它们与价格之间的相关性。由于卧室数量和浴室数量与房价高度相关，通过对它们的值进行平方操作，可以增加它们在线性模型中的影响力。这将减少0和1对线性模型的影响。 12kc_df[&quot;bedroom_squared&quot;] = kc_df[&quot;bedrooms&quot;] ** 2kc_df[&quot;bathroom_squared&quot;] = kc_df[&quot;bathrooms&quot;] ** 2 4.线性回归模型选择4.1训练以及测试数据集概述：在该步骤中准备训练集以及测试集，将原始数据集划分为训练集和测试集，并确保两者之间的数据是相互独立的、没有重叠的。具体代码： 1234features = [col for col in kc_df.columns if col not in [&quot;id&quot;, &quot;date&quot;, &quot;price&quot;] ] #remove id, date, and price column from featureslr_kc_df = kc_df[features] #set train/test data using feature abovemodel_target = kc_df[&quot;price&quot;] #target column is the price columnx_train, x_test, y_train, y_test = train_test_split(lr_kc_df, model_target ,test_size=0.2) 4.2多元线性回归模型概述：该模型将作为所有其他模型的基线比较。该模型利用了一些基本特征和经过特征工程处理的特征。调整后的R-squared值为0.738，这意味着模型可以解释因变量约73.8%的变异程度。较高的R-squared值表示模型对数据的拟合较好，但并不代表模型一定是最佳模型，因为R-squared无法告诉我们关于模型中其他因素。 代码解析：使用statsmodels库中的ols函数来拟合一个多元线性回归模型，并计算模型在训练集上的预测结果和均方根误差（RMSE）。在这段代码中，定义了一个包含多个自变量的回归模型，其中自变量包括’sqft_living’（居住面积）、’C(zipcode)’（邮政编码，使用了虚拟变量表示）、’condition’（房屋条件）、’renovation_age’（翻新年龄）、’sale_year’（售出年份，使用了虚拟变量表示）、’C(sale_quarter)’（销售季度，使用了虚拟变量表示）、’C(basement)’（地下室，使用了虚拟变量表示）、’bedroom_squared’（卧室数量的平方）和’bathroom_squared’（浴室数量的平方）。 接下来，使用这个模型在训练集上进行预测，并计算了预测结果与实际值之间的均方根误差（RMSE）。 最后调用kc_ols.summary()来获取模型的详细统计结果。该方法会输出模型的摘要信息，包括回归系数、标准误差、t统计量、p值等。通过查看这些统计结果，以此了解模型的拟合效果、各个自变量的显著性以及模型的解释能力等信息。 具体代码如下： 1234567eq = &quot;price~sqft_living+C(zipcode)+condition+renovation_age+sale_year+C(sale_quarter)+C(basement)+bedroom_squared+bathroom_squared&quot;kc_ols = smf.ols(formula=eq, data=kc_df).fit()# uncomment below for summary of the ols model# print(kc_ols.summary())ols_result = kc_ols.predict(x_train)ols_rmse = np.sqrt(metrics.mean_squared_error(y_train, ols_result))kc_ols.summary() 部分输出结果： 4.3Scikit-learn库中的线性回归模型概述：使用Scikit-learn库中的线性回归模型，可以建立一个基本的线性回归模型，使用数据集中的所有特征进行训练和预测。 代码解析：首先使用Scikit-learn库中的LinearRegression()函数创建一个线性回归模型lm_kc，并使用训练数据x_train和对应的目标变量y_train进行了模型的训练。 接下来，使用训练好的模型对训练数据x_test进行预测，得到了预测值y_train_prediction。 然后，通过计算均方根误差（RMSE）来评估模型在测试数据上的性能。RMSE是衡量模型预测误差的指标，表示预测值与实际值之间的平均差异。 最后，使用list(zip(lr_kc_df.columns, lm_kc.coef_))这一行代码来查看模型的系数。通过这行代码，可以得到一个由特征列名和对应的系数值组成的列表，用于查看模型对各个特征的权重影响。 具体代码如下： 12345678910#fit modellm_kc = LinearRegression().fit(x_train, y_train)#training data predictiony_train_prediction = lm_kc.predict(x_test)#rmsetrain_rmse = np.sqrt(metrics.mean_squared_error(y_test, y_train_prediction))#coeffeicient checkinglist(zip(lr_kc_df.columns,lm_kc.coef_)) 输出结果：总结：根据上述信息，可以看出这个模型在预测中高度依赖房产的邮政编码，同时减少了卧室数量、浴室数量和居住面积等房产的其他方面对房价的影响。在实际应用中，这种影响效果可能非常明显，导致该模型预测大多数房产的价格为负数。 4.4递归特征消除概述：使用递归特征消除（Recursive Feature Elimination）方法来消除不必要的特征。通过这个方法，线性回归模型在每一次迭代中会剔除对模型预测性能贡献较小的特征。理论上，这个方法应该能够提供更准确的模型。 代码解析：使用递归特征消除（RFE）方法来对特征进行排名和选择。 首先，使用RFE函数创建一个RFE对象，其中指定估计器（estimator）为线性回归模型（LinearRegression()），并设置步长（step）为1。然后，使用x_train和y_train作为训练数据来拟合RFE模型。 接下来，通过将特征名称和对应的特征排名组成的数据框（kc_rfe_ranking）打印出来，可以可视化特征的排名情况。数据框中的”Model Features”列包含特征的名称，”Feature Ranking”列包含每个特征的排名。 具体代码如下： 1234567kc_rfe = RFE(estimator=LinearRegression(), step=1)kc_rfe = kc_rfe.fit(x_train, y_train)# Run this cell to visualize how the feature are rankedkc_rfe_ranking = pd.DataFrame(&#123;&quot;Model Features&quot;:x_train.columns, &quot;Feature Ranking&quot;:kc_rfe.ranking_&#125;)rank_check = kc_rfe_ranking.sort_values(by=&quot;Feature Ranking&quot;)print(rank_check) 输出结果： 代码解析：首先使用RFE对象的transform方法将训练数据x_train进行特征选择，得到经过特征选择后的训练数据x_train_rfe和测试数据x_test_rfe。 接下来，使用经过特征选择后的训练数据x_train_rfe和对应的目标变量y_train，创建一个新的线性回归模型lm_kc_rfe，并进行模型的训练。 然后，使用训练好的模型lm_kc_rfe对测试数据x_test_rfe进行预测，得到了预测值y_train_prediction_rfe。 最后，通过计算均方根误差（RMSE）来评估经过特征选择后模型在测试数据上的性能。使用np.sqrt(metrics.mean_squared_error(y_test, y_train_prediction_rfe))计算了模型在测试数据上的均方根误差。 lm_kc_rfe.coef_这一行代码输出了经过特征选择后的线性回归模型lm_kc_rfe的系数。通过这个系数，可以查看经过特征选择后，每个特征对于模型的影响程度。 具体代码如下： 123456789101112x_train_rfe = kc_rfe.transform(x_train)x_test_rfe = kc_rfe.transform(x_test)#fit modellm_kc_rfe = LinearRegression().fit(x_train_rfe, y_train)#training data predictiony_train_prediction_rfe = lm_kc_rfe.predict(x_test_rfe)#rmsetrain_rmse_rfe = np.sqrt(metrics.mean_squared_error(y_test, y_train_prediction_rfe))lm_kc_rfe.coef_ 输出结果：总结：可以看出经过递归特征消除交叉验证（RFECV）的模型系数异常地高。这些系数无法与特征名称轻松对应，但是大多数特征的单位变化会导致数百万甚至数千万美元的价格变化。这也解释了在数据集稍微变化时，该模型的不稳定行为。总结来说，可以预测这个模型是高度不现实的。 4.5交叉验证的递归特征消除概述：通过使用交叉验证的方式进行特征选择，这个模型会花费更多的时间来完成。理论上，这个模型应该是最准确的模型，但实际结果显示，这个模型在某些情况下虽然准确，但也表现不稳定。这种不稳定的行为可以通过下面的模型系数来解释。 代码解析：首先创建一个RFECV对象kc_rfecv，其中指定估计器（estimator）为线性回归模型（LinearRegression()），步长（step）为1，交叉验证的折数（cv）为5，评估指标（scoring）为负的均方根误差（neg_root_mean_squared_error），并使用所有可用的处理器（n_jobs&#x3D;-1）进行并行计算。然后，使用x_train和y_train作为训练数据来拟合RFECV模型。 接下来，使用RFECV对象的transform方法将训练数据x_train进行特征选择，得到经过特征选择后的训练数据x_train_rfecv和测试数据x_test_rfecv。 然后，使用经过特征选择后的训练数据x_train_rfecv和对应的目标变量y_train，创建一个新的线性回归模型lm_kc_rfecv，并进行模型的训练。 然后，使用训练好的模型lm_kc_rfecv对测试数据x_test_rfecv进行预测，得到了预测值y_train_prediction_rfecv。 最后，通过计算均方根误差（RMSE）来评估经过特征选择后模型在测试数据上的性能。使用np.sqrt(metrics.mean_squared_error(y_test, y_train_prediction_rfecv))计算了模型在测试数据上的均方根误差。 具体代码如下： 1234567891011121314151617kc_rfecv = RFECV(estimator=LinearRegression(), step=1, cv=5, scoring=&quot;neg_root_mean_squared_error&quot;, n_jobs=-1)kc_rfecv = kc_rfecv.fit(x_train, y_train)x_train_rfecv = kc_rfecv.transform(x_train)x_test_rfecv = kc_rfecv.transform(x_test)#fit modellm_kc_rfecv = LinearRegression().fit(x_train_rfecv, y_train)#training data predictiony_train_prediction_rfecv = lm_kc_rfecv.predict(x_test_rfecv)#rmsetrain_rmse_rfecv = np.sqrt(metrics.mean_squared_error(y_test, y_train_prediction_rfecv))lm_kc_rfecv.coef_ 输出结果： 总结：RFECV模型的系数看起来异常地高。这些系数无法与特征名称轻松对应，但大多数特征的单位变化会导致数百万甚至数千万美元的价格变化。这也解释了在数据集稍微变化时，该模型的不稳定行为。总结来说，可以预测这个模型也是高度不现实的。 4.6模型对比与选择通过以下代码，输出上述不同模型在训练数据上的均方根误差。通过这些误差，可以比较不同模型的性能，了解它们在训练数据上的预测精度。较低的均方根误差表示模型的预测结果与实际值之间的误差较小，预测性能较好。 1234567891011121314print(&quot;OLS Model Errors&quot;)print(&quot;Root Mean Squared Error:&quot;, ols_rmse)print(&quot;\\n&quot;)print(&quot;Basic Linear Regression Model Errors&quot;)print(&quot;Root Mean Squared Error:&quot;, train_rmse)print(&quot;\\n&quot;)print(&quot;Linear Regression Model with Recursive Feature Elimination Errors&quot;)print(&#x27;Root Mean Squared Error:&#x27; , train_rmse_rfe)print(&quot;\\n&quot;)print(&quot;Linear Regression Model with Recursive Feature Elimination with Cross Validation Errors&quot;)print(&quot;Root Mean Squared Error:&quot; , train_rmse_rfecv) 输出结果：OLS Model Errors Root Mean Squared Error: 189818.9783572206 Basic Linear Regression Model Errors Root Mean Squared Error: 157757.42505386463 Linear Regression Model with Recursive Feature Elimination Errors Root Mean Squared Error: 206293.18835843043 Linear Regression Model with Recursive Feature Elimination with Cross Validation Errors Root Mean Squared Error: 158517.33695024686 结论：综上，Basic Linear Regression model的均方根误差在所有模型中最低。然而，RMSE并不是模型的全貌。当对各模型的系数进行分析时，观察到以下情况：-基本线性模型在负预测中出现偏斜-RFE线性模型系数表现出最佳平衡。-RFECV线性模型系数异常高，大多数都高于目标值。因此，选择RFE线性回归模型作为最终模型。 5.模型导出1234567with open(&quot;models/regression_model_rfe.pickle&quot;, &quot;wb&quot;) as model: pickle.dump(lm_kc_rfe, model)with open(&quot;models/transform_rfe.pickle&quot;, &quot;wb&quot;) as transform: pickle.dump(kc_rfe, transform)ziplist.to_csv(&quot;data/zipcod_dummy.csv&quot;) 6.预测（模型的使用）6.1导入库1234567import osimport pandas as pdimport numpy as npimport picklepd.options.display.max_columns = 500pd.options.display.max_rows = 500 6.2导入测试集123kc_import_df = pd.read_csv(&quot;data/kc_house_data_test_features.csv&quot;, index_col=0)kc_test_df = kc_import_df #this is done not to adulterate the original filekc_test_df.head() 部分测试集： 6.3 邮政编码伪变量导入注意：导入的数据集应与线性模型相匹配 123ziplist = pd.read_csv(&quot;data/zipcod_dummy.csv&quot;, index_col=0)ziplist = ziplist.zipcodeziplist.head() 输出结果： 6.4特征工程相当于3.特征工程（Feature Engineering） 具体代码： 12345678910111213141516171819202122232425262728293031#renovationkc_test_df[&quot;renovated&quot;] = kc_test_df.yr_renovated.apply(lambda x: 1 if x &gt; 0 else 0)kc_test_df[&quot;renovation_age&quot;] = kc_test_df.yr_renovated.apply(lambda x: 2020-x if x &gt; 0 else 0)#basementkc_test_df[&quot;basement&quot;] = kc_test_df.sqft_basement.apply(lambda x: 1 if x != 0 else 0)#master bathroomkc_test_df[&quot;master_bathroom&quot;] = kc_test_df.bathrooms.apply(lambda x: 1 if x &gt; 2 else 0)#family housekc_test_df[&quot;family_house&quot;] = kc_test_df.bedrooms.apply(lambda x: 1 if x &gt; 2 else 0)#sold year and quarterkc_test_df[&quot;sale_year&quot;] = kc_test_df.date.apply(lambda x: int(x[:4]))kc_test_df[&quot;sale_quarter&quot;] = kc_test_df.date.apply(lambda x: int(x[4:6])//3.1 + 1)#zipcode dummy variableskc_test_df = kc_test_df.merge(pd.get_dummies(ziplist), left_index=True, right_index=True)#squared bedrooms and bathroomskc_test_df[&quot;bedroom_squared&quot;] = kc_test_df[&quot;bedrooms&quot;] ** 2kc_test_df[&quot;bathroom_squared&quot;] = kc_test_df[&quot;bathrooms&quot;] ** 2# uncomment to check the data set# kc_test_df.head()features = [col for col in kc_test_df.columns if col not in [&quot;id&quot;, &quot;date&quot;] ] #remove unused columnkc_test_df_features = kc_test_df[features] #set train/test data using feature above 1kc_test_df_features.head() 输出结果： 1kc_test_df_features.describe() 输出结果： 6.5导入模型与预测价格导入模型： 12345with open(&quot;models/regression_model_rfe.pickle&quot;, &quot;rb&quot;) as model: lr_model_rfe = pickle.load(model)with open(&quot;models/transform_rfe.pickle&quot;, &quot;rb&quot;) as transform: rfe_transform = pickle.load(transform) 根据RFECV变换特征： 1rfe_features = rfe_transform.transform(kc_test_df_features) 房价预测： 123kc_price_predict_rfe = lr_model_rfe.predict(rfe_features)price_prediction_rfe = pd.DataFrame(&#123;&quot;price&quot;:kc_price_predict_rfe&#125;)price_prediction_rfe.describe() 预测结果： 6.6预测结果合并与导出1234567selectedfeatures = []final_model.predict(holdout[sele])kc_import_df = kc_import_df.merge(price_prediction_rfe, left_index=True, right_index=True)#reset columns for exportkc_import_df = kc_import_df[[&#x27;id&#x27;, &#x27;price&#x27;, &#x27;date&#x27;, &#x27;bedrooms&#x27;, &#x27;bathrooms&#x27;, &#x27;sqft_living&#x27;,&#x27;sqft_lot&#x27;, &#x27;floors&#x27;, &#x27;waterfront&#x27;, &#x27;view&#x27;, &#x27;condition&#x27;, &#x27;grade&#x27;,&#x27;sqft_above&#x27;, &#x27;sqft_basement&#x27;, &#x27;yr_built&#x27;,&#x27;yr_renovated&#x27;,&#x27;zipcode&#x27;,&#x27;lat&#x27;,&#x27;long&#x27;,&#x27;sqft_living15&#x27;, &#x27;sqft_lot15&#x27;]]kc_import_df.to_csv(&quot;results/kc_house_price_prediction.csv&quot;)price_prediction_rfe.to_csv(&quot;results/kc_house_price_prediction_no_features.csv&quot;) 根据选定的特征进行房价预测，并将预测结果与其他相关数据进行合并。然后，将合并后的数据保存为名为”kc_house_price_prediction.csv”的CSV文件。最后，将price_prediction_rfe保存为名为”kc_house_price_prediction_no_features.csv”的CSV文件。 四、实验结果首先，对多元线性回归模型、递归特征消除、交叉验证的递归特征消除等回归模型分别进行测试，比较出在预测房价上表现的最好的最稳定的模型：RFE线性回归模型。其次，通过建立好的RFE线性回归模型进行未知房价的数据集的房价预测，得到房价预测表。 五、实验分析此次实验，在多个模型上进行了优劣对比，但在模型考察上只使用了均方根误差（RMSE），往后可以考虑用更多评价指标来对模型进行评估，以此获得更加全面的模型报告。","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"数据挖掘","slug":"课程笔记/数据挖掘","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"},{"name":"实验报告","slug":"课程笔记/数据挖掘/实验报告","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"}],"tags":[]},{"title":"","slug":"culitivate/other/机器学习/三剑客","date":"2023-06-03T04:22:06.767Z","updated":"2023-09-20T08:42:18.846Z","comments":true,"path":"2023/06/421b0a24131a.html","link":"","permalink":"http://example.com/2023/06/421b0a24131a.html","excerpt":"","text":"Pandas用frame[‘列名’]可直接获取[[爬虫]]该列数据 用loc是直接改变，是一种引用而[]切片只是副本 df[]$是列标签索引df[[列标签]],不支持切片$当df[1:3]时可以选取1到2行数据,不可只传入一个整数,只支持切片操作选取行只有一个参数，要么是行标签要么是列标签 $.loc[:,:]&#x2F;.loc[[列表],[列表]]$在行标签没有用字符串重命名时，行标签可用整数此外，行标签列标签只能用标签索引.loc[整数]只能选取标签数值是该数的行数据 $.ilco[:,:]&#x2F;.iloc[[列表],[列表]]$只能用整数索引 rename(colums&#x3D;{字典},index&#x3D;{字典},inplace&#x3D;True)当inplace为false时返回更改后的副本对象，而本身不做更改当为true时，直接更改原对象，不返回 reindex(index&#x3D;[列表],colums&#x3D;[列表])重置标签索引，选取原数据中的标签组成新dataframe若无该标签则为NaN返回更改后的副本对象，而本身不做更改 concat与merge(96条消息) pandas数据的合并concat()和merge()_pandas数据合并concat和merge_蓝小白1024的博客-CSDN博客(96条消息) pandas中DF拼接：concat，merge，join，append方法区别_df.concat_Lian_Ge_Blog的博客-CSDN博客 shape在NumPy中，shape 属性返回一个元组，表示数组的维度。例如，如果你有一个2行3列的二维数组，那么 shape 属性将返回 (2, 3)。 在Pandas中，shape 属性也返回一个元组，表示DataFrame或Series的维度。对于DataFrame，shape 属性返回 (n, m)，其中 n 是行数，m 是列数。对于Series，shape 属性返回一个只有一个元素的元组，例如 (n,)，其中 n 是元素的数量。","categories":[{"name":"culitivate","slug":"culitivate","permalink":"http://example.com/categories/culitivate/"},{"name":"other","slug":"culitivate/other","permalink":"http://example.com/categories/culitivate/other/"},{"name":"机器学习","slug":"culitivate/other/机器学习","permalink":"http://example.com/categories/culitivate/other/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"","slug":"课程笔记/python/报告","date":"2023-06-03T02:37:06.640Z","updated":"2023-09-20T08:42:18.828Z","comments":true,"path":"2023/06/611c274db787.html","link":"","permalink":"http://example.com/2023/06/611c274db787.html","excerpt":"","text":"碳排放数据分析与可视化一、1997-2019年中国各省随时间变化的碳排放量折线图数据简述数据集包含1997-2019年中国各省的碳排放量，每年的排放清单又包括30个省份的碳排放量细则与汇总 数据准备由于数据是以每年为一个sheet进行分类的，所以需要提取每年每个省的总数据到一个DataFrame中，以下是数据提取的代码： 12345678910def getdata(path): df=pd.DataFrame() countdata=pd.DataFrame() for i in range(1997,2020): df=pd.read_excel(path,sheet_name=str(i)) df=df.iloc[0:5,2:32] df=df.drop([0,1,2,3]).reset_index(drop=True) df.insert(0,&#x27;year&#x27;,str(i)) countdata=pd.concat([countdata,df]) return countdata.reset_index(drop=True) 通过以上代码，将数据提取成以以年份为列，省份为行的格式，部分数据效果如下图： 数据分析通过以下代码对数据获取每年的碳排放量汇总以及均值，对数据继续分析(1)获取每年的碳排放量的汇总与最大值，并绘制折线图，来直观判断1997-2019年碳排放量的总体趋势 12345678# 获取汇总与平均 year_data=[] year_datacount=[] year_datamax=[] for i in range(23): year_data.append(data.iloc[i,1:].values.tolist()) year_datacount.append(sum(year_data[i])) year_datamax.append(max(year_data[i])) (2)绘制每年碳排放量最大值的折线图 (3)绘制每年碳排放量总和的折线图 数据绘制之后进行数据的分析与绘制把年份信息，省份信息，以及每个省份的碳排放量信息提取成列表，代码如下： 12345year=data[&#x27;year&#x27;].tolist() province=data.columns.values[1:] province_data=[]for i in range(0,30): province_data.append(data[province[i]].tolist()) 通过以上列表进行省份碳排放量随时间变化的折线图绘制，下图是以北京为例： 具体绘制代码： 1234plt.plot(year, province_data[0], color=&#x27;g&#x27;, marker=&#x27;D&#x27;, markersize=5, label=province[0])# 图例plt.legend(province[0:1]) plt.show() 效果图： 所有省份的绘制代码： 1234567891011plt.figure()# 获取颜色映射cmap = cm.get_cmap(&#x27;jet&#x27;) # &#x27;jet&#x27;是一个颜色映射的名字，颜色之间的差距比较大# 生成一个等差数列，长度为30colors = cmap(np.linspace(0, 1, 30))# 循环绘制for i in range(0,30): plt.plot(year, province_data[i], color=colors[i], marker=&#x27;D&#x27;, markersize=5, label=province[i])# 图例plt.legend(province) plt.show() 效果图： 二、2019年五个省份不同部门碳排放量的柱状图数据简述：数据集包含2019年30个省份的排放清单，每个省份的排放清单又包括47个部门的碳排放量细则与汇总 数据准备：为了统计与分析，从数据集中抽取五个部门在10个省份的碳排放量，汇总成新的DataFrame，代码如下： 1234567891011def getpartdata(path): province=[&#x27;Shanghai2019&#x27;,&#x27;Beijing2019&#x27;,&#x27;Guangxi2019&#x27;\\ ,&#x27;Jiangsu2019&#x27;,&#x27;Fujian2019&#x27;,&#x27;Chongqing2019&#x27;] countdata=pd.DataFrame() for i in province: df=pd.read_excel(path,sheet_name=i).iloc[30:35,[0,22]]\\ .rename(columns=&#123;&#x27;范围_1_总计&#x27;: i&#125;) if i==&#x27;Shanghai2019&#x27;: countdata=df else: countdata=pd.merge(countdata, df) 提取出的DataFrame如下图: 数据分析通过以下代码对数据获取最大值，最小值，以及平均值，获取数据的基本信息(1)获取每个省五个部门的排放平均量 1234avg=[] for i in province: avg.append(countdata[i].sum()/len(countdata[i])) print(avg) 输出结果：$[6.688247267237283, 0.12788708485960373, 11.165378112481232, 39.82381083666304, 7.630868627404693, 3.053621319875066]$通过数据可看出北京的平均排放量最低，江苏的平均排放量最高。(2)获取每个部门在五个省中碳排放的最大值与最小值，并用字典输出相关信息： 123456789max=&#123;&#125; min=&#123;&#125; for i in range(5): maxindex=np.argmax(countdata.iloc[i,1:]) max[parts[i]]=province[maxindex]+&#x27;:&#x27;+str(countdata.iloc[i,1:].max()) minindex = np.argmin(countdata.iloc[i, 1:]) min[parts[i]] = province[minindex] + &#x27;:&#x27; + str(countdata.iloc[i, 1:].min()) print(max) print(min) 输出结果：最大值：{‘黑色金属的冶炼和压制’: ‘Jiangsu2019:189.36761446896122’, ‘有色金属冶炼与压制’: ‘Guangxi2019:20.728637306979614’, ‘金属制品’: ‘Jiangsu2019:1.124787686428541’, ‘普通机械’: ‘Jiangsu2019:6.28855042346841’, ‘特殊用途设备’: ‘Jiangsu2019:0.8906691982079363’}最小值：{‘黑色金属的冶炼和压制’: ‘Beijing2019:0.02246408503574667’, ‘有色金属冶炼与压制’: ‘Beijing2019:0.012429511920685107’, ‘金属制品’: ‘Fujian2019:0.1791310869326789’, ‘普通机械’: ‘Guangxi2019:0.14851084462394454’, ‘特殊用途设备’: ‘Chongqing2019:0.04581406518438616’} 数据绘图为了更直观地了解数据信息，将上述数据以柱状图的形式绘制出。代码如下： 1234567891011121314151617X = np.arange(5) fig = plt.figure() # 添加子图区域 ax = fig.add_axes([0.2, 0.2, 0.6, 0.6]) ax.set_ylim([0, 50]) # 绘制柱状图 ax.bar(X + 0.00, procince_data[0], color = &#x27;b&#x27;, width = 0.15,label=province[0]) ax.bar(X + 0.15, procince_data[1], color = &#x27;y&#x27;, width = 0.15,label=province[1]) ax.bar(X + 0.30, procince_data[2], color = &#x27;r&#x27;, width = 0.15,label=province[2]) ax.bar(X + 0.45, procince_data[3], color = &#x27;c&#x27;, width = 0.15,label=province[3]) ax.bar(X + 0.60, procince_data[4], color = &#x27;m&#x27;, width = 0.15,label=province[4]) ax.bar(X + 0.75, procince_data[5], color = &#x27;y&#x27;, width = 0.15,label=province[5]) ax.legend() # 设置x轴的刻度和刻度标签 ax.set_xticks(X + 0.3) ax.set_xticklabels(parts)plt.show() 绘制结果如下： 由于黑色金属的冶炼和压制与其他部门的数据差过大，因此将其与其他部门分开绘制：黑色金属的冶炼和压制的绘制代码： 1234567# 创建图形对象 fig = plt.figure() # 添加子图区域，参数值表示[left, bottom, width, height ] ax = fig.add_axes([0.2, 0.2, 0.6, 0.6]) # 绘制柱状图 ax.bar(province, data.iloc[0,1:]) plt.show() 绘制结果： 其他部门绘制代码： 1234567891011121314X = np.arange(4) fig = plt.figure() # 添加子图区域 ax = fig.add_axes([0.2, 0.2, 0.6, 0.6]) ax.set_ylim([0, 10]) # 绘制柱状图 ax.bar(X + 0.00, procince_data[0][1:], color = &#x27;b&#x27;, width = 0.15,label=province[0]) ax.bar(X + 0.15, procince_data[1][1:], color = &#x27;y&#x27;, width = 0.15,label=province[1]) ax.bar(X + 0.30, procince_data[2][1:], color = &#x27;r&#x27;, width = 0.15,label=province[2]) ax.bar(X + 0.45, procince_data[3][1:], color = &#x27;c&#x27;, width = 0.15,label=province[3]) ax.bar(X + 0.60, procince_data[4][1:], color = &#x27;m&#x27;, width = 0.15,label=province[4]) ax.bar(X + 0.75, procince_data[5][1:], color = &#x27;y&#x27;, width = 0.15,label=province[5]) ax.legend() plt.show() 其他部门绘制结果：","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"python","slug":"课程笔记/python","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/python/"}],"tags":[]},{"title":"","slug":"课程笔记/数据挖掘/作业/电子版作业汇总","date":"2023-06-02T04:56:53.271Z","updated":"2023-09-20T08:42:18.847Z","comments":true,"path":"2023/06/806ee691561a.html","link":"","permalink":"http://example.com/2023/06/806ee691561a.html","excerpt":"","text":"第一章 思考题1. 按照科学进化论的观点，从古至今经历了哪些阶段，请简单介绍答：（1）17世纪之前：经验科学。 人们根据经验，总结归纳出可能的因果关系的结论，但内部的逻辑不一定清晰。（2）17-20世纪50年代: 理论科学。 每个学科都有很大的发展，形成了理论模型，帮助人们更好地认识世界。（3）20世纪50s-90s:计算机科学。 由于计算机与关系型数据库、结构化查询语言的发展，人们可以更好地管理、查询与处理分析数据。（4）20世纪90年代至今：数据科学。 因高级数据仓库、数据算法等技术的发展，能够有效地管理分析大数据，能够从数据中获取知识，甚至预测数据。 2. 知识发现分哪些步骤，请简单介绍各步骤的主要功能答：1.数据清理：消除数据中的噪声和删除不一致的数据2.数据集成：将不同来源的数据组合在一起3.数据选择：从数据库中提取、分析与任务相关的数据4.数据变换：通过汇总或聚集操作，把数据变换和统一成适合挖掘的形式5.数据挖掘：使用智能方法提取数据模式6.模式评估：根据某种兴趣度度量，识别代表知识的真正的有趣的模式7.知识表示：将挖掘到的知识用可视化的技术表示出来，使用可视化和知识表示技术，向用户提供挖掘的知识 3. 数据挖掘为什么会涉及到许多学科？请给出理由答：数据挖掘之所以涉及到许多学科，与数据挖掘的步骤息息相关。在数据集成、变换、选择等阶段，不仅仅需要计算机学科的知识来获取大量数据，还需要统计学的知识来提取分析数据，以及机器学习等学科来提取数据模式。 第二章 思考题1. 请解释并举例说明什么是标称属性，什么是二元属性，什么是序数属性答：标称属性的值是一些符号或事物的名称，每个值代表某种类别、编码或状态，可以看成是用于分类、枚举的。例子：性别属性：男、女；头发颜色属性 二元属性是一种只有两种状态（0或1）的标称属性，有对称的二元属性（两种状态同样重要）与非对称二元属性（重要性不相等）之分。例子：对称二元属性：性别；非对称二元属性：医学检测的阴性与阳性 序数属性其可能的值之间具有有意义的序或秩评定，但是相继值之间的差是未知的。例子：杯子的型号属性：小、中、大 2. 数据的中心趋势测度有哪几个参数，请解释它们各自的含义答：有均值、中位数、众数这三个参数。 均值：数据集的平均值$$ $\\bar{x}&#x3D;\\frac{\\sum\\limits_{i&#x3D;1}^{n}x_i}{n}$$均值又有加权平均$$\\bar{x}&#x3D;\\frac{\\sum_{i&#x3D;1}^{n}w_{i}x_{i}}{\\sum_{i&#x3D;1}^{n}w_i}$$以及截尾均值：丢弃高低极端值后的均值 中位数：有序数据值的中间值 众数：集合中出现最频繁的值 3. 盒图有哪几个数据点构成？请解释各个点的含义答：由Minimun,Q1,Median,Q3,Maximun，离群点五个数据点构成 Mininum:数据集的最小值Q1：数据集的第一个百分位Median:中位数Q3：第三个百分位Maximum:数据集中的最大值离群点：超出指定的值，单独标记 4. 直方图的横坐标和纵坐标分别表示什么，它可以用来观察数据的什么情况答：横坐标表示值，纵坐标表示频数 用来观察数据的不同值的频率发布情况 5. 散点图是由什么构成的，有什么作用答：是由代数坐标对在坐标轴中形成的的散点构成。作用：用于确定两个数值变量之间看上去是否存在联系、模式、或趋势。 6. 什么是对称二元标称属性，什么是非对称二元标称属性？计算它们之间的距离有什么不同？答：对称二元属性：两种状态同样重要非对称二元属性：两种状态重要性不相等 对称二元属性的距离测度考虑两个实体属性同时取0的情况；而非对称二元属性的距离测度则忽略，两个实体属性同时取0的情况，不参与计算。 7. Minkowski 距离有哪些性质？L1 norm，L2 norm和$L_{\\infty}$ norm分别表示什么情况下的取值？答：性质： $d(i, j) &gt; 0$ if $i ≠ j, and d(i, i) &#x3D; 0$（正定性） $d(i,j)&#x3D;d(j,i)$（对称性） $d(i,j)\\leq d(i,k)+d(k,j)$（三角不等式） L1 norm：h&#x3D;1，哈曼顿距离（直线距离）L2 norm：h&#x3D;2，欧几里得距离$L_{\\infty}$ norm：h-&gt;无穷，切比雪夫距离 第三章 思考题1. 衡量数据质量主要考察哪些方面？答：主要考察数据的精确度、完整性、一致性、时效性、可行性、可解释性 2. 数据预处理主要有哪些工作？答：数据清洗、数据集成、数据规约、数据转换和离散 3. 自动填充缺失数据主要包含哪些方法？请解释其适用范围答：方法：（1）用一个全局常量替代（2）用属性的均值来填充（3）属于同一类的所有样本的属性均值（4）最可能值：基于贝叶斯公式或决策树的推断适用范围：（1）数据集属性分布比较均匀，缺失数据比较少。（2）属性之间的关系比较简单，缺失数据的影响不会对数据分析和建模产生较大影响。（3）缺失数据随机分布，没有明显的规律和模式。（4）数据集的规模较大，数据质量较好，可以保证填充缺失数据的准确性和可靠性。（5）对于特定的数据类型和应用场景，存在合适的自动填充缺失数据的方法。 4．处理噪声数据主要有哪些方法，请介绍各方法的思路答：（1）分箱 思路：首先将数据排序并划分到等频的箱中；然后用箱的均值&#x2F;中位数&#x2F;边界等光滑箱中数据（2）回归 思路：用一个函数拟合数据来光滑数据（3）离群点分析&#x2F;聚类 思路：将类似的值组织成群或“簇”。落在簇集合之外的值被视为离群点（4）组合方法 思路：检测可疑值并由人工检查（例如，处理可能的异常值） 5. 标称数据的相关性分析可以采用什么方法，请叙述其具体步骤答：采用卡方分析（检验）具体步骤：对于要分析的两个属性，先计算不同取值下对应的期望频率，再将观测频率代入卡方分析公式$$\\chi^{2}&#x3D;\\sum\\frac{(Observed-Expected)^2}{Expected}$$计算出$\\chi^{2}$，$\\chi^{2}$值越大，两属性越可能相关 第四章 思考题1. 请解释W. H. Inmon所定义的数据仓库是面向主题的，集成的，时变得，非易失的数据集合的含义答：面向主题的：数据仓库中的数据围绕一些重要主题。数据仓库关注决策者的数据建模与分析，排除对于决策无用的数据，提供特定主题的简明视图。 集成的：构造数据仓库是将多个异构数据源集成在一起，通过数据清理和数据集成技术，确保命名约定、编码结构、属性度量等的一致性。 时变的：数据存储从历史的角度提供信息，时间跨度大。数据仓库中的关键结构都隐式或显示地包含时间元素。 非易失的：数据仓库总是物理地分离存放数据。数据仓库不需要事务处理、恢复和并发控制机制。通常只需要两种数据访问操作：数据的初始化装入和数据访问。 2. 数据仓库的概念模型有哪些？请予以解释它们之间的异同答：有星型模式、雪花模式、事实星座模式 异同如下：星型模式：只有一个大的中心表（事实表）和一组小的维表（附属表），每维只有一个维度表，事实表和维度表之间是一对多的关系。查询速度快、易于理解，但可能会存在数据冗余 雪花模式：是星型模式的变种，在其基础上进一步规范化，通过拆分某些维度表中的属性将其转化为单独的表，以便减少冗余。具有更高的数据质量和更高规范化程度，但查询需要更多的连接操作，降低查询效率。 事实星座模式：具有多个事实表，并且可能共享维表，可以看做星型模式的汇集。查询速度较快，但维护复杂度相对较高。 3. 数据立方体度量有哪些？count(), avg(), median()各分别属于哪一种？答：有分布的、代数的和整体的count():分布的avg():代数的median():整体的 第五章 思考题1. 什么是模式？满足什么条件的模式称之为频繁模式？答：模式：出现在数据集中的项集、子序列或子结构频繁模式：满足最小支持度阈值的模式 2. 有如表1所示的事务数据库，设minsup&#x3D;50%,minconf&#x3D;50%.表1 事务数据库 Id Items bought 10 Beer, Nuts, Diaper 20 Beer, Coffee, Diaper 30 Beer, Diaper, Eggs 40 Nuts, Eggs, Milk 50 Nuts, Coffee, Diaper, Eggs, Milk （1）请查询得出所有的频繁项集频繁1项集：{Beer},{Nuts},{Diaper},{Eggs}频繁2项集：{Beer,Diaper} （2）计算下面两个关联规则的支持度和置信度Beer-&gt;Diaper支持度：60%；置信度：100%Diaper-&gt;Beer支持度：60%；置信度：75% 3.什么是闭模式？什么是极大模式？现有DB &#x3D; {&lt;a1, …, a100&gt;, &lt; a1, …, a50&gt;}设min_sup &#x3D; 1.。试分析：&lt;a1, …, a100&gt;和&lt; a1, …, a50&gt;，哪些是闭模式，哪些是极大模式，说明原因答：闭模式：X是闭模式，则X本身是频繁项集且不存在真超项集使得真超项集与其在数据集中具有相同的支持度计数。极大模式：X是极大频繁项集，则如果X是频繁的且不存在频繁的真超项集。 &lt;a1, …, a100&gt;和&lt; a1, …, a50&gt;都是闭模式，因为首先他们都是频繁项集，最小支持度大于等于1，其次不存在真超项集与其具有相同的支持度计数。&lt; a1, …, a100&gt;是极大模式，因为其本身是频繁的，其次不存在真超项集，更不用说存在是频繁的真超项集。 4．一个频繁项集的子集是否一定是频繁的？一个频繁项集的超集是否一定是频繁的？一个非频繁项集的子集是否一定是非频繁的？一个非频繁项集的超集是否一定是非频繁的？答：（1）一定（2）不一定（3）不一定（4）一定 5. 掌握Apriori挖掘频繁项集的算法。12345678910111213141516171819Ck:Candidate itemset of size kLk:frequent itemset of size kL1=&#123;frequent items&#125;;for(k=1;Lk!=空集;k++)do begin Ck+1=candidates generated form Lk; For each transaction t in database do Increment the count of all candidates in Ck+1 that are contained in t; Lk+1=candidates in Ck+1 with min_suppor; EndReturn U Lk；(并上所有Lk) 6. 什么是单调约束条件？什么是反单调约束条件？试分析下面的约束哪些是单调的，哪些是反单调的，说明原因：（S是项集） （1）sum(S.price)&lt;&#x3D;100 （2）range(S.profit)&lt;&#x3D;20 （3）sum(S.Price)&gt;&#x3D;100 （4）min(S.Price)&lt;&#x3D;15答：单调约束：对满足约束的项集，向此项集中添加更多的项，但总满足约束，因此在此项集上检查该约束是多余的。即如果项集满足这个规则约束，则它的所有超集也满足。如果一个约束规则具有这种性质则称它是单调的。 反单调约束：对于已经违反约束的项集，向此项集内添加更多的项不可能满足这些约束，此时应该直接丢弃此项集。即如果项集违反规则约束，则它的所有超集也违反。如果一个约束规则具有这种性质则称它是反单调的。 （1）、（4）是反单调的。因为一旦项集和已经超过价格约束再添加任何一件商品其价格总和必将增加，必违反约束。即其超项集是违反约束的。 （3）是单调的。因为一旦项集的总价满足约束（大于100）再添加任何项只会使总价增加，即其超项集是满足约束的。 （2）既不是单调也不是反单调的。因为利润可能为负值。项集的利润和并不随着项集中项的个数增加而增加。 第六章 思考题表1 购买记录 age income student credit_rating buys_computer &lt;&#x3D;30 high no fair no &lt;&#x3D;30 high no excellent no 31…40 high no fair yes &gt;40 medium no fair yes &gt;40 low yes fair yes &gt;40 low yes excellent no 31…40 low yes excellent yes &lt;&#x3D;30 medium no fair no &lt;&#x3D;30 low yes fair yes &gt;40 medium yes fair yes &lt;&#x3D;30 medium yes excellent yes 31…40 medium no excellent yes 31…40 high yes fair yes &gt;40 medium no excellent no 1.购买记录如表1所示，(1)用信息增益法建立一棵完整的决策树$$Info(D)&#x3D;-\\frac{9}{14}\\log_2^{\\frac{9}{14}}-\\frac{5}{14}\\log_2^{\\frac{5}{14}}&#x3D;0.940$$$$Info_{age}(D)&#x3D;\\frac{5}{14}(-\\frac{2}{5}\\log_2^{\\frac{2}{5}}-\\frac{3}{5}\\log_2^{\\frac{3}{5}})+\\frac{4}{14}(-\\frac{4}{4}\\log_2^{\\frac{4}{4}}-\\frac{0}{4}\\log_2^{\\frac{0}{4}})+\\frac{5}{14}*(-\\frac{3}{5}\\log_2^{\\frac{3}{5}}-\\frac{2}{5}\\log_2^{\\frac{2}{5}})&#x3D;0.694$$$$Gain(age)&#x3D;Info(D)-Info_{age}(D)&#x3D;0.940-0.694&#x3D;0.264$$同理可计算得$$Gain(income)&#x3D;0.029;Gain(student)&#x3D;0.151;Gain(credit_-rating)&#x3D;0.048$$综上，age在属性中有最大信息增益，所以被选作划分属性：根节点用age标记，以age属性的三种属性值生长出对应分支。由于age属性值为31…40的分支buys_Computer属性值全为yes，所以直接用yes标记该叶节点。 接着，对age取&lt;&#x3D;30与&gt;40分别进行上述计算。对于age取&lt;&#x3D;30分支：$$Info(D_1)&#x3D;-\\frac{2}{5}\\log_2^{\\frac{2}{5}}-\\frac{3}{5}\\log_2^{\\frac{3}{5}}&#x3D;0.529+0.442&#x3D;0.971$$$$Info_{income}(D_1)&#x3D;\\frac{2}{5}(-\\frac{2}{2}\\log_2^{\\frac{2}{2}}-\\frac{0}{2}\\log_2^{\\frac{0}{2}})+\\frac{2}{5}(-\\frac{1}{2}\\log_2^{\\frac{1}{2}}-\\frac{1}{2}\\log_2^{\\frac{1}{2}})+\\frac{1}{5}(-\\frac{1}{1}\\log_2^{\\frac{1}{1}}-\\frac{0}{1}\\log_2^{\\frac{0}{1}})&#x3D;0+0.4+0&#x3D;0.4$$$$Gain(income)&#x3D;Info(D_1)-Info_{income}(D_1)&#x3D;0.971-0.4&#x3D;0.571$$同理可计算得$$Info_{student}(D_1)&#x3D;\\frac{3}{5}(-\\frac{3}{3}\\log_2^{\\frac{3}{3}}-\\frac{0}{3}\\log_2^{\\frac{0}{3}})+\\frac{2}{5}(-\\frac{2}{2}\\log_2^{\\frac{2}{2}}-\\frac{0}{2}\\log_2^{\\frac{0}{2}})&#x3D;0$$$$Gain(student)&#x3D;Info(D_1)-Info_{income}(D_1)&#x3D;0.971$$$$Info_{student}(D_1)&#x3D;\\frac{3}{5}(-\\frac{2}{3}\\log_2^{\\frac{2}{3}}-\\frac{1}{3}\\log_2^{\\frac{1}{3}})+\\frac{2}{5}*(-\\frac{1}{2}\\log_2^{\\frac{1}{2}}-\\frac{1}{2}\\log_2^{\\frac{1}{2}})&#x3D;0.951$$$$Gain(credit_-rating)&#x3D;Info(D_1)-Info_{credit_-rating}(D_1)&#x3D;0.020$$综上，student属性具有最大信息增益，所以选取其为划分属性。又属性值no分支下类标记全为no，所以用no类标签标记该叶节点；同理，属性值yes分支下类标记全为yes，所以用yes类标签标记该叶节点。 对于age取&gt;40分支：$$Info(D_2)&#x3D;-\\frac{3}{5}\\log_2^{\\frac{3}{5}}-\\frac{2}{5}\\log_2^{\\frac{2}{5}}&#x3D;0.971$$$$Info_{credit_-rating}(D_2)&#x3D;\\frac{3}{5}(-\\frac{3}{3}\\log_2^{\\frac{3}{3}}-\\frac{0}{3}\\log_2^{\\frac{0}{3}})+\\frac{2}{5}(-\\frac{2}{2}\\log_2^{\\frac{2}{2}}-\\frac{0}{2}\\log_2^{\\frac{0}{2}})&#x3D;0$$$$Gain(credit_-rating)&#x3D;Info(D_2)-Info_{credit_-rating}(D_2)&#x3D;0.971$$所以，credit_rating属性具有最大信息增益，所以选取其为划分属性。又属性值fair分支下类标记全为yes，所以用yes类标签标记该叶节点；同理，属性值excellent分支下类标记全为no，所以用no类标签标记该叶节点。最终所得决策树如下图： (2)用Bayes分类法判断X &#x3D; (age &lt;&#x3D;30, income &#x3D;medium, student &#x3D; yes, credit_rating &#x3D; Fair)是否购买电脑P(Ci): P(buys_computer &#x3D; “yes”) &#x3D; 9&#x2F;14 &#x3D; 0.643 P(buys_computer &#x3D; “no”) &#x3D; 5&#x2F;14&#x3D; 0.357Compute P(X|Ci) for each class P(age &#x3D; “&lt;&#x3D;30” | buys_computer &#x3D; “yes”) &#x3D; 2&#x2F;9 &#x3D; 0.222P(age &#x3D; “&lt;&#x3D; 30” | buys_computer &#x3D; “no”) &#x3D; 3&#x2F;5 &#x3D; 0.6P(income &#x3D; “medium” | buys_computer &#x3D; “yes”) &#x3D; 4&#x2F;9 &#x3D; 0.444 P(income &#x3D; “medium” | buys_computer &#x3D; “no”) &#x3D; 2&#x2F;5 &#x3D; 0.4 P(student &#x3D; “yes” | buys_computer &#x3D; “yes) &#x3D; 6&#x2F;9 &#x3D; 0.667 P(student &#x3D; “yes” | buys_computer &#x3D; “no”) &#x3D; 1&#x2F;5 &#x3D; 0.2 P(credit_rating &#x3D; “fair” | buys_computer &#x3D; “yes”) &#x3D; 6&#x2F;9 &#x3D; 0.667 P(credit_rating &#x3D; “fair” | buys_computer &#x3D; “no”) &#x3D; 2&#x2F;5 &#x3D; 0.4X &#x3D; (age &lt;&#x3D; 30 , income &#x3D; medium, student &#x3D; yes, credit_rating &#x3D; fair)P(X|Ci) : P(X|buys_computer &#x3D; “yes”) &#x3D; 0.222 x 0.444 x 0.667 x 0.667 &#x3D; 0.044 P(X|buys_computer &#x3D; “no”) &#x3D; 0.6 x 0.4 x 0.2 x 0.4 &#x3D; 0.019 P(X|Ci)*P(Ci) : P(X|buys_computer &#x3D; “yes”) * P(buys_computer &#x3D; “yes”) &#x3D; 0.028 P(X|buys_computer &#x3D; “no”) * P(buys_computer &#x3D; “no”)&#x3D;0.007因此，X&#x3D;(age &lt;&#x3D;30, income &#x3D;medium, student &#x3D; yes, credit_rating &#x3D; Fair)购买电脑。 2. 已知混淆矩阵如表2所示，完成下列工作：(1)解释表格中100、12、10和90分别表示什么含义100：被正确分类的正例数目12：被错误标记为负例的正例数目10：被错误标记为正例的负例数目90：被正确分类的负例数目 (2)分别计算混淆矩阵中的准确率（accuracy）、灵敏性（sensitivity）和特指性（specificity）的值 表2 混合矩阵 actual class &#x2F;prediction class buy_computer&#x3D;yes buy-computer&#x3D;no total buy_computer&#x3D;yes 100 12 112 buy-computer&#x3D;no 10 90 100 total 110 102 212 accuracy: $$accuracy&#x3D;\\frac{TP+TN}{P+N}&#x3D;\\frac{100+90}{212}&#x3D;0.896$$ sensitivity: $$sensitivity&#x3D;\\frac{TP}{P}&#x3D;\\frac{100}{112}&#x3D;0.893$$ specificity: $$specificity&#x3D;\\frac{TN}{N}&#x3D;\\frac{90}{100}&#x3D;0.900$$","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"数据挖掘","slug":"课程笔记/数据挖掘","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"},{"name":"作业","slug":"课程笔记/数据挖掘/作业","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/%E4%BD%9C%E4%B8%9A/"}],"tags":[]},{"title":"","slug":"project/2023暑期项目health/que","date":"2023-05-29T08:22:03.078Z","updated":"2023-09-20T08:42:18.828Z","comments":true,"path":"2023/05/2a01fc38f096.html","link":"","permalink":"http://example.com/2023/05/2a01fc38f096.html","excerpt":"","text":"上传文件到图床Spring boot 上传文件到腾讯云对象储存COS（完整步骤流程）-羊毛之家 (yangmao.info) 传参(108条消息) SpringBoot getpost请求详解_springboot接收参数get和post请求_普通网友的博客-CSDN博客","categories":[{"name":"project","slug":"project","permalink":"http://example.com/categories/project/"},{"name":"2023暑期项目health","slug":"project/2023暑期项目health","permalink":"http://example.com/categories/project/2023%E6%9A%91%E6%9C%9F%E9%A1%B9%E7%9B%AEhealth/"}],"tags":[]},{"title":"","slug":"课程笔记/安卓论文/速记","date":"2023-05-29T06:15:41.293Z","updated":"2023-09-20T08:42:18.829Z","comments":true,"path":"2023/05/6b268dbe32a4.html","link":"","permalink":"http://example.com/2023/05/6b268dbe32a4.html","excerpt":"","text":"![[流程图.svg]] 以部门为地区 PA PB PC p1 p2 p3 p4 p5 total上海 1 2 3 4 5 6北京 5 6 7 5 9","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"安卓论文","slug":"课程笔记/安卓论文","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E5%AE%89%E5%8D%93%E8%AE%BA%E6%96%87/"}],"tags":[]},{"title":"","slug":"课程笔记/安卓论文/论文","date":"2023-05-29T05:52:32.648Z","updated":"2023-09-20T08:42:18.828Z","comments":true,"path":"2023/05/996a911d2c4b.html","link":"","permalink":"http://example.com/2023/05/996a911d2c4b.html","excerpt":"","text":"置顶 12345678FloatingActionButton scrollToTopButton = root.findViewById(R.id.scrollToTopButton);scrollToTopButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; recyclerView.smoothScrollToPosition(0); &#125;&#125;); 12345678910&lt;com.google.android.material.floatingactionbutton.FloatingActionButton android:id=&quot;@+id/scrollToTopButton&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentEnd=&quot;true&quot; android:layout_alignParentBottom=&quot;true&quot; android:layout_margin=&quot;16dp&quot; android:src=&quot;@drawable/ic_arrow_upward&quot; app:backgroundTint=&quot;@color/colorPrimary&quot; /&gt;","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"安卓论文","slug":"课程笔记/安卓论文","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E5%AE%89%E5%8D%93%E8%AE%BA%E6%96%87/"}],"tags":[]},{"title":"","slug":"README","date":"2023-05-28T02:59:52.528Z","updated":"2023-05-28T03:09:53.964Z","comments":true,"path":"2023/05/f0287de22e27.html","link":"","permalink":"http://example.com/2023/05/f0287de22e27.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"课程笔记/数据挖掘/第六章 分类","date":"2023-05-26T02:15:43.069Z","updated":"2023-09-20T08:42:18.829Z","comments":true,"path":"2023/05/2beb34271b81.html","link":"","permalink":"http://example.com/2023/05/2beb34271b81.html","excerpt":"","text":"分类的一般方法数据分类分为两个阶段： 学习阶段：模型建立&#x2F;构建分类模型 分类阶段：使用模型预测给定数据的类标号利用模型预测 具体模型决策树决策树的构造基本流程决策树的一般流程(1)收集数据:可以使用任何方法。(2)准备数据:树构造算法只适用于标称型数据，因此数值型数据必须离散化。(3)分析数据:可以使用任何方法，构造树完成之后，我们应该检查图形是否符合预期。(4)训练算法:构造树的数据结构。(5)测试算法:使用经验树计算错误率。(6)使用算法:此步骤可以适用于任何监督学习算法，而使用决策树可以更好地理解数据的内在含义。 决策树归纳算法基于贪婪算法树以&#x3D;&#x3D;自上而下的递归分而治之&#x3D;&#x3D;的方式构造 1234567891011121314151617def Generate_decisicion_tree 创建一个结点N(一开始所有元组都在根节点) if D中的元组都在一个类C中: 返回N作为叶节点，以类C标记 if 剩余属性为空： 返回N作为叶节点，标记为D中的多数类 调用Attribute_selection_method(D,attribute_list)找出最优划分属性splittiong_attribute 使用splittiong_attribute标记结点N if 划分属性splittiong_attribute是离散的且允许多路划分： 从attribute_list中删除splittiong_attribute for splittiong_attribute的每个输出j //划分元组并对每个分区产生子树 设Dj是D中满足j的数据元组的集合 if Dj为空： 创捷叶节点，用D中的多数类 else 加一个由Attribute_selection_method(Dj,attribute_list)返回的结点N 返回N； 递归划分的终止条件： 分区D的所有元组属于同一个类 没有剩余属性用于划分，用多数类标记 给定分支没有元组，用多数类标记 最优划分属性的选择1.信息增益&#x3D;&#x3D;“信息嫡”(information entropy)：&#x3D;&#x3D;是度量样本集合纯度最常用的一种指标.假定当前样本集合D中第k类样本所占的比例为$p_{k}$(k &#x3D; 1,2,…, $|y|$)则D的信息嫡定义为（对D中的元组分类所需要的期望信息）$$Info(D)&#x3D;Ent(D)&#x3D;-\\sum_{k&#x3D;1}^{|y|}p_{k}log_{2}^{p_{k}}$$熵（期望信息）越小，分区的纯度越高&#x3D;&#x3D;信息增益：&#x3D;&#x3D;假定离散属性a有V个可能的取值{$a^{1},a^{2},…,a^{v}$}则用属性a对样本集D进行划分的“信息增益”为：$$Gain(A)&#x3D;Info(D)-Info_{A}(D)(学校)$$$$Gain(D,a)&#x3D;Ent(D)-\\sum_{v&#x3D;1}^{V}\\frac{|D^v|}{|D|}Ent(D^{v})$$最优划分属性即最大信息增益&#x3D;&#x3D;特点：&#x3D;&#x3D;结果偏向具有大量属性值的属性&#x3D;&#x3D;使用此方法的算法：&#x3D;&#x3D;ID3 2.增益率为减少信息增益准则对可能取值数目较多的属性有所偏好用“分裂信息”(学校)&#x2F;固有值将信息增益规范化&#x3D;&#x3D;增益率：&#x3D;&#x3D;$$GainRatio(A)&#x3D;\\frac{Gain(A)}{SplitInfo(A)}$$$$Gain_{-}ratio(D,a)&#x3D;\\frac{Gain(D,a)}{IV(a)}$$&#x3D;&#x3D;属性a的固有值(分裂信息)：&#x3D;&#x3D;$$SplitInfo_A(D)&#x3D;-\\sum_{v&#x3D;1}^{V}\\frac{|D^v|}{|D|}log_2^{\\frac{|D^v|}{|D|}}$$$$IV(a)&#x3D;-\\sum_{v&#x3D;1}^{V}\\frac{|D^v|}{|D|}log_2^{\\frac{|D^v|}{|D|}}$$通常a的可取值数目越多，则IV(a)越大&#x3D;&#x3D;特点：&#x3D;&#x3D;增益率准则可能对取值数目较少的属性有所偏好C4.5算法并不是直接选择增益率最大的候选划分属性，而是使用了一个启发式：先从候选划分属性中找出信息增益高于平均水平的属性，再从中选择增益率最高的&#x3D;&#x3D;使用此方法的算法：&#x3D;&#x3D;C4.5 3.基尼指数&#x3D;&#x3D;基尼值：&#x3D;&#x3D;基尼值反映了从数据集D中随机抽取两个样本，其类别标记不一致的概率基尼值越小，则D的纯度越高$$Gini(D)&#x3D;\\sum_{k&#x3D;1}^{|y|}\\sum_{k’!&#x3D;k}p_kp_{k’}\\&#x3D;1-\\sum_{k&#x3D;1}^{|y|}p_{k^2}$$&#x3D;&#x3D;基尼指数：&#x3D;&#x3D;$$Gini_A(D)&#x3D;\\sum_{v&#x3D;1}^{V}\\frac{|D^v|}{|D|}Gini(D^v)$$$$Gini_{-}index(D,a)&#x3D;\\sum_{v&#x3D;1}^{V}\\frac{|D^v|}{|D|}Gini(D^v)$$选取基尼指数最小的属性 树剪枝剪枝（purning）是决策树学习算法对付“过拟合”的主要手段 泛化性能（generalization performance）是指模型在未见过的数据上的性能表现。简而言之，它衡量了一个机器学习模型对新样本的适应能力和推广能力。 预剪枝步骤： 基于信息增益（或其他）准则，选取属性A来对训练集进行划分，并产生分支。 对划分前后的泛化性能进行估计。 划分前，将该节点标记为叶结点，其类别标记为训练样例最多的类别。 划分后，划分后叶子结点标记为训练样例最多的类别。 则验证集精度&#x3D;分类正确样本&#x2F;验证集样本总数，分别计算划分前后验证集精度，若下降，则不展开，不划分。 性能:降低了过拟合的风险，显著减少了决策树的训练时间开销和测试时间开销；但预剪枝基于“贪心”本质禁止某些分支展开，带来了欠拟合的风险。 后剪枝步骤： 先从训练集生成一颗完整决策树。 根据叶子节点的深度顺序（深度越大优先级越高）进行剪枝前后验证机精度比对。 若同一深度存在多叶子结点则从做到右 顺序：6-&gt;5-&gt;2-&gt;3-&gt;4 性能：后剪枝决策树通常比预剪枝决策树保留了更多的分支，一般情形下，后剪枝决策树的欠拟合风险很小，泛化性能往往优于预剪枝决策树。但后剪枝的训练时间开销时间比未剪枝决策树和预剪枝决策树都要大得多。 连续与缺失值连续值处理对取值连续的属性进行划分最简单的策略：二分法（C4.5决策树算法中采用的极值）步骤： 给定样本集D和连续属性a，假定a在D上出现了n个不同的取值，进行从小到大的排序，记为{$a^1,a^2,\\dots,a^n$} 基于划分点t可将D分为在属性a上取值不大于t的样本集合$D_t^-$,以及大于t的$D_t^+$ 对连续属性a，考察包含n-1个元素的候选划分点集合$$T_a&#x3D;{\\frac{a^i+a^{i+1}}{2}|1 \\leqslant i \\geqslant n-1 }$$ Gain(D,a,t)是样本集D基于划分点t二分后的信息增益，选择Gain(D,a,t)最大的作为划分点 注意点：与离散属性不同，若当前结点划分属性为连续属性，该属性还可作为其后代结点的划分属性 缺失值处理","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"数据挖掘","slug":"课程笔记/数据挖掘","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"}],"tags":[]},{"title":"","slug":"culitivate/other/数学建模笔记/数学建模笔记","date":"2023-04-20T02:37:27.467Z","updated":"2023-09-20T08:42:18.846Z","comments":true,"path":"2023/04/c4bd880caf59.html","link":"","permalink":"http://example.com/2023/04/c4bd880caf59.html","excerpt":"","text":"[toc]比赛：https://shuang96.blog.csdn.net/article/details/129204116?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EYuanLiJiHua%7EPosition-2-129204116-blog-105923643.235%5Ev32%5Epc_relevant_increate_t0_download_v2&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EYuanLiJiHua%7EPosition-2-129204116-blog-105923643.235%5Ev32%5Epc_relevant_increate_t0_download_v2&amp;utm_relevant_index=5 matlab语法dslove函数用于求解微分方程 符号变量的创建优点：在运算过程中不存在误差，符号不受运算位数的限制x&#x3D;sym(‘符号’)syms x y; subssubs(s,old,new)replace old with new forfor i&#x3D;1:30 fprintf(‘i:%d’,i);end 矩阵矩阵创建zeros(1,4) %1行4列的全0矩阵（第一个参数表示行数） zeros(3,4) %3行4列的全0矩阵（第二个参数表示列数） zeros(4) %4阶（4*4）全0矩阵（只有一个参数则行数列数相同） ones(1,4) %1行4列的全1矩阵. eye(3) %3阶单位矩阵 eye(2,3) %2行3列的单位矩阵 magic(3) %3阶魔方矩阵 magic(30) %30阶魔方矩阵 数学模型优化数学规划模型线性规划定义定义首先把问题化为Matlab标准型$$min_{x}-f^{T}x, $$s.t. A·x&lt;&#x3D;b Aeq·x&#x3D;beq lb&lt;&#x3D;x&lt;&#x3D;ubf,x,b,beq,lb,ub均为列向量A，Aeq为矩阵然后准备变量最后调用命令函数[x,fval]&#x3D;linprog(f,A,b)[x,fval]&#x3D;linprog(f,A,b,Aeq,beq)[x,fval]&#x3D;linprog(f,A,b,Aeq,beq,lb,ub)[x,fval]&#x3D;linprog(f,A,b,[],[],lb,ub)&#x2F;&#x2F;Aeq,beq不存在 相关问题绝对值的转换求min $$|x_{1}|+|x_{2}|+…+|x_{n}|$$转换：对任意实数$$x_{i},存在u_{i},v_{i}&gt;&#x3D;0$$满足$$x_{i}&#x3D;u_{i}-v_{i},|x_{i}|&#x3D;u_{i}+v_{i}$$即$$u_{i}&#x3D;\\frac{|x_{i}|+x_{i}}{2},v_{i}&#x3D;\\frac{|x_{i}|-x_{i}}{2}$$进而代入转换 多目标的线性规划可以选择固定多个目标条件使多目标变换为一个目标的线性规划《数学建模算法与应用》p8 12345678910111213141516clc,cleara=0;hold on while a &lt;0.5 c=[-0.05,-0.27,-0.19,-0.185,-0.185]; A=[zeros(4,1),diag([0.025,0.015,0.055,0.026])]; b=a*ones(4,1); Aeq=[1,1.01,1.02,1.045,1.065]; beq=1; LB=zeros(5,1); [x,Q]=linprog(c,A,b,Aeq,beq,LB); Q=-Q; plot(a,Q,&#x27;r*&#x27;); a=a+0.001;endxlabel(&#x27;a&#x27;),ylabel(&#x27;Q&#x27;) 整数规划定义数学规划中的变量（全部或部分）限制为整数现在基本只有求解整数线性规划的方法用Lingo更好 0-1型整数规划相互排斥的约束条件&#x3D;&#x3D;引入&#x3D;&#x3D;&#x3D;&#x3D;普通约束条件&#x3D;&#x3D; 指派问题&#x3D;&#x3D;数学模型&#x3D;&#x3D;&#x3D;&#x3D;Matlab代码&#x3D;&#x3D; 12345678910111213141516171819clc,clear c=[3 8 2 10 3; 8 7 2 9 7; 6 4 2 7 5; 8 4 2 3 5; 9 10 6 9 10];n=5;c=c(:);a=zeros(2*n,n^2);intcon=1:n^2;for i=1:na(i,(i-1)*n+1:n*i)=1;v a(n+i,i:n:n^2)=1;endb=ones(2*n,1);lb=zeros(n^2,1);ub=ones(n^2,1);x=intlinprog(c,intcon,[],[],a,b,lb,ub);x=reshape(x,[n,n]) 非线性规划定义如果目标函数或约束条件中包含非线性函数,就称这种规划问题为非线性规划问题。一般说来,解非线性规划要比解线性规划问题困难得多。而且,也不像线性规划有单纯形法这一通用方法,非线性规划目前还没有适于各种问题的一般算法,各个方法都有自己特定的适用范围。 注意线性规划如果存在最优解则只能在其可行域的边界上非线性规划则可能在其可行域的任意一点达到 非线性规划的一般解法（fmincon）模型： matlab函数命令： 1[x,fval]=fmincon(fun,x0,A,b,Aeq,beq,lb,ub,nonlcon,options) 参数解释：x：返回决策向量x的取值fval：返回目标函数的取值fun：用M文件定义的函数f(x)x0：x的初始值A,b,Aeq,beq：线性约束条件lb,ub：上下界nonlcon：用M文件定义的非线性向量函数c(x),ceq(x)非线性约束条件options：优化参数 例子： 无约束问题无约束极值问题的符号解（依靠特征值的正负判断）模型&#x2F;步骤： Matlab程序： 123456789101112131415161718192021clc,clearsyms x y;f=x^3-y^3+3*x^2+3*y^2-9*x;df=jacobian(f); %求一阶偏导数d2f=jacobian(df);%求Hessian阵[xx,yy]=slove(df);%求驻点xx=double(xx);yy=double(yy);%转换成双精度浮点型数据for i=1:length(xx): a=subs(d2f,&#123;x,y&#125;,&#123;xx(i),yy(i)&#125;); %替换 b=eig(a); %求矩阵的特征值 f=subs(f,&#123;x,y&#125;,&#123;xx(i),yy(i)&#125;);f=double(f); if all(b&gt;0) fprintf(&#x27;(%f,%f)是极小值点，对应的极小值为%f\\n&#x27;,xx(i),yy(i),f); elseif all(b&lt;0) fprintf(&#x27;(%f,%f)是极大值点，对应的极大值为%f\\n&#x27;,xx(i),yy(i),f); elseif any(b&gt;0)&amp;any(b&lt;0) fprintf(&#x27;(%f,%f)是不是极值点\\n&#x27;,xx(i),yy(i)); else fprintf(&#x27;无法判断(%f,%f)是否是极值点\\n&#x27;,xx(i),yy(i)); endend 无约束极值问题的数值解（fminunc和fminsearch）fminunc函数：注意点可以在fun函数中增加梯度、一阶导、二阶导来增加准确率与速度梯度（一阶导）参数打开：’GradObj’,’on’二阶导Hessian阵参数打开：‘Hessian’,’on’ 123456789fun3函数function[f,g,d2f]=fun3(x);f=100*(x(2)-x(1)^2)^2+(1-x(1))^2;g=[-400*x(1)(x(2)-x(1)^2)-2*(1-x(1));200*(x(2)-x(1)^2)]; %g返回梯度向量d2f=[-400*x(2)+12000*x(1)^2+2,-400*x(1) -400*x(1),200];%Hessian阵主函数options=optimset(&#x27;GradObj&#x27;,&#x27;on&#x27;,&#x27;Hessian&#x27;,&#x27;on&#x27;);[x,y]=fminunc(&#x27;fun3&#x27;,rand(1,2),options); fminsearch函数:使用直接搜索，适合求初始值附近的极小值点[x,y]&#x3D;fminsearch(@fun3,x0)&#x2F;fminsearch(‘fun3’,x0) 求函数的零点和方程组的解（slove,roots）求零点： 123clc,clearxishu=[1 -1 2 -3];x0=roots(xishu); 1234clc,clearsyms xx0=solve(x^3-x^2+2*x-3);x0=vpa(x0,5); 123clc,cleary=@(x)x^3-x^2+2*x-3;x=fslove(y,rand); 123clc,clearsyms x y[x,y]=slove(x^2+y-2,y^2+x-6); 约束极值问题二次规划定义：若某非线性规划的目标函数为自变量x的二次函数，约束条件又全是线性的，就称为二次规划 数学模型： 例子： 罚函数法定义：将非线性规划问题转化为一系列无约束极值问题 模型： 例子： 求约束极值问题的相关函数fminbnd:模型： fseminf:模型： 例子： 1234567891011121314151617function f=fun7(x,s);f=sum((x-0.5).^2);endfunction [c,ceq,k1,k2,s]=fun8(x,s);c=[];ceq=[];if isnan(s(1,1)) %是否是数字 s=[0.2,0;0.2,0];endw1=1:s(1,1):100;w2=1:s(2,1):100;k1=sin(w1*x(1)).*cos(w1*x(2))-1/1000*(w1-50).^2-sin(w1*x(3))-x(3)-1;k2=sin(w2*x(2)).*cos(w2*x(2))-1/1000*(w2-50).^2-sin(w2*x(3))-x(3)-1;plot(w1,k1,&#x27;-&#x27;,w2,k2,&#x27;+&#x27;);x0=[0.5;0.2;0.3];[x,y]=fseminf(@fun7,x0,2,@fun8); fminimax:模型： 例子： 利用梯度求解约束优化问题：例子： wkhtmltopdf –enable-toc-back-links E:&#x2F;blog&#x2F;first&#x2F;source&#x2F;_posts&#x2F;数学建模笔记&#x2F;数学建模笔记.html E:\\Study\\python\\spiderlearn\\数学建模.pdf 微分方程组模型定义：含有未知数及其导数的方程 人口增长模型：阻滞增长模型（Logistic模型）模型建立与假设： 假设t时刻人口数量为连续、可微函数x(t) 假设初始人数为x0 假设r(0)&#x3D;r，r(xm)&#x3D;0，其中r为一个常数，即初始人口增长率 假设当前环境和资源最大可能承受的人口数为xm 假设单位时间人口增长率为x的减函数，即r(x)&#x3D;a-bx，其中b&gt;0 数学模型：$$\\frac{dx}{dt}&#x3D;r(x)x&#x3D;r(1-\\frac{x}{x_{m}})x$$ 求模型求解x(t)得：$$x&#x3D;\\frac{x_{m}}{1+(\\frac{x_{m}}{x_{0}}-1)*\\exp(-rt)}$$ 求解过程： matlab程序： 123456789101112131415161718clear;clc;% 定义迭代次数n=500;% 定义并初始化参数x=zeros(1,n);x(1,1)=5.42;%初始入口r=0.018; %初始人口增长率xm=100;%最大人口数% 开始迭代for t=2:n x(1,t)=xm/(1+(xm/x(1,1)-1)*exp(-r*t));end%绘图plot(1:1:n,x,&#x27;.-r&#x27;);legend(&#x27;人口增长曲线&#x27;);xlabel(&#x27;迭代次数&#x27;);ylabel(&#x27;人口数&#x27;);grid on; 传染病模型：SI模型：模型建立与假设：SI模型将人群分为两类，一类是健康人群（S），另一类是感染者（I） 假设总人数为N，且N不变 假设时刻t健康人和感染者所占比例分别为s(t)和i(t)，且s(t)+i(t)&#x3D;1 假设每个病人每天有效接触人数为常数L（日接触率），感染者接触健康者，就会让健康者患病 数学模型：$\\begin{cases} \\frac{di}{dt}&#x3D;L*i(1-i) \\ i(0)&#x3D;i_{0}\\end{cases}$$f(x)&#x3D;\\begin{cases}x, &amp; \\text{if }x\\geq 0\\ax, &amp; \\text{if }x \\leq 0\\end{cases}$ 推导过程：依据每日感染者增长人数建立方程$N[i(t+\\Delta{t})-i(t)]&#x3D;L*s(t)Ni(t)\\Delta{t}$$\\implies \\frac{di}{dt}&#x3D;Li(1-i)$解logistic模型得：$i(t)&#x3D;\\frac{1}{1+(\\frac{1}{i_{0}}-1)*e^{-Lt}}$ maltba程序： 1234567891011121314151617181920212223clc;clear;% 迭代次数n=100;% 初始状态E=zeros(2,n);% 初始感染率与健康率i=0.01;s=0.09;L=0.5;for t=1:n E(2,t)=1/(1+(1/i-1)*exp(-L*t)); E(1,t)=1-E(2,t);end%绘图ii=E(2,:);ss=E(1,:);plot(ii,&#x27;.-r&#x27;);hold on;plot(ss,&#x27;.-g&#x27;);legend(&#x27;患者&#x27;,&#x27;健康者&#x27;);xlabel(&#x27;迭代次数&#x27;);ylabel(&#x27;比例&#x27;);grid on; SIS模型：模型建立与假设：SIS模型在SI模型的基础上，还考虑了健康人被感染后可能会被治愈，而且治愈后，还可能再次被感染的情况 假设总人数为N，且N不变 假设时刻t健康人和感染者所占比例分别为s(t)和i(t)，且s(t)+i(t)&#x3D;1 假设每个病人每天有效接触人数为L（日接触率），感染者接触健康者，就会让健康者患病 假设病人每天的治愈率为M（日治愈率）数学模型：$\\begin{cases}\\frac{di}{dt}&#x3D;Li(1-i)-Mi \\i(0)&#x3D;i_{0}\\end{cases}$模型推导：依据每日感染者增长人数建立方程$N[i(t+\\Delta{t})-i(t)]&#x3D;Ls(t)Ni(t)\\Delta{t}-MNi(t)\\Delta{t}$$\\implies \\frac{di}{dt}&#x3D;Li(1-i)-Mi$$用\\sigma&#x3D;\\frac{L}{M}代入上式得：\\\\frac{di}{dt}&#x3D;Li[(1-\\frac{1}{\\sigma})-1]$其中L表示日接触人数(日接触率)，$\\frac{1}{\\sigma}$表示感染期[M表示一个人一天内被治好的概率，1&#x2F;M表示平均得多久的病才会被治好]，$\\sigma$表示一个感染期内每个病人的有效接触人数，称为接触数。 matlab程序： 123clc;clear;syms i(t) L M;dsolve(L*i*(1-i)-M*i-diff(i)==0) SIR模型：模型建立与假设：SIR模型中，有三种人群：健康者（S），感染者（I），免疫者（R） 假设总人数为N，且N不变 假设时刻t健康人、感染者和免疫者所占比例分别为s(t)、i(t)和r(t)，且s(t)+i(t)+r(t)&#x3D;1 假设每个病人每天有效接触人数为L（日接触率），感染者接触健康者，就会让健康者患病 假设病人每天的治愈率为M（日治愈率） 假设病人被治愈后，会产生抗体，成为免疫者，免疫者群体不会被再次感染 数学模型：$$\\frac{di}{dt}&#x3D;Lsi-Mi$$ 模型推导： matlab程序： 概率模型csdn链接：https://blog.csdn.net/ywsydwsbn/article/details/123523083 图论最短路径12345678W = [.41 .99 .51 .32 .15 .45 .38 .32 .36 .29 .21];DG = sparse([6 1 2 2 3 4 4 5 5 6 1],[2 6 3 5 4 1 6 3 4 3 5],W)h = view(biograph(DG,[],&#x27;ShowWeights&#x27;,&#x27;on&#x27;))[dist,path,pred] = graphshortestpath(DG,1,6)set(h.Nodes(path),&#x27;Color&#x27;,[1 00.9 0.4])edges = getedgesbynodeid(h,get(h.Nodes(path),&#x27;ID&#x27;));set(edges,&#x27;LineColor&#x27;,[1 00.9 0])set(edges,&#x27;LineWidth&#x27;,1.5) 最小生成树1234567891011121314clc,clearx=[0 5 16 20 33 23 35 25 10];y=[15 20 24 20 25 11 7 0 3];xy=[x;y];d=mandist(xy);% 下三角矩阵d=tril(d);% 稀疏矩阵b=sparse(d);[ST,pred]=graphminspantree(b,&#x27;Method&#x27;,&#x27;Kruskal&#x27;);st=full(ST);TreeLength=sum(sum(st))view(biograph(ST,[],&#x27;ShowArrows&#x27;,&#x27;off&#x27;))","categories":[{"name":"culitivate","slug":"culitivate","permalink":"http://example.com/categories/culitivate/"},{"name":"other","slug":"culitivate/other","permalink":"http://example.com/categories/culitivate/other/"},{"name":"数学建模笔记","slug":"culitivate/other/数学建模笔记","permalink":"http://example.com/categories/culitivate/other/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"爬虫","slug":"culitivate/Python/爬虫/爬虫","date":"2023-04-11T10:41:14.000Z","updated":"2023-09-20T08:42:18.829Z","comments":true,"path":"2023/04/2d0e0a8951d8.html","link":"","permalink":"http://example.com/2023/04/2d0e0a8951d8.html","excerpt":"","text":"请求库:1、urllib: urllib库是Python3自带的库(Python2有urlib和urlib2，到了Python3统一为urlib)，这个库是爬虫里最简单的库。2、requests: requests属于第三方库，使用起来比urlib要简单不少，且功能更加强大，是最常用的请求库。3、Selenium: Selenium属于第三方库，它是一个自动化测试工具，可以利用它自动完成浏览器的操作，如点击，下拉，拖拽等等，通常完成ajax复杂的操作。解析库:1、lxml:属于第三方库，支持HTML和xml的解析，支持XPath的解析方式，解析效率非常高。2、Beautiful Soup:属于第三方库，API强大，使用也方便。3、pyquery:属于第三方库，功能强大在于css选择器上，对jQuery比较了解的话使用pyquery将会十分方便，因此我也比较推荐使用pyquery。存储库:1、PyMySQL: MySQL作为最常用的数据库之一，PyMySQL也是爬虫后存储数据的非常好的选择，它可以实现对数据库的创建表，增删查改等操作。2、PyMongo: PyMongo是和MongoDB进行交互的库。3、redis-py: redis-py是和Redis进行交互的库。 基本库的使用urlliib它包含如下 4 个模块。 request：它是最基本的 HTTP 请求模块，可以用来模拟发送请求。就像在浏览器里输入网址然后回车一样，只需要给库方法传入 URL 以及额外的参数，就可以模拟实现这个过程了。 error：异常处理模块，如果出现请求错误，我们可以捕获这些异常，然后进行重试或其他操作以保证程序不会意外终止。 parse：一个工具模块，提供了许多 URL 处理方法，比如拆分、解析、合并等。 robotparser：主要是用来识别网站的 robots.txt 文件，然后判断哪些网站可以爬，哪些网站不可以爬，它其实用得比较少。 发送请求request模块包含方法 1.urlopen&#x3D;&#x3D;基本使用&#x3D;&#x3D; 1234import urllib.requestresponse = urllib.request.urlopen(&#x27;https://cuiqingcai.com/202221.html&#x27;)print(response.read().decode(&#x27;utf-8&#x27;)) type(response)&#x3D;&lt;class ‘http.client.HTTPResponse’&gt; 状态码：response.status 响应头：response.getheaders() &#x3D;&#x3D;传参&#x3D;&#x3D; 1urllib.request.urlopen(url, data=None, [timeout,]*, cafile=None, capath=None, cadefault=False, context=None) data参数data 参数是可选的。如果要添加该参数，需要使用 bytes 方法将参数转化为字节流编码格式的内容，即 bytes 类型。另外，如果传递了这个参数，则它的请求方式就不再是 GET 方式，而是 POST 方式。 123456import urllib.parseimport urllib.requestdata = bytes(urllib.parse.urlencode(&#123;&#x27;name&#x27;: &#x27;germey&#x27;&#125;), encoding=&#x27;utf-8&#x27;)response = urllib.request.urlopen(&#x27;https://httpbin.org/post&#x27;, data=data)print(response.read().decode(&#x27;utf-8&#x27;)) urlib.parse.urlencode将参数字典转换为字符串 time参数捕获异常 123456789import socketimport urllib.requestimport urllib.errortry: response = urllib.request.urlopen(&#x27;https://httpbin.org/get&#x27;, timeout=0.1)except urllib.error.URLError as e: if isinstance(e.reason, socket.timeout): print(&#x27;TIME OUT&#x27;) context参数必须是ssl.SSLContext 类型，用来指定 SSL 设置。 cafile、capath两个参数指定 CA 证书和它的路径在请求 HTTPS 链接时会有用。 cadefault参数现在已经弃用了，其默认值为 False。 2.Requestrequests","categories":[{"name":"culitivate","slug":"culitivate","permalink":"http://example.com/categories/culitivate/"},{"name":"Python","slug":"culitivate/Python","permalink":"http://example.com/categories/culitivate/Python/"},{"name":"爬虫","slug":"culitivate/Python/爬虫","permalink":"http://example.com/categories/culitivate/Python/%E7%88%AC%E8%99%AB/"}],"tags":[]},{"title":"机器学习","slug":"culitivate/other/机器学习/机器学习","date":"2023-04-11T10:40:56.000Z","updated":"2023-09-20T08:42:18.846Z","comments":true,"path":"2023/04/bcf9f2881cb5.html","link":"","permalink":"http://example.com/2023/04/bcf9f2881cb5.html","excerpt":"","text":"[toc] 机器学习决策树决策树的构造基本流程决策树的一般流程(1)收集数据:可以使用任何方法。(2)准备数据:树构造算法只适用于标称型数据，因此数值型数据必须离散化。(3)分析数据:可以使用任何方法，构造树完成之后，我们应该检查图形是否符合预期。(4)训练算法:构造树的数据结构。(5)测试算法:使用经验树计算错误率。(6)使用算法:此步骤可以适用于任何监督学习算法，而使用决策树可以更好地理解数据的内在含义。 最优划分属性的选择1.信息增益&#x3D;&#x3D;“信息嫡”(information entropy)：&#x3D;&#x3D;是度量样本集合纯度最常用的一种指标.假定当前样本集合D中第k类样本所占的比例为$p_{k}$(k &#x3D; 1,2,…, $|y|$)则D的信息嫡定义为（对D中的元组分类所需要的期望信息）$$Info(D)&#x3D;Ent(D)&#x3D;-\\sum_{k&#x3D;1}^{|y|}p_{k}log_{2}^{p_{k}}$$熵（期望信息）越小，分区的纯度越高&#x3D;&#x3D;信息增益：&#x3D;&#x3D;假定离散属性a有V个可能的取值{$a^{1},a^{2},…,a^{v}$}则用属性a对样本集D进行划分的“信息增益”为：$$Gain(A)&#x3D;Info(D)-Info_{A}(D)(学校)$$$$Inof_A(D)&#x3D;\\sum_{j&#x3D;1}^{v}\\frac{|D_j|}{D}Info(D_j)$$$$Gain(D,a)&#x3D;Ent(D)-\\sum_{v&#x3D;1}^{V}\\frac{|D^v|}{|D|}Ent(D^{v})$$最优划分属性即最大信息增益&#x3D;&#x3D;特点：&#x3D;&#x3D;结果偏向具有大量属性值的属性&#x3D;&#x3D;使用此方法的算法：&#x3D;&#x3D;ID3 2.增益率为减少信息增益准则对可能取值数目较多的属性有所偏好用“分裂信息”(学校)&#x2F;固有值将信息增益规范化&#x3D;&#x3D;增益率：&#x3D;&#x3D;$$GainRatio(A)&#x3D;\\frac{Gain(A)}{SplitInfo(A)}$$$$Gain_{-}ratio(D,a)&#x3D;\\frac{Gain(D,a)}{IV(a)}$$&#x3D;&#x3D;属性a的固有值(分裂信息)：&#x3D;&#x3D;$$SplitInfo_A(D)&#x3D;-\\sum_{v&#x3D;1}^{V}\\frac{|D^v|}{|D|}log_2^{\\frac{|D^v|}{|D|}}$$$$IV(a)&#x3D;-\\sum_{v&#x3D;1}^{V}\\frac{|D^v|}{|D|}log_2^{\\frac{|D^v|}{|D|}}$$通常a的可取值数目越多，则IV(a)越大&#x3D;&#x3D;特点：&#x3D;&#x3D;增益率准则可能对取值数目较少的属性有所偏好C4.5算法并不是直接选择增益率最大的候选划分属性，而是使用了一个启发式：先从候选划分属性中找出信息增益高于平均水平的属性，再从中选择增益率最高的&#x3D;&#x3D;使用此方法的算法：&#x3D;&#x3D;C4.5 3.基尼指数&#x3D;&#x3D;基尼值：&#x3D;&#x3D;基尼值反映了从数据集D中随机抽取两个样本，其类别标记不一致的概率基尼值越小，则D的纯度越高$$Gini(D)&#x3D;\\sum_{k&#x3D;1}^{|y|}\\sum_{k’!&#x3D;k}p_kp_{k’}\\&#x3D;1-\\sum_{k&#x3D;1}^{|y|}p_{k^2}$$&#x3D;&#x3D;基尼指数：&#x3D;&#x3D;$$Gini_A(D)&#x3D;\\sum_{v&#x3D;1}^{V}\\frac{|D^v|}{|D|}Gini(D^v)$$$$Gini_{-}index(D,a)&#x3D;\\sum_{v&#x3D;1}^{V}\\frac{|D^v|}{|D|}Gini(D^v)$$选取基尼指数最小的属性 树剪枝剪枝（purning）是决策树学习算法对付“过拟合”的主要手段 泛化性能（generalization performance）是指模型在未见过的数据上的性能表现。简而言之，它衡量了一个机器学习模型对新样本的适应能力和推广能力。 预剪枝步骤： 基于信息增益（或其他）准则，选取属性A来对训练集进行划分，并产生分支。 对划分前后的泛化性能进行估计。 划分前，将该节点标记为叶结点，其类别标记为训练样例最多的类别。 划分后，划分后叶子结点标记为训练样例最多的类别。 则验证集精度&#x3D;分类正确样本&#x2F;验证集样本总数，分别计算划分前后验证集精度，若下降，则不展开，不划分。 性能:降低了过拟合的风险，显著减少了决策树的训练时间开销和测试时间开销；但预剪枝基于“贪心”本质禁止某些分支展开，带来了欠拟合的风险。 后剪枝步骤： 先从训练集生成一颗完整决策树。 根据叶子节点的深度顺序（深度越大优先级越高）进行剪枝前后验证机精度比对。 若同一深度存在多叶子结点则从做到右 顺序：6-&gt;5-&gt;2-&gt;3-&gt;4 性能：后剪枝决策树通常比预剪枝决策树保留了更多的分支，一般情形下，后剪枝决策树的欠拟合风险很小，泛化性能往往优于预剪枝决策树。但后剪枝的训练时间开销时间比未剪枝决策树和预剪枝决策树都要大得多。 连续与缺失值连续值处理对取值连续的属性进行划分最简单的策略：二分法（C4.5决策树算法中采用的极值）步骤： 给定样本集D和连续属性a，假定a在D上出现了n个不同的取值，进行从小到大的排序，记为{$a^1,a^2,\\dots,a^n$} 基于划分点t可将D分为在属性a上取值不大于t的样本集合$D_t^-$,以及大于t的$D_t^+$ 对连续属性a，考察包含n-1个元素的候选划分点集合$$T_a&#x3D;{\\frac{a^i+a^{i+1}}{2}|1 \\leqslant i \\geqslant n-1 }$$ Gain(D,a,t)是样本集D基于划分点t二分后的信息增益，选择Gain(D,a,t)最大的作为划分点 注意点：与离散属性不同，若当前结点划分属性为连续属性，该属性还可作为其后代结点的划分属性 缺失值处理","categories":[{"name":"culitivate","slug":"culitivate","permalink":"http://example.com/categories/culitivate/"},{"name":"other","slug":"culitivate/other","permalink":"http://example.com/categories/culitivate/other/"},{"name":"机器学习","slug":"culitivate/other/机器学习","permalink":"http://example.com/categories/culitivate/other/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"","slug":"工具记录/建站/建站","date":"2023-03-28T14:40:54.402Z","updated":"2023-09-20T08:42:18.828Z","comments":true,"path":"2023/03/ee6f7bde34c6.html","link":"","permalink":"http://example.com/2023/03/ee6f7bde34c6.html","excerpt":"","text":"npm install hexo-auto-category –save mavenmaven下载网站Index of &#x2F;dist&#x2F;maven&#x2F;maven-3&#x2F;3.6.3&#x2F;binaries (apache.org)依赖下载网站Maven Repository: Search&#x2F;Browse&#x2F;Explore (mvnrepository.com)Project ‘org.springframework.boot:spring-boot-starter-parent:3.0.4.RELEASE’ not found解决方案： java: 无法访问org.springframework.web.bind.annotation.RequestMapping……类文件具有错误的版本 61.0, 应为 52.0(106条消息) java: 无法访问org.springframework.web.bind.annotation.RequestMapping……类文件具有错误的版本 61.0, 应为 52.0_java无法访问_Shipley_Leo的博客-CSDN博客 数据库连接结构","categories":[{"name":"工具记录","slug":"工具记录","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7%E8%AE%B0%E5%BD%95/"},{"name":"建站","slug":"工具记录/建站","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7%E8%AE%B0%E5%BD%95/%E5%BB%BA%E7%AB%99/"}],"tags":[]},{"title":"算法专题","slug":"culitivate/408/算法/算法专题","date":"2023-03-13T10:31:22.000Z","updated":"2023-09-20T08:42:18.829Z","comments":true,"path":"2023/03/075a7020b2b5.html","link":"","permalink":"http://example.com/2023/03/075a7020b2b5.html","excerpt":"","text":"进度[[数学建模笔记]] 暴力枚举[2]贪心[3]动态[3]*排序[2]搜索[2]*图论[2]数论[3]字符串算法[2]数据结构[2]openai_api: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 动态规划核心：状态与状态转移方程 背包九讲述一、01背包问题题目有 N 件物品和一个容量为 V 的背包。放入第 i 件物品耗费的费用是 Ci1，得到的价值是 Wi。求解将哪些物品装入背包可使价值总和最大。状态与状态转移方程分析状态： F[i, v] 表示前 i 件物品恰放入一个容量为 v 的背包可以获得的最大价值。状态转移方程：F[i, v] &#x3D; max{F[i − 1, v], F[i − 1, v − Ci] + Wi}F[i − 1, v]：当前物品不选，前i-1件物品，放入容量为v的背包的最大价值F[i − 1, v − Ci] + Wi：往前物品选取，前i件物品放入容量为v-Ci的背包的最大价值 代码 1234F[0, 0..V ] ← 0for i ← 1 to N for v ← Ci to V（V to Ci） F[i, v] ← max&#123;F[i − 1, v], F[i − 1, v − Ci] + Wi&#125; 优化空间复杂度F[0..V ] ←0for i ← 1 to Nfor v ← V to CiF[v] ← max{F[v], F[v − Ci] + Wi} 优化后代码 123456def ZeroOnePack(F, C, W)： for v ← V to C F[v] ← max(F[v], F[v − C] + W)F[0..V ] ←0for i ← 1 to N ZeroOnePack(F, Ci, Wi) 1234F[0..V ] ←0for i ← 1 to N for v ← V to Ci F[v] ← max(F[v], F[v − Ci] + Wi) 二、完全背包问题题目有 N 种物品和一个容量为 V 的背包，每种物品都有&#x3D;&#x3D;无限件&#x3D;&#x3D;可用。放入第 i 种物品的费用是 Ci，价值是 Wi。求解：将哪些物品装入背包，可使这些物品的耗费的费用总和不超过背包容量，且价值总和最大。状态与状态转移方程状态：F[i, v] 表示前 i 种物品恰放入一个容量为 v的背包的最大权值。状态转移方程：F[i, v] &#x3D; max{F[i − 1, v − kCi] + kWi| 0 ≤ kCi ≤ v}代码 1234F[0..V ] ←0for i ← 1 to N for v ← Ci to V F[v] ← max(F[v], F[v − Ci] + Wi) 三、多重背包问题题目有 N 种物品和一个容量为 V 的背包。第 i 种物品最多有&#x3D;&#x3D; Mi&#x3D;&#x3D; 件可用，每件耗费的空间是 Ci，价值是 Wi。求解将哪些物品装入背包可使这些物品的耗费的空间总和超过背包容量，且价值总和最大状态转移方程F[i，v] &#x3D; max{F[i − 1, v − k ∗ Ci] + k ∗ Wi| 0 ≤ k ≤ Mi}代码O($log^M$) 12345678910def MultiplePack(F,C,W,M)if C · M ≥ V //相当于无限，完全背包问题 CompletePack(F,C,W)// returnk ← 1while k &lt; M ZeroOnePack(kC,kW) //将M件分为，系数为不大于K($M_i-2^k+1&gt;0$)的1，2，$2^2$...$2^&#123;k-1&#125;$,$M_i-2^k+1$为系数的k+1件物品，进行01背包 M ←M − k k ← 2k //计算下一个k的过程ZeroOnePack(C · M,W · M)//最后一个系数的01背包 可行性问题O(VN) 123456789101112F[0, 1 . . . V ] ← −1F[0, 0] ← 0for i ← 1 to N for j ← 0 to V if F[i − 1][j] ≥ 0 F[i][j] = Mi else F[i][j] = −1 for j ← 0 to V − Ci if F[i][j] &gt; 0 F[i][j + Ci] ← max&#123;F[i][j + Ci], F[i][j] − 1&#125;最终 F[N][0 . . . V ] 便是多重背包可行性问题的答案 四、混合三种背包问题01 背包与完全背包的混合O(VN) 1234567for i ← 1 to N if 第 i 件物品属于 01 背包 for v ← V to Ci F[v] ← max(F[v], F[v − Ci] + Wi) else if 第 i 件物品属于完全背包 for v ← Ci to V F[v] ← max(F[v], F[v − Ci] + Wi) 再加上背包问题 1234567for i ← 1 to N if 第 i 件物品属于 01 背包 ZeroOnePack(F,Ci,Wi) else if 第 i 件物品属于完全背包 CompletePack(F,Ci,Wi) else if 第 i 件物品属于多重背包 MultiplePack(F,Ci,Wi,Ni) 五、二维费用的背包问题题目二维费用的背包问题是指：对于每件物品，具有两种不同的费用，选择这件物品必须同时付出这两种费用。对于每种费用都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。设第 i 件物品所需的两种费用分别为 Ci 和 Di。两种费用可付出的最大值（也即两种背包容量）分别为 V 和 U。物品的价值为 Wi。状态F[i, v, u] &#x3D; max{F[i − 1, v, u], F[i − 1, v − Ci, u − Di] + Wi}如前述优化空间复杂度的方法，可以只使用二维的数组：当每件物品只可以取一次时变量 v 和 u 采用逆序的循环，当物品有如完全背包问题时采用顺序的循环，当物品有如多重背包问题时拆分物品。 六、分组背包问题题目有 N 件物品和一个容量为 V 的背包。第 i 件物品的费用是 Ci，价值是 Wi。这些物品被划分为 K 组，每组中的物品互相冲突，最多选一件。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。状态转移方程F[k, v] &#x3D; max{F[k − 1, v], F[k − 1, v − Ci] + Wi| item i ∈ group k}代码 1234for k ← 1 to K for v ← V to 0 for all item i in group k F[v] ← max&#123;F[v], F[v − Ci] + Wi&#125; 七、有依赖的背包问题问题这种背包问题的物品间存在某种“依赖”的关系。也就是说，物品 i 依赖于物品 j，表示若选物品 i，则必须选物品 j。为了简化起见，我们先设没有某个物品既依赖于别的物品，又被别的物品所依赖；另外，没有某件物品同时依赖多件物品。算法将之转化为分组背包问题：每个选择了主件又选择了若干个附件的策略对应于这个物品组中的一个物品策略优化：对主件k的“附件集合”先进行一次01背包问题代码 1234567891011121314#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std; int T,M,t,m,dp[1001];int main()&#123; cin&gt;&gt;T&gt;&gt;M; for(int i=1;i&lt;=M;i++)&#123; cin&gt;&gt;t&gt;&gt;m; for(int j=T;j&gt;=t;j--)&#123; dp[j]=max(dp[j],dp[j-t]+m); &#125; &#125; cout&lt;&lt;dp[T];&#125; 记忆化搜索DAG上的动态规划求不固定顶点的最长路径d(i)表示从i开始的最长路径状态转移方程：d(i)&#x3D;max{d(j)+1,1}(i,j)属于边集合 123456789int dp(int i) &#123;int&amp; ans = d[i];if(ans &gt; 0) return ans;ans = 1;for(int j = 1; j &lt;= n; j＋＋)if(G[i][j]) ans = max(ans, dp(j)＋1);return ans;&#125; 基础DP最长公共子序列问题(p517跳转程序设计竞赛)状态转移方程dp[i+1][j+1]&#x3D;dp[i][j]+1 ($$s_(i+1)$$&#x3D;&#x3D;$$t_(j+1)$$) &#x3D;max(dp[i][j+1],dp[i+1][j]) (其他) 代码 1234567891011121314151617int n,m;char s[MAX_N],t[MAX_M];int dp[MAX_N+1][MAX_M+1]; //DP数组void slove()&#123; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; if(s[i]==t[j])&#123; dp[i+1][j+1]=dp[i][j]+1; &#125;else&#123; dp[i+1][j+1]=max(dp[i][j+1],dp[i+1][j]); &#125; &#125; &#125; cout&lt;&lt;dp[n][m];&#125; 最长上升子序列状态转移方程d(i)&#x3D;max{0,d(j)|j&lt;i,$$A_(j)&lt;A_i$$}+1 代码 1234567891011int n;cahr s[MAX];int d[MAX+1];void slove()&#123; for(int i=1;i&lt;n;i++)&#123; for(int j=0;j&lt;i;j++) if(s[i]&gt;s[j])&#123; d[i]=max(0,d[j])+1;8 &#125; &#125;&#125; 暴力枚举枚举排列生成1~n的全排列对1~n每个作为开始递归 123456789101112131415161718void print_permutation(int n,int *A,int cur) &#123; if (cur == n) &#123; for (int i = 0; i &lt; n;i++)cout &lt;&lt; A[i]; cout &lt;&lt; endl; &#125; else &#123; for (int i = 1; i &lt;= n; i++) &#123; int ok = 1; for (int j = 0; j &lt; cur; j++) &#123; if (A[j] == i)ok = 0; &#125; if (ok) &#123; A[cur] = i; print_permutation(n, A, cur + 1); &#125; &#125; &#125;&#125; 生成可重集的排列123456789101112131415161718192021void print_permutation(int n,int *P,int *A,int cur) &#123; if (cur == n) &#123; for (int i = 0; i &lt; n;i++)cout &lt;&lt; A[i]; cout &lt;&lt; endl; &#125; else &#123; for (int i = 0; i &lt; n; i++) &#123; if(!i||p[i]!=p[i-1])&#123; int ok = 1; for (int j = 0; j &lt; cur; j++) &#123; if (A[j] == P[i])ok = 0;8 &#125; if (ok) &#123; A[cur] = P[i]; print_permutation(n,P, A, cur + 1); &#125; &#125; &#125; &#125;&#125; 使用STL中的next_permutation12345678910int main() &#123; int n = 3; int p[3] = &#123; 2,1,3 &#125;; sort(p, p + n); do &#123; for (int i = 0; i &lt; n; i++)cout &lt;&lt; p[i]; cout &lt;&lt; endl; &#125;while (next_permutation(p, p + n)); return 0;&#125; 子集生成增量构造法每次开始的位置+1,且每次都输出 1234567001012021122 123456789void print_subset(int n, int* A, int cur) &#123; for (int i = 0; i &lt; cur; i++)cout &lt;&lt; A[i]; cout &lt;&lt; endl; int s = cur ? A[cur - 1] + 1 : 0; for (int i = s; i &lt; n; i++) &#123; A[cur] = i; print_subset(n, A, cur+1); &#125;&#125; 位向量法同全排列一样，到n才输出，选取位置1，否则0 1234567891011void print_subset(int n,int* B,int cur)&#123; if(cur==n)&#123; for(int i=0;i&lt;cur;i++) if(B[i])cout&lt;&lt;i; cout&lt;&lt;endl; &#125; B[cur]=1;//选取 print_subset(n,B,cur+1); B[cur]=0;//不选取 print_subset(n,B,cur+1);&#125; 二进制法三个数的集合001，010，100s从000到111 12345678void print_subset()&#123; for(int i=0;i&lt;n;i++) if(s&amp;(1&lt;&lt;i))cout&lt;&lt;i; cout&lt;&lt;endl;&#125;for(int i=0;i&lt;(1&lt;&lt;n);i++)&#123; // print_subset(n,i)&#125; 回溯法在递归中判断 八皇后问题常规法递归每一行可能放置的列，并且检查是否冲突（回溯），若不冲突，继续递归 123456789101112void search(int cur)&#123; if(cur==n)total++; else for(int i=0;i&lt;n;i++)&#123; int ok=1; C[cur]=i; //把第cur行的皇后放在i列 for(int j=0;j&lt;cur;j++)&#123;//检查和之前皇后的冲突问题 if(C[cur]==C[j]||cur-C[cur]==j-C[j]||cur+C[cur]==j+C[cur]) &#123;ok=0;break;&#125; &#125; if(ok)search(cur+1); &#125;&#125; 优化版（数组）用二维数组来判断列、副对角线、主对角线的冲突情况:vis[0][i]:第i列冲突情况vis[1][x+y]:副对角线冲突情况坐标（x，y）vis[1][y-x+n]:主对角线冲突情况坐标（x，y） 1234567891011`void search(int cur)&#123; if(cur==n)total++; else for(int i=0;i&lt;n;i++)&#123; if(!vis[0][i]&amp;&amp;!vis[1][i+cur]&amp;&amp;!vis[1][cur-i+n])&#123;//判断冲突 C[cur]=i; vis[0][i]=vis[1][i+cur]=vis[1][cur-1+n]=1;//更新冲突情况 search(cur+1); vis[0][i]=vis[1][i+cur]=vis[1][cur-1+n]=0;//当前i不可行，复原冲突情况 &#125; &#125;&#125; 素数环 UVa 524使用回溯，判断是否使用过以及是否和前一个之和为素数 12345678910111213141516171819202122232425262728293031int main()&#123; int A[16]; int isp[32]; int n; cin&gt;&gt;n; for(int i=2;i&lt;=2*n;i++)isp[i]=is_prime(i);//生成素数表 for(int i=2;i&lt;=n;i++)vis[i]=0;//未被选择 dfs(1,n,A,isp,vis); return 0;&#125;void dfs(int cur,int n,int *A,int *isp,int *vis)&#123; if(cur==n&amp;&amp;isp[A[0]+A[n-1]])&#123; //测试边界是否满足 for(int i=0;i&lt;n;i++)cout&lt;&lt;A[i]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; &#125; else for(int i=2;i&lt;=n;i++)&#123; if(!vis[i]&amp;&amp;isp[i+A[cur-1]])&#123;//没有选择过且和前一位之和为素数 A[cur]=i; vis[i]=1; //标记使用过 dfs(cur+1,n,A,isp,vis); vis[i]=0; //清除标记 &#125; &#125;&#125;int is_prime(int i)&#123; if(i&lt;=1)return 0; for(int i=2;i&lt;=sqrt(n);i++)&#123; if(n%i==0)return 0; &#125; return 1;&#125; 困难的串 UVa 1291 带宽 UVa 140天平难题 UVa 1354贪心动态排序搜索图论数论字符串算法数据结构ArrayString双指针Linked ListStackTree","categories":[{"name":"culitivate","slug":"culitivate","permalink":"http://example.com/categories/culitivate/"},{"name":"408","slug":"culitivate/408","permalink":"http://example.com/categories/culitivate/408/"},{"name":"算法","slug":"culitivate/408/算法","permalink":"http://example.com/categories/culitivate/408/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"-算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"C++笔记","slug":"culitivate/C++/C++笔记","date":"2023-03-13T10:26:45.000Z","updated":"2023-09-20T08:42:18.828Z","comments":true,"path":"2023/03/fa95a9f99adb.html","link":"","permalink":"http://example.com/2023/03/fa95a9f99adb.html","excerpt":"","text":"12vector&lt;int&gt; A;A[0]=1; 会报错，因为A还是空，需要A.push_back(1) 1wdwd 123table title,date,tags,tocfrom #算法 sort date desc","categories":[{"name":"culitivate","slug":"culitivate","permalink":"http://example.com/categories/culitivate/"},{"name":"C++","slug":"culitivate/C","permalink":"http://example.com/categories/culitivate/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"all","slug":"culitivate/408/算法/all","date":"2023-03-13T01:17:35.000Z","updated":"2023-09-20T08:42:18.846Z","comments":true,"path":"2023/03/240e812ca6f8.html","link":"","permalink":"http://example.com/2023/03/240e812ca6f8.html","excerpt":"","text":"[toc] 数据结构数组二分法 非递归 1234567891011121314151617181920212223class Solution &#123; public int search(int[] nums, int target) &#123; if (target &lt; nums[0] || target &gt; nums[nums.length - 1]) &#123; return -1; &#125; int left = 0; int right = nums.length - 1; while (left &lt;= right) &#123; int mid = (left + right) / 2; if (nums[mid] == target) &#123; return mid; &#125; else if (target &lt; nums[mid]) &#123; right = mid - 1; &#125; else if (target &gt; nums[mid]) &#123; left = mid + 1; &#125; &#125; return -1; &#125;&#125; 递归 123456789101112131415161718192021222324252627282930package javasuanfa;public class Main &#123; public static void main(String[] args) &#123; int[] nums = &#123;1, 2, 3, 4, 5, 6&#125;; int target = 3; System.out.println(search(nums, target,0,nums.length-1)); &#125; public static int search(int[] nums, int target, int left, int right) &#123; if (target &lt; nums[0] || target &gt; nums[nums.length - 1]) &#123; return -1; &#125; left = 0; right = nums.length - 1; int mid = (left + right) / 2; if (target &lt; nums[mid]) &#123; return search(nums, target, left, mid - 1); &#125; else if (target &gt; nums[mid]) &#123; return search(nums, target, mid + 1, right); &#125; else &#123; return mid; &#125; &#125; &#125; 双指针删除数组元素1234567891011121314class Solution &#123; public int removeElement(int[] nums, int val) &#123; int slowp=0; for(int fastp=0;fastp&lt;nums.length;fastp++)&#123; if(nums[fastp]!=val)&#123; nums[slowp++]=nums[fastp]; &#125; &#125; return slowp; &#125;&#125; 有序数组平方1234567891011121314151617181920class Solution &#123; public int[] sortedSquares(int[] nums) &#123; int[] result =new int[nums.length]; int left=0; int right=nums.length-1; for(int k=nums.length-1;k&gt;=0;k--)&#123; int lsquare=nums[left]*nums[left]; int rqsuare=nums[right]*nums[right]; if(rqsuare&gt;lsquare) &#123; result[k] = rqsuare; right--; &#125; else &#123; result[k]=lsquare; left++; &#125; &#125; return result; &#125;&#125; 滑动窗口(长度最小子数组)123456789101112131415class Solution &#123; public int minSubArrayLen(int target, int[] nums) &#123; int left = 0; int sum = 0; int result = Integer.MAX_VALUE; for (int right = 0; right &lt; nums.length; right++) &#123; sum += nums[right]; while (sum &gt;= target) &#123; result = Math.min(result, right - left + 1); sum -= nums[left++]; &#125; &#125; return result == Integer.MAX_VALUE ? 0 : result; &#125;&#125; 螺旋矩阵1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution &#123; public int[][] generate Matrix(int n) &#123; int[][] result = new int[n][n]; //填充数字 int insert=1; //循环次数 int loop = n / 2; //偏移量 int offset=0; //起始位置 int StartX = 0; int StartY = 0; //坐标 int x = 0; int y = 0; //中间 int mid=n/2; while (loop&gt;0)&#123; x=StartX; y=StartY; //上行 for(;x&lt;n-offset-1;x++)&#123; result[y][x]=insert++; &#125; //右列 for (;y&lt;n-offset-1;y++)&#123; result[y][x]=insert++; &#125; //下列 for(;x&gt;StartX;x--)&#123; result[y][x]=insert++; &#125; //左列 for (;y&gt;StartY;y--)&#123; result[y][x]=insert++; &#125; loop--; offset++; StartX++; StartY++; &#125; if(n%2==1)result[mid][mid]=insert; if(n==1)result[0][0]=1; return result; &#125;&#125; 广义表1. 广义表的定义 广义表(Lists，又称列表)是线性表的推广。即广义表中放松对表元素的原子限制，容许它们具有其自身结构。 广义表是n(n≥0)个元素a1，a2，…，ai，…，an的有限序列。 其中： ①ai–或者是原子或者是一个广义表。 ②广义表通常记作： Ls&#x3D;( a1，a2，…，ai，…，an)。 ③Ls是广义表的名字，n为它的长度。 ④若ai是广义表，则称它为Ls的子表。 注意： ①广义表通常用圆括号括起来，用逗号分隔其中的元素。 ②为了区分原子和广义表，书写时用大写字母表示广义表，用小写字母表示原子。 ③若广义表Ls非空(n≥1)，则al是LS的表头，其余元素组成的表(a1，a2，…，an)称为Ls的表。 ​ ④广义表是递归定义的。 2. 广义表的表示 （1）广义表常用表示 ① E&#x3D;() E是一个空表，其长度为0。 ② L&#x3D;(a，b) L是长度为2的广义表，它的两个元素都是原子，因此它是一个线性表 ③ A&#x3D;(x，L)&#x3D;(x，(a，b)) A是长度为2的广义表，第一个元素是原子x，第二个元素是子表L。 ④ B&#x3D;(A，y)&#x3D;((x，(a，b))，y) B是长度为2的广义表，第一个元素是子表A，第二个元素是原子y。 ⑤ C&#x3D;(A，B)&#x3D;((x，(a，b))，((x，(a，b))，y)) C的长度为2，两个元素都是子表。 ⑥ D&#x3D;(a，D)&#x3D;(a，(a，(a，(…)))) D的长度为2，第一个元素是原子，第二个元素是D自身，展开后它是一个无限的广义表。 （2）广义表的深度 一个表的”深度”是指表展开后所含括号的层数。 【例】表L、A、B、C的深度为分别为1、2、3、4，表D的深度为∞。 （3）带名字的广义表表示 如果规定任何表都是有名字的，为了既表明每个表的名字，又说明它的组成，则可以在每个表的前面冠以该表的名字，于是上例中的各表又可以写成： ①E() ②L(a，b) ③A(x，L(a，b)) ④B(A(x，L(a，b))，y) ⑤C(A(x，l(a，b))，B(A(x，L(a，b))，y)) ⑥D(a，D(a，D(…))) （4）广义表的图形表示 ①图中的分支结点对应广义表 ②非分支结点一般是原子 ③但空表对应的也是非分支结点。 【例】下图给出了几个广义表的图形表示 图 广义表的图形表示 3. 广义表的操作 广义表的基本操作主要有以下5种： （1）GetHead(L)：求广义表的表头操作。如果广义表是空表，返回NULL，否则返回指向表头结点的指针。 （2）GetTail(L)：求广义表的表尾操作。如果广义表是空表，返回NULL，否则返回指向表尾结点的指针。 （3）GListLength(L)：返回广义表的长度操作。如果广义表是空表，则返回0，否则返回广义表的长度。 （4）GListDepth(L)：求广义表的深度操作。深度就是广义表中括号嵌套的层数。空表返回1，否则返回表的深度。 （5）CopyGList(&amp;T,L)：广义表的复制操作。由广义表L复制得到广义表T。复制成功返回1，否则返回0。 广义表中的每个元素可以用一个结点表示，表中有两类结点：原子结点和子表结点。广义表可以分解为表头和表尾，一个表头和一个表尾可以确定一个广义表。因此，一个表结点一般由三个域组成：标志域、指向表头的指针域和指向表尾的指针域。一个原子结点一般由两个域组成：标志域和值域。4. 广义表的运算 在此，只讨论广义表的两个特殊的基本运算：取表头head(Ls)和取表尾tail(Ls)。 根据表头、表尾的定义可知：任何一个非空广义表的表头是表中第一个元素，它可以是原子，也可以是子表，而其表尾必定是子表。 【例】 head(L)&#x3D;a， tail(L)&#x3D;(b) head(B)&#x3D;A， tail(B)&#x3D;(y) 由于tail(L)是非空表，可继续分解得到： head(tail(L))&#x3D;b， tail(tail(L))&#x3D;() 对非空表A和(y)，也可继续分解。 注意:广义表()和(())不同。前者是长度为0的空表，对其不能做求表头和表尾的运算；而后者是长度为l的非空表(只不过该表中惟一的一个元素是空表)，对其可进行分解，得到的表头和表尾均是空表()。 表 iterator迭代器 https://blog.csdn.net/qq_29689343/article/details/113832455 SeqList操作合集完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192#include &quot;SeqList.h&quot;#include &quot;stdlib.h&quot; //realloc#include &quot;String&quot; //string#include &quot;assert.h&quot; //assert#include &quot;iostream&quot; //coutusing namespace std;//初始化操作int SeqList:: InitList(SeqList&amp; L) &#123; L.elem = new int[LIST_INIT_SIZE]; L.length = 0; L.listsize = LIST_INIT_SIZE; return OK; &#125;//增加存储容量int SeqList:: addlistsize(SeqList&amp; L, int n) &#123; int* newbase = (int*)realloc(L.elem, (L.listsize + n * LISTINCREMENT) * sizeof(int)); if (!newbase)exit(OVERFLOW); L.elem = newbase; L.listsize += n * LISTINCREMENT;//增加储存容量 return OK;&#125;//结构销毁操作int SeqList:: DestroyList(SeqList&amp; L) &#123; delete[] L.elem; L.elem = NULL; L.length = 0; L.listsize = 0; return OK;&#125;//引用型操作bool SeqList::ListEmpty(SeqList L) &#123; return L.length == 0;&#125;int SeqList::ListLength(SeqList L) &#123; assert(L.elem != NULL); cout &lt;&lt; &quot;顺序表长度：&quot; &lt;&lt; L.length&lt;&lt;endl; return L.length;&#125;//求前驱int SeqList::PriorElem(SeqList L, int cur_e, int&amp; pre_e) &#123; assert(L.elem != NULL); if (LocateElem(L, cur_e) &lt;= 0) &#123; cout &lt;&lt; &quot;该元素无前驱&quot; &lt;&lt; endl; return ERROR; &#125; pre_e = L.elem[LocateElem(L, cur_e) - 1]; cout &lt;&lt; &quot;元素&quot;&lt;&lt;cur_e&lt;&lt;&quot;的前驱：&quot; &lt;&lt; pre_e &lt;&lt; endl; return OK;&#125;//求后驱int SeqList::NextElem(SeqList L, int cur_e, int&amp; next_e) &#123; assert(L.elem != NULL); if (LocateElem(L, cur_e) &gt;= L.length - 1) &#123; cout &lt;&lt; &quot;该元素无后驱&quot; &lt;&lt; endl; return ERROR; &#125; next_e = L.elem[LocateElem(L, cur_e) + 1]; cout &lt;&lt; &quot;元素&quot; &lt;&lt; cur_e &lt;&lt; &quot;的后驱：&quot; &lt;&lt; next_e &lt;&lt; endl; return OK;&#125;//获取第i个元素的值返回于eint SeqList::GetElem(SeqList L, int i, int&amp; e) &#123; assert(L.elem != NULL); if (i &lt; 0 || i &gt; L.length ) &#123; cout &lt;&lt; &quot;越界&quot; &lt;&lt; endl; return ERROR; &#125; e = L.elem[i - 1]; return OK;&#125;//定位元素int SeqList::LocateElem(SeqList L, int e) &#123; assert(L.elem != NULL); for (int i = 0; i &lt; L.length; ++i) &#123; if (L.elem[i] == e) &#123; cout &lt;&lt; &quot;元素&quot; &lt;&lt; e &lt;&lt; &quot;的位置：&quot; &lt;&lt; i&lt;&lt;endl; return i; &#125; &#125; cout &lt;&lt; &quot;该表内无&quot; &lt;&lt; e &lt;&lt; &quot;元素&quot; &lt;&lt; endl; return ERROR;&#125;//遍历打印int SeqList::ListTraverse(SeqList L) &#123; assert(L.elem != NULL); if (L.length == 0)cout &lt;&lt; &quot;该顺序表内无元素&quot; &lt;&lt; endl; cout &lt;&lt; &quot;L内元素为：&quot; ; for (int i = 0; i &lt; L.length; ++i) &#123; cout &lt;&lt; L.elem[i] &lt;&lt; &quot; &quot; ; &#125; cout &lt;&lt; endl; return OK;&#125;//置空int SeqList:: ClearList(SeqList&amp; L) &#123; delete[] L.elem; InitList(L); return OK;&#125;//改变i位置的值int SeqList::PutElem(SeqList&amp; L, int i, int e) &#123; assert(L.elem != NULL); if (i &lt; 0 || i &gt; L.length - 1) &#123; cout &lt;&lt; &quot;越界&quot; &lt;&lt; endl; return ERROR; &#125; L.elem[i] = e; return OK;&#125;//在第i个元素之前插入int SeqList::ListInsert(SeqList&amp; L, int i, int e) &#123; assert(L.elem != NULL); if (i &lt; 1 || i &gt; L.length + 1) &#123; cout &lt;&lt; &quot;插入位置越界&quot; &lt;&lt; endl; return ERROR; &#125; if (L.length &gt;= L.listsize) &#123;//存储空间已满 addlistsize(L, 1);//增加存储10Datatype容量 &#125; for (int j = L.length - 1; j &gt;= i - 1; --j) L.elem[j + 1] = L.elem[j]; L.elem[i - 1] = e; L.length++; return OK;&#125;//删除i个元素int SeqList::ListDelete(SeqList&amp; L, int i, int &amp;e) &#123; assert(L.elem != NULL); if (i &lt; 1 || i &gt; L.length) &#123; cout &lt;&lt; &quot;删除元素越界&quot; &lt;&lt; endl; return ERROR; &#125; e = L.elem[i]; for (; i &lt; L.length-1; ++i) L.elem[i] = L.elem[i+1]; L.length--; return OK;&#125;//尾插int SeqList::SeqListPushBack(SeqList &amp;L, int x) &#123; assert(&amp;L); //L.ListInsert(L,L.length+1,x); 调用插入函数 L.elem[L.length] = x; L.length++; return OK;&#125;//尾删int SeqList::SeqListPopBack(SeqList &amp;L) &#123; assert(&amp;L); int e; L.ListDelete(L,L.length-1,e); return e;&#125;//测试int SeqList:: Test() &#123; SeqList s; s.InitList(s);//初始化 s.SeqListPushBack(s, 1); //尾插 s.SeqListPushBack(s, 2); s.SeqListPushBack(s, 3); s.ListInsert(s, 4, 4); //指定插入 s.ListTraverse(s); //遍历 int e = 2, cure_e = 2; s.LocateElem(s, e);//获取e元素的位置 s.GetElem(s, 3, e);//获取第三个元素的值 s.PriorElem(s, cure_e, e);//求前驱 s.NextElem(s, cure_e, e);//求后驱 s.ListLength(s); //顺序表长度 s.PutElem(s, 2, 5);//改变第三个元素的值 s.SeqListPopBack(s); //尾删 s.ListTraverse(s); //遍历 s.ListLength(s); s.ClearList(s); //置空 s.ListTraverse(s); s.DestroyList(s); //销毁 s.ListTraverse(s); return OK;&#125; 函数列举初始化操作1234567int SeqList:: InitList(SeqList&amp; L) &#123; L.elem = new int[LIST_INIT_SIZE]; L.length = 0; L.listsize = LIST_INIT_SIZE; return OK; &#125; 增加存储容量1234567int SeqList:: addlistsize(SeqList&amp; L, int n) &#123; int* newbase = (int*)realloc(L.elem, (L.listsize + n * LISTINCREMENT) * sizeof(int)); if (!newbase)exit(OVERFLOW); L.elem = newbase; L.listsize += n * LISTINCREMENT;//增加储存容量 return OK;&#125; 结构销毁操作1234567int SeqList:: DestroyList(SeqList&amp; L) &#123; delete[] L.elem; L.elem = NULL; L.length = 0; L.listsize = 0; return OK;&#125; 判空123bool SeqList::ListEmpty(SeqList L) &#123; return L.length == 0;&#125; 求长12345int SeqList::ListLength(SeqList L) &#123; assert(L.elem != NULL); cout &lt;&lt; &quot;顺序表长度：&quot; &lt;&lt; L.length&lt;&lt;endl; return L.length;&#125; 求前驱12345678910111213int SeqList::PriorElem(SeqList L, int cur_e, int&amp; pre_e) &#123; assert(L.elem != NULL); if (LocateElem(L, cur_e) &lt;= 0) &#123; cout &lt;&lt; &quot;该元素无前驱&quot; &lt;&lt; endl; return ERROR; &#125; pre_e = L.elem[LocateElem(L, cur_e) - 1]; cout &lt;&lt; &quot;元素&quot;&lt;&lt;cur_e&lt;&lt;&quot;的前驱：&quot; &lt;&lt; pre_e &lt;&lt; endl; return OK;&#125; 求后驱123456789101112int SeqList::NextElem(SeqList L, int cur_e, int&amp; next_e) &#123; assert(L.elem != NULL); if (LocateElem(L, cur_e) &gt;= L.length - 1) &#123; cout &lt;&lt; &quot;该元素无后驱&quot; &lt;&lt; endl; return ERROR; &#125; next_e = L.elem[LocateElem(L, cur_e) + 1]; cout &lt;&lt; &quot;元素&quot; &lt;&lt; cur_e &lt;&lt; &quot;的后驱：&quot; &lt;&lt; next_e &lt;&lt; endl; return OK;&#125; 获取第i个元素的值返回于e12345678910int SeqList::GetElem(SeqList L, int i, int&amp; e) &#123; assert(L.elem != NULL); if (i &lt; 0 || i &gt; L.length ) &#123; cout &lt;&lt; &quot;越界&quot; &lt;&lt; endl; return ERROR; &#125; e = L.elem[i - 1]; return OK;&#125; 定位元素123456789101112int SeqList::LocateElem(SeqList L, int e) &#123; assert(L.elem != NULL); for (int i = 0; i &lt; L.length; ++i) &#123; if (L.elem[i] == e) &#123; cout &lt;&lt; &quot;元素&quot; &lt;&lt; e &lt;&lt; &quot;的位置：&quot; &lt;&lt; i&lt;&lt;endl; return i; &#125; &#125; cout &lt;&lt; &quot;该表内无&quot; &lt;&lt; e &lt;&lt; &quot;元素&quot; &lt;&lt; endl; return ERROR;&#125; 遍历打印1234567891011int SeqList::ListTraverse(SeqList L) &#123; assert(L.elem != NULL); if (L.length == 0)cout &lt;&lt; &quot;该顺序表内无元素&quot; &lt;&lt; endl; cout &lt;&lt; &quot;L内元素为：&quot; ; for (int i = 0; i &lt; L.length; ++i) &#123; cout &lt;&lt; L.elem[i] &lt;&lt; &quot; &quot; ; &#125; cout &lt;&lt; endl; return OK;&#125; 置空123456int SeqList:: ClearList(SeqList&amp; L) &#123; delete[] L.elem; InitList(L); return OK;&#125; 改变i位置的值12345678910int SeqList::PutElem(SeqList&amp; L, int i, int e) &#123; assert(L.elem != NULL); if (i &lt; 0 || i &gt; L.length - 1) &#123; cout &lt;&lt; &quot;越界&quot; &lt;&lt; endl; return ERROR; &#125; L.elem[i] = e; return OK;&#125; 在第i个元素之前插入12345678910111213141516int SeqList::ListInsert(SeqList&amp; L, int i, int e) &#123; assert(L.elem != NULL); if (i &lt; 1 || i &gt; L.length + 1) &#123; cout &lt;&lt; &quot;插入位置越界&quot; &lt;&lt; endl; return ERROR; &#125; if (L.length &gt;= L.listsize) &#123;//存储空间已满 addlistsize(L, 1);//增加存储10Datatype容量 &#125; for (int j = L.length - 1; j &gt;= i - 1; --j) L.elem[j + 1] = L.elem[j]; L.elem[i - 1] = e; L.length++; return OK;&#125; 删除i个元素12345678910111213int SeqList::ListDelete(SeqList&amp; L, int i, int &amp;e) &#123; assert(L.elem != NULL); if (i &lt; 1 || i &gt; L.length) &#123; cout &lt;&lt; &quot;删除元素越界&quot; &lt;&lt; endl; return ERROR; &#125; e = L.elem[i]; for (; i &lt; L.length-1; ++i) L.elem[i] = L.elem[i+1]; L.length--; return OK;&#125; 尾插12345678int SeqList::SeqListPushBack(SeqList &amp;L, int x) &#123; assert(&amp;L); //L.ListInsert(L,L.length+1,x); 调用插入函数 L.elem[L.length] = x; L.length++; return OK;&#125; 置空123456int SeqList:: ClearList(SeqList&amp; L) &#123; delete[] L.elem; InitList(L); return OK;&#125; 尾删12345678int SeqList::SeqListPopBack(SeqList &amp;L) &#123; assert(&amp;L); int e; L.ListDelete(L,L.length-1,e); return e;&#125; LinkedList操作合集123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250#include &quot;ListNode.h&quot;#include &quot;iostream&quot;using namespace std;ListNode::ListNode()&#123; this-&gt;val =0; this-&gt;next =nullptr;&#125;ListNode::ListNode(int val, ListNode* next)&#123; this-&gt;val = val; this-&gt;next = next;&#125;ListNode::ListNode(int val)&#123; this-&gt;val = val;&#125;ListNode::ListNode( ListNode* next)&#123; this-&gt;next = next;&#125;int ListNode::Val() &#123; return val;&#125;//初始化ListNode* ListNode::initList(ListNode* head,int a[],int n) &#123; int inputnum; int i=0; ListNode* node; ListNode* nodetemp; head = nullptr; nodetemp = nullptr; while (n--) &#123; inputnum=a[i]; i++; node = new ListNode; node-&gt;val = inputnum; if (head == nullptr) &#123; head = node; &#125; else &#123; nodetemp-&gt;next = node; &#125; nodetemp = node; nodetemp-&gt;next = nullptr; &#125; return head;&#125;//创建ListNode* ListNode::CreatList(ListNode* head,int n) &#123; cout &lt;&lt; &quot;input:&quot;; int inputnum; ListNode* node; ListNode* nodetemp; head = nullptr; nodetemp = nullptr; while (n--) &#123; cin &gt;&gt; inputnum; node = new ListNode; node-&gt;val = inputnum; if (head == nullptr) &#123; head = node; &#125; else &#123; nodetemp-&gt;next = node; &#125; nodetemp = node; nodetemp-&gt;next = nullptr; &#125; return head;&#125;//遍历int ListNode::ListTravel(ListNode* head) &#123; cout &lt;&lt; &quot;链表元素依次为：&quot; ; ListNode* curnode=new ListNode(); curnode = head; while (curnode != nullptr) &#123; cout &lt;&lt; curnode-&gt;val&lt;&lt;&quot; &quot;; curnode = curnode-&gt;next; &#125; return OK;&#125;//翻转链表(双指针)ListNode* ListNode::reverseList_1(ListNode* head) &#123; ListNode* temp; //保存cur下一个节点 ListNode* cur = head; ListNode* pre = NULL; while (cur) &#123; temp = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = temp; &#125; return pre;&#125;//翻转链表(递归)ListNode* ListNode::reverseList_2(ListNode* head) &#123; return reverse(NULL, head);&#125;ListNode* ListNode::reverse(ListNode* pre, ListNode* cur) &#123; if (cur == NULL)return pre; ListNode* temp = cur-&gt;next; cur-&gt;next = pre; return reverse(cur, pre);&#125;//链表左右两两交换ListNode* ListNode::swapPairs(ListNode* head) &#123; ListNode* dummtyHead = new ListNode(0);//虚拟头节点 dummtyHead-&gt;next = head; ListNode* cur = dummtyHead; while (cur-&gt;next != NULL &amp;&amp; cur-&gt;next-&gt;next != NULL) &#123; ListNode* tmp = cur-&gt;next;//记录临时节点 ListNode* tmp1 = cur-&gt;next-&gt;next-&gt;next;//记录临时节点 cur-&gt;next = cur-&gt;next-&gt;next-&gt;next;//第一步 cur-&gt;next-&gt;next = tmp;//第二步 cur-&gt;next-&gt;next-&gt;next = tmp1;//第三步 cur = cur-&gt;next-&gt;next;//cur向后移动两位，准备下一轮交换 &#125; return dummtyHead-&gt;next;&#125;//链表长度int ListNode::ListLength(ListNode* head) &#123; ListNode* cur = head; int n = 0; while (cur-&gt;next != NULL) &#123; cur = cur-&gt;next; n++; &#125; return n;&#125;//删除倒数第N个ListNode* ListNode::deletebehindN(ListNode* head, int n) &#123; ListNode* cur = head; int length = ListLength(head); for (int i = 0; i &lt; length - n; i++) &#123; cur = cur-&gt;next; &#125; cur-&gt;next = cur-&gt;next-&gt;next; return head;&#125;//删除倒数第N个(双指针)ListNode* ListNode::removeNthfromEnd(ListNode* head, int n) &#123; ListNode* dummyHead = new ListNode(0); dummyHead-&gt;next = head; ListNode* fast = dummyHead; ListNode* slow = dummyHead; while (n-- &amp;&amp; fast != nullptr) &#123; fast = fast-&gt;next; &#125; fast = fast-&gt;next;//再往前走一步，让slow指向删除节点前一个 while (fast != nullptr) &#123; fast = fast-&gt;next; slow = slow-&gt;next; &#125; slow-&gt;next = slow-&gt;next-&gt;next; return dummyHead-&gt;next;&#125;//判断是否有环ListNode* ListNode::ifcircle(ListNode* head) &#123; ListNode* fast; ListNode* slow; int count = 0; fast = slow = head; while (fast != NULL &amp;&amp; fast-&gt;next != NULL) &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if (fast == slow) &#123; ListNode* index1; ListNode* index2; index1 = head; index2 = fast; while (index1 != index2) &#123; count++; index1 = index1-&gt;next; index2 = index2-&gt;next; &#125; return index2; &#125; &#125; return NULL;&#125;//相交节点ListNode* ListNode::getIntersectionNode(ListNode* headA, ListNode* headB) &#123; ListNode* curA = headA; ListNode* curB = headB; int lenA = 0, lenB = 0; while (curA != NULL) &#123; lenA++; curA = curA-&gt;next; &#125; while (curB != NULL) &#123; lenB++; curB = curB-&gt;next; &#125; curA = headA; curB = headB; if (lenB &gt; lenA) &#123; int i = lenB - lenA; while (i--) &#123; curB = curB-&gt;next; &#125; &#125; else &#123; int i = lenA - lenB; while (i--) &#123; curA = curA-&gt;next; &#125; &#125; while (curA != curB) &#123; //地址相等 curA = curA-&gt;next; curB = curB-&gt;next; &#125; return curA;&#125; 函数列举初始化12345678910111213141516171819202122232425ListNode* ListNode::initList(ListNode* head,int a[],int n) &#123; int inputnum; int i=0; ListNode* node; ListNode* nodetemp; head = nullptr; nodetemp = nullptr; while (n--) &#123; inputnum=a[i]; i++; node = new ListNode; node-&gt;val = inputnum; if (head == nullptr) &#123; head = node; &#125; else &#123; nodetemp-&gt;next = node; &#125; nodetemp = node; nodetemp-&gt;next = nullptr; &#125; return head;&#125; 创建123456789101112131415161718192021222324ListNode* ListNode::CreatList(ListNode* head,int n) &#123; cout &lt;&lt; &quot;input:&quot;; int inputnum; ListNode* node; ListNode* nodetemp; head = nullptr; nodetemp = nullptr; while (n--) &#123; cin &gt;&gt; inputnum; node = new ListNode; node-&gt;val = inputnum; if (head == nullptr) &#123; head = node; &#125; else &#123; nodetemp-&gt;next = node; &#125; nodetemp = node; nodetemp-&gt;next = nullptr; &#125; return head;&#125; 遍历1234567891011int ListNode::ListTravel(ListNode* head) &#123; cout &lt;&lt; &quot;链表元素依次为：&quot; ; ListNode* curnode=new ListNode(); curnode = head; while (curnode != nullptr) &#123; cout &lt;&lt; curnode-&gt;val&lt;&lt;&quot; &quot;; curnode = curnode-&gt;next; &#125; return OK;&#125; 翻转链表(双指针)12345678910111213ListNode* ListNode::reverseList_1(ListNode* head) &#123; ListNode* temp; //保存cur下一个节点 ListNode* cur = head; ListNode* pre = NULL; while (cur) &#123; temp = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = temp; &#125; return pre;&#125; 翻转链表(递归)1234567891011ListNode* ListNode::reverseList_2(ListNode* head) &#123; return reverse(NULL, head);&#125;ListNode* ListNode::reverse(ListNode* pre, ListNode* cur) &#123; if (cur == NULL)return pre; ListNode* temp = cur-&gt;next; cur-&gt;next = pre; return reverse(cur, pre);&#125; 链表左右两两交换1234567891011121314151617ListNode* ListNode::swapPairs(ListNode* head) &#123; ListNode* dummtyHead = new ListNode(0);//虚拟头节点 dummtyHead-&gt;next = head; ListNode* cur = dummtyHead; while (cur-&gt;next != NULL &amp;&amp; cur-&gt;next-&gt;next != NULL) &#123; ListNode* tmp = cur-&gt;next;//记录临时节点 ListNode* tmp1 = cur-&gt;next-&gt;next-&gt;next;//记录临时节点 cur-&gt;next = cur-&gt;next-&gt;next-&gt;next;//第一步 cur-&gt;next-&gt;next = tmp;//第二步 cur-&gt;next-&gt;next-&gt;next = tmp1;//第三步 cur = cur-&gt;next-&gt;next;//cur向后移动两位，准备下一轮交换 &#125; return dummtyHead-&gt;next;&#125; 链表长度12345678910int ListNode::ListLength(ListNode* head) &#123; ListNode* cur = head; int n = 0; while (cur-&gt;next != NULL) &#123; cur = cur-&gt;next; n++; &#125; return n;&#125; 删除倒数第N个123456789101112ListNode* ListNode::deletebehindN(ListNode* head, int n) &#123; ListNode* cur = head; int length = ListLength(head); for (int i = 0; i &lt; length - n; i++) &#123; cur = cur-&gt;next; &#125; cur-&gt;next = cur-&gt;next-&gt;next; return head;&#125; 删除倒数第N个(双指针)123456789101112131415161718ListNode* ListNode::removeNthfromEnd(ListNode* head, int n) &#123; ListNode* dummyHead = new ListNode(0); dummyHead-&gt;next = head; ListNode* fast = dummyHead; ListNode* slow = dummyHead; while (n-- &amp;&amp; fast != nullptr) &#123; fast = fast-&gt;next; &#125; fast = fast-&gt;next;//再往前走一步，让slow指向删除节点前一个 while (fast != nullptr) &#123; fast = fast-&gt;next; slow = slow-&gt;next; &#125; slow-&gt;next = slow-&gt;next-&gt;next; return dummyHead-&gt;next;&#125; 判断是否有环123456789101112131415161718192021222324252627ListNode* ListNode::ifcircle(ListNode* head) &#123; ListNode* fast; ListNode* slow; int count = 0; fast = slow = head; while (fast != NULL &amp;&amp; fast-&gt;next != NULL) &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if (fast == slow) &#123; ListNode* index1; ListNode* index2; index1 = head; index2 = fast; while (index1 != index2) &#123; count++; index1 = index1-&gt;next; index2 = index2-&gt;next; &#125; return index2; &#125; &#125; return NULL;&#125; 相交节点12345678910111213141516171819202122232425262728293031323334353637ListNode* ListNode::getIntersectionNode(ListNode* headA, ListNode* headB) &#123; ListNode* curA = headA; ListNode* curB = headB; int lenA = 0, lenB = 0; while (curA != NULL) &#123; lenA++; curA = curA-&gt;next; &#125; while (curB != NULL) &#123; lenB++; curB = curB-&gt;next; &#125; curA = headA; curB = headB; if (lenB &gt; lenA) &#123; int i = lenB - lenA; while (i--) &#123; curB = curB-&gt;next; &#125; &#125; else &#123; int i = lenA - lenB; while (i--) &#123; curA = curA-&gt;next; &#125; &#125; while (curA != curB) &#123; //地址相等 curA = curA-&gt;next; curB = curB-&gt;next; &#125; return curA;&#125; 移除列表元素（JAVA）123456789101112131415161718192021public ListNode removeElements(ListNode head, int val) &#123; while (head != null &amp;&amp; head.val == val) &#123; head = head.next; &#125; // 已经为null，提前退出 if (head == null) &#123; return head; &#125; // 已确定当前head.val != val ListNode pre = head; ListNode cur = head.next; while (cur != null) &#123; if (cur.val == val) &#123; pre.next = cur.next; &#125; else &#123; pre = cur; &#125; cur = cur.next; &#125; return head;&#125; 设计链表（JAVA）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109//单链表class LinkedNode &#123; int val; LinkedNode next; LinkedNode()&#123;&#125; LinkedNode(int val) &#123; this.val=val; &#125;&#125;class MyLinkedList &#123; int size; LinkedNode head; public MyLinkedList() &#123; size = 0; head = new LinkedNode(0); &#125; public int get(int index) &#123; if(index&gt;=size)&#123; return -1; &#125; if(index&lt;0)&#123; index=0; &#125; LinkedNode pre=head; for(int i =0;i&lt;=index;i++)&#123; pre=pre.next; &#125; return pre.val; &#125; public void addAtHead(int val) &#123; addAtIndex(0, val); &#125; public void addAtTail(int val) &#123; addAtIndex(size, val); &#125; public void addAtIndex(int index, int val) &#123; if (index &gt; size) &#123; return; &#125; if (index &lt; 0) &#123; index = 0; &#125; size++; LinkedNode pre = head; for (int i = 0; i &lt; index; i++) &#123; pre = pre.next; &#125; LinkedNode toAdd = new LinkedNode(val); toAdd.next = pre.next; pre.next = toAdd; &#125; public void deleteAtIndex(int index) &#123; if (index &gt;= size) &#123; return; &#125; if (index &lt; 0) &#123; index = 0; &#125; size--; LinkedNode pre=head; for(int i=0;i&lt;index;i++)&#123; pre=pre.next; &#125; pre.next=pre.next.next; &#125; public void overTurn() &#123; ListNode prev = null; ListNode cur = head; ListNode temp = null; while (cur != null) &#123; temp = cur.next;//保存下一节点 cur.next = prev;//连接上一节点 prev = cur;//保存当前节点 cur = temp;//切换节点 &#125; head.next= prev; ListNode newnode =head; for(int i=0;i&lt;size;i++)&#123; newnode=newnode.next; &#125; newnode.next=null; &#125; public void reverseList(ListNode Start,ListNode End) &#123; head.next = reverse(Start,End ); &#125; private ListNode reverse(ListNode prev, ListNode cur) &#123; if (cur == null) &#123; return prev; &#125; ListNode temp = null; temp = cur.next;// 先保存下一个节点 cur.next = prev;// 反转 // 更新prev、cur位置 // prev = cur; // cur = temp; return reverse(cur, temp); &#125;&#125; 结构体定义12345678910111213141516171819202122232425262728#define _CRT_SECURE_NO_WARNINGS#include &quot;stdio.h&quot;#include &quot;cstdlib&quot;#define OK 1;#define ERROR -1;#define LIST_INIT_SIZE 100#define LISTINCREMENT 10typedef char ElemType;typedef int Status;typedef struct LNode &#123;//单链表 ElemType data; //数据 struct LNode* next; //下一指针&#125;LNode, * LinkList;typedef struct DuLNode &#123;//双向链表 ElemType data; struct DuLNode* prior; struct DuLNode* next;&#125;DuLNode, * DiLinkList;typedef struct SeqList &#123; int* elem;//线性表首地址 int length;//长度 int listsize = LIST_INIT_SIZE;//当前分配的存储空间&#125;; 表的初始化，不带头节点，内置，顺序123456789101112LinkList CreatSlist()&#123; LinkList head = NULL; for (int i = 5; i &gt;= 1; i--) &#123; LinkList newhead = (LinkList)malloc(sizeof(LNode)); newhead-&gt;data = i; newhead-&gt;next = head; head = newhead; &#125; return head;&#125; 顺序创建，输入，n123456789101112void CreatListno(LinkList&amp; L, int n) &#123; L = (LinkList)malloc(sizeof(LNode)); L-&gt;next = NULL; LinkList nL = L; for (int i = 0; i &lt; n; i++) &#123; LinkList p = (LinkList)malloc(sizeof(LNode)); scanf(&quot;%d&quot;, &amp;p-&gt;data); p-&gt;next = nL-&gt;next; nL-&gt;next = p; nL = p; &#125;&#125; 逆序创建输入单链表,n12345678910void CreateList(LinkList&amp; L, int n) &#123; L = (LinkList)malloc(sizeof(LNode)); L-&gt;next = NULL; for (int i = n; i &gt; 0; i--) &#123; LinkList p = (LinkList)malloc(sizeof(LNode)); scanf(&quot;%d&quot;, &amp; p-&gt;data); p-&gt;next = L-&gt;next; L-&gt;next = p; &#125;&#125; 遍历123456789void travel(LinkList L) &#123; LinkList p = L-&gt;next; if (!p)printf(&quot;空表&quot;); while (p != NULL) &#123; printf(&quot;%c &quot;, p-&gt;data); p = p-&gt;next; &#125; printf(&quot;\\n&quot;);&#125; 打印输出1234567891011void print(LinkList P)&#123; while (P != NULL) &#123; printf(&quot;%d &quot;, P-&gt;data); P = P-&gt;next; &#125; printf(&quot;\\n&quot;); return;&#125; 取第i个结点元素1234567891011Status GetElem(LinkList L,int i,ElemType &amp;e) &#123; LinkList p = L-&gt;next; int j = i; while (p &amp;&amp; j &lt; i) &#123; p = p-&gt;next; ++j; &#125; if (!p || j &gt; i)return ERROR; e = p-&gt;data; return OK;&#125; 在第i个元素之前插入12345678910111213141516Status ListInsert(LinkList &amp;L,int i,ElemType e) &#123; LinkList p = L; int j = i; while (p &amp;&amp; j &lt; i-1) &#123; p = p-&gt;next; ++j; &#125; if (!p || j &lt; i - 1) &#123; return ERROR; &#125; LinkList q = (LinkList)malloc(sizeof(LNode)); q-&gt;data = e; q-&gt;next = p-&gt;next; p-&gt;next = q; return OK;&#125; 删除data值为x的结点123456789101112131415161718192021222324void ListDel_X(LinkList&amp; L, int x) &#123; if (L-&gt;next == NULL) &#123; printf(&quot;空表无法删除\\n&quot;); return; &#125; LinkList p = L-&gt;next, pre_p = L; int flag = 0; while (p) &#123; if (p-&gt;data == x) &#123; pre_p-&gt;next = p-&gt;next; free(p); p = pre_p-&gt;next; //p=p-&gt;next; //pre_p-&gt;next=p; flag = 1; &#125; else &#123; pre_p = p; p = p-&gt;next; &#125; &#125; flag == 1 ? printf(&quot;已删除\\n&quot;) : printf(&quot;无此元素\\n&quot;);&#125; 删除data值为x的直接前驱结点1234567891011121314151617181920212223242526void ListDel_Xpre(LinkList&amp; L, int x) &#123; if (L-&gt;next == NULL) &#123; printf(&quot;空表无法删除\\n&quot;); return; &#125; LinkList p = L-&gt;next, pre_p = L; if (p-&gt;data == x) printf(&quot;首元素无前驱无法执行操作\\n&quot;); p = p-&gt;next; int flag = 0; while (p) &#123; if (p-&gt;data == x) &#123; pre_p-&gt;next = p; p = pre_p-&gt;next-&gt;next; //p=p-&gt;next; //pre_p-&gt;next=p; flag = 1; &#125; else &#123; pre_p = pre_p-&gt;next; p = p-&gt;next; &#125; &#125; flag == 1 ? printf(&quot;已删除直接前驱\\n&quot;) : printf(&quot;无此元素\\n&quot;);&#125; 删除第i个结点1234567891011Status ListDelete(LinkList&amp; L, int i, ElemType e) &#123; LinkList p = L; int j = i; while (p-&gt;next &amp;&amp; j &lt; i - 1) &#123; p = p-&gt;next; ++j; &#125; if (!p-&gt;next || j &gt; i - 1)return ERROR; p-&gt;next = p-&gt;next-&gt;next; return OK; &#125; 删除最小元素结点1234567891011121314151617Status DelMinNode(LinkList&amp; head) &#123; LinkList p = head-&gt;next, pre = head; LinkList minp=NULL, minpre=NULL; ElemType min = p-&gt;data; while (p != NULL) &#123; if (p-&gt;data &lt; pre-&gt;data) &#123; min = p-&gt;data; minp = p; minpre = pre; &#125; pre = p; p = p-&gt;next; &#125; minpre-&gt;next = minp-&gt;next; free(minp); return OK;&#125; 改造单向循环链表12345678Status linklist_cycle(LNode* head) &#123; LNode* p = head; if (!p)return ERROR; while (p-&gt;next != NULL)//时间复杂度为O(n)为链表长度 p = p-&gt;next; p-&gt;next = head; return OK;&#125; 连接循环链表12345678Status merge(LNode *L1,LNode *L2) &#123; LNode* p = L1, * q = L2; while (p-&gt;next != L1)p = p-&gt;next; while (q-&gt;next != L2)q = q-&gt;next; q-&gt;next = L1; p-&gt;next = L2; return OK;&#125; 顺序表逆置最小辅助空间(顺序表)123456789Status Invert_seqList(SeqList &amp;L) &#123; ElemType temp; for (int i = 0; i &lt; L.length / 2; i++) &#123; temp = L.elem[i]; L.elem[i] = L.elem[L.length - i - 1]; L.elem[L.length - i - 1] = temp; &#125; return OK;&#125; 逆置算法(三辅助)1234567891011121314Status invent(LinkList &amp;head)&#123; LinkList p, q, r; if (!head-&gt;next)return ERROR; p = head-&gt;next; q = p-&gt;next; p-&gt;next = NULL; while (q) &#123; r = q; q = q-&gt;next; head-&gt;next = r; r-&gt;next = p; p = r; &#125;&#125; 头插法1234567891011LinkList reserve(LinkList &amp;head) &#123; LinkList temp=NULL, phead=NULL; while (head != NULL) &#123; temp = head; head = head-&gt;next; temp-&gt;next = phead; phead = temp; &#125; return phead;&#125; 就地逆置12345678910111213LinkList reverse_2(LinkList&amp; head) &#123; LinkList p = NULL,q = NULL; p = head; q = head-&gt;next; while (q != NULL) &#123; p-&gt;next = q-&gt;next; q-&gt;next = head; head = q; q = p-&gt;next; &#125; p = NULL; return head;&#125; 判断回文123456789101112131415161718192021222324252627282930313233343536373839404142Status ifPalin()&#123; char c; int flag = 1; LinkList L1,L2; L1 = (LinkList)malloc(sizeof(LNode)); L2 = (LinkList)malloc(sizeof(LNode)); L1-&gt;next = NULL; L2-&gt;next = NULL; LinkList nL1= L1,nL2=L2; LinkList p= (LinkList)malloc(sizeof(LNode)); LinkList q = (LinkList)malloc(sizeof(LNode));while ((c=getchar())!=&#x27;@&#x27;) &#123; //顺序 p = (LinkList)malloc(sizeof(LNode)); p-&gt;data = c; p-&gt;next = nL1-&gt;next; nL1-&gt;next = p; nL1 = p; //逆序 q = (LinkList)malloc(sizeof(LNode)); q-&gt;data = c; q-&gt;next = nL2-&gt;next; nL2-&gt;next = q; &#125; nL1 = L1-&gt;next; nL2 = L2-&gt;next; while (nL1!=NULL) &#123; if (nL1-&gt;data == nL2-&gt;data) &#123; nL1 = nL1-&gt;next; nL2 = nL2-&gt;next; &#125; else &#123; printf(&quot;bu是&quot;); return 0; &#125; &#125; printf(&quot;是&quot;); return 1;&#125; 栈理论底层容器：缺省情况下deque(双向队列)&#x2F;list&#x2F;vector 12std::stack&lt;int, std::vector&lt;int&gt; &gt; third; // 使用vector为底层容器的栈std::queue&lt;int, std::list&lt;int&gt;&gt; third; // 定义以list为底层容器的队列 标准栈操作 push(x) – 将一个元素放入队列的尾部。pop() – 从队列首部移除元素。peek() – 返回队列首部的元素。empty() – 返回队列是否为空。 操作合集(用stackr容器)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Solution &#123;public: struct abb &#123; int data; &#125;abb;private: string s;public: //有效的括号 bool isValid(string s) &#123; if (s.size() % 2 != 0)return false;//为奇数一定不匹配 stack&lt;char&gt; st; cout &lt;&lt; st.empty(); for (int i = 0; i &lt; s.size(); i++) &#123; if (s[i] == &#x27;(&#x27;)st.push(&#x27;)&#x27;); else if (s[i] == &#x27;&#123;&#x27;)st.push(&#x27;&#125;&#x27;); else if (s[i] == &#x27;[&#x27;)st.push(&#x27;]&#x27;); else if (st.empty() || st.top() != s[i])return false; else st.pop(); &#125; return st.empty(); &#125; //删除字符串中的所有相邻重复项 string removeDuplicates(string S) &#123; stack&lt;char&gt; st; for (char s : S) &#123; if (st.empty() || s != st.top()) &#123; st.push(s); &#125; else &#123; st.pop(); &#125; &#125; string result = &quot;&quot;; while (!st.empty()) &#123; result += st.top(); st.pop(); &#125; reverse(result.begin(), result.end()); return result; &#125; //逆波兰表达式求值 int evalRPN(vector&lt;string&gt; &amp;s) &#123; stack&lt;int&gt; st; for (int i = 0; i &lt; s.size(); i++) &#123; int num1 = st.top(); st.pop(); int num2 = st.top(); st.pop(); if (s[i] == &quot;+&quot; || s[i] == &quot;-&quot; || s[i] == &quot;*&quot; || s[i] == &quot;/&quot;) &#123; if (s[i] == &quot;+&quot;)st.push(num1 + num2); if (s[i] == &quot;-&quot;)st.push(num1 - num2); if (s[i] == &quot;*&quot;)st.push(num1 * num2); if (s[i] ==&quot;/&quot;)st.push(num1 / num2); &#125; else &#123; st.push(stoi(s[i])); &#125; &#125; int result = st.top(); st.pop(); return result; &#125;&#125;; 操作合集（自定义结构体）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;cstdlib&gt;//malloc#define OK 1#define ERROR -1#define STACK_INIT_SIZE 100 //初始分配空间#define STACKINCREMENT 10 //分配增量typedef int ElemType;typedef int Status;//栈的链式实现typedef struct SNode&#123; ElemType data; struct SNode* next;&#125;SNode,*StackPtr;typedef struct &#123; StackPtr top;//栈顶指针 int count; //元素数&#125;LinkStack;Status InitStackLink(LinkStack &amp;S) &#123; S.top = NULL; S.count = 0; return OK;&#125;Status GetTopLink(LinkStack S,ElemType &amp;e) &#123; printf(&quot;COUNT:%d\\n&quot;,S.count); if (S.count == 0)return ERROR; e = S.top-&gt;data; printf(&quot;gettop:%d&quot;,e); return OK;&#125;Status PopLink(LinkStack &amp;S,ElemType &amp;e) &#123; if (S.count == 0)return ERROR; e = S.top-&gt;data; S.top = S.top-&gt;next; S.count--; return OK;&#125;Status PushLink(LinkStack&amp; S, ElemType e) &#123; SNode* p = (StackPtr)malloc(sizeof(SNode)); if (!p)printf(&quot;ERROR\\n&quot;); p-&gt;data = e; p-&gt;next = S.top; S.top = p; printf(&quot;push:%d\\n&quot;,S.top-&gt;data); S.count++; return OK;&#125;//栈的顺序实现typedef struct &#123; ElemType* base;//存储空间基址 ElemType* top;//栈顶指针 int StackSize;//已分配空间&#125;SqStack;//初始化操作Status InitStack(SqStack &amp;S) &#123; S.base = (ElemType*)malloc(STACK_INIT_SIZE*sizeof(ElemType)); if (!S.base) &#123; exit(OVERFLOW); &#125; S.top = S.base; S.StackSize = STACK_INIT_SIZE; return OK;&#125;//取栈顶元素Status GetTop(SqStack S) &#123; if (S.top == S.base)return ERROR; return *(S.top-1);&#125;//进栈Status Push(SqStack&amp; S, ElemType e) &#123; if (S.top - S.base &gt;= S.StackSize) &#123; S.base = (ElemType*)realloc(S.base, S.StackSize+STACKINCREMENT * sizeof(ElemType)); if (!S.base)exit(OVERFLOW); S.top = S.base + S.StackSize; S.StackSize += STACKINCREMENT; &#125; *(S.top++) = e; return OK;&#125;//出栈Status Pop(SqStack&amp; S, ElemType&amp; e) &#123; if (S.top == S.base)return ERROR; e = *(--S.top); return OK;&#125;//判断栈空bool StackEmpty(SqStack S) &#123; if (S.base == S.top)return true; else &#123; return false; &#125;&#125;//进制转换 不断取模入栈，num=num/nvoid conversion(int num,int n,ElemType &amp;e) &#123; ElemType temp; SqStack S; int flag = 1; while (num) &#123; Push(S, num % n); num = num / n; &#125; while (!StackEmpty(S)) &#123; Pop(S, temp); if (flag)flag = 0; else &#123; e = temp * 10 + temp; &#125; printf(&quot;&amp;d&quot;, temp); &#125; printf(&quot;\\n&quot;); printf(&quot;%d&quot;, e);&#125;//判断是否为运算符，是运算符返回1，若不是返回0int In(char c) &#123; switch (c) &#123; case &#x27;+&#x27;: case &#x27;-&#x27;: case &#x27;*&#x27;: case &#x27;/&#x27;: case &#x27;(&#x27;: case &#x27;)&#x27;: case &#x27;=&#x27;: return 1; default: return 0; &#125;&#125;//判断是否为数，是运算符返回1，若不是返回0int InNum(char c)&#123; if (c &gt;= 48 &amp;&amp; c &lt;= 57)return 1; else &#123; return 0; &#125;&#125;//比较优先级char Precede(char operate1, char operate2)&#123; int i, j; char pre[7][7] = &#123;// + - * / ( ) = &#123;&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;&#125;, &#123;&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;&#125;, &#123;&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&lt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;&#125;, &#123;&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&lt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;&#125;, &#123;&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;=&#x27;,&#x27;0&#x27;&#125;, &#123;&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;0&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;&#125;, &#123;&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;0&#x27;,&#x27;=&#x27;&#125; &#125;; switch (operate1) &#123; case &#x27;+&#x27;: i = 0; break; case &#x27;-&#x27;: i = 1; break; case &#x27;*&#x27;: i = 2; break; case &#x27;/&#x27;: i = 3; break; case &#x27;(&#x27;: i = 4; break; case &#x27;)&#x27;: i = 5; break; case &#x27;=&#x27;: i = 6; break; &#125; switch (operate2) &#123; case &#x27;+&#x27;: j = 0; break; case &#x27;-&#x27;: j = 1; break; case &#x27;*&#x27;: j = 2; break; case &#x27;/&#x27;: j = 3; break; case &#x27;(&#x27;: j = 4; break; case &#x27;)&#x27;: j = 5; break; case &#x27;=&#x27;: j = 6; break; &#125; return(pre[i][j]);&#125;//操作int Operate(int a, char operate, int b)&#123; int result; switch (operate) &#123; case&#x27;+&#x27;:return a + b; case&#x27;-&#x27;:return a - b; case&#x27;*&#x27;:return a * b; case&#x27;/&#x27;: //判断除数是否为0，若除数为零返回错误提示 if (b != 0) return a / b; else &#123; printf(&quot;0不能作为被除数!\\n&quot;); exit(1); &#125; &#125;&#125;//数学表达式求值ElemType EvaluateExpressione(char content[]) &#123; SqStack OPTR;//运算符栈 SqStack OPND;//运算数栈； InitStack(OPTR); InitStack(OPND); Push(OPTR, &#x27;=&#x27;); int temp; int e;//存放pop操作符 int a,b;//pop操作数 int x, y;//存放数 char ch;//读取内容字符 int i = 0;//表达式数组下标 ch = content[i]; while (ch != &#x27;=&#x27; || GetTop(OPTR) != &#x27;=&#x27;) &#123; if (InNum(ch)) &#123;//是操作数 x = ch - &#x27;0&#x27;; Push(OPND, x); y = x; ch = content[++i];//读取下一位字符并将指针向后偏移一位 while (InNum(ch)) &#123; x = ch - &#x27;0&#x27;; y = 10 * y + x; Pop(OPND, a); Push(OPND, y); ch = content[++i];//读取下一位字符并将指针向后偏移一位 &#125; &#125; else if(In(ch)) &#123;//操作符 switch (Precede(GetTop(OPTR), ch))//比较ch的与OPTR栈顶元素的优先级 &#123; case&#x27;&lt;&#x27;: Push(OPTR, ch); ch = content[++i]; //读取下一位字符并将指针向后偏移一位 break; case&#x27;&gt;&#x27;: Pop(OPTR, e); Pop(OPND, a); Pop(OPND, b); Push(OPND, Operate(b,e,a)); break; case&#x27;=&#x27;: Pop(OPTR,temp); ch =content[++i]; //读取下一位字符并将指针向后偏移一位 break; &#125; &#125; else &#123; printf(&quot;输入包含无效字符！&quot;); exit(1); &#125; &#125; return GetTop(OPND);&#125;//数学表达式求值ElemType EvaluateExpressione2( ) &#123; SqStack OPTR;//运算符栈 SqStack OPND;//运算数栈； InitStack(OPTR); InitStack(OPND); Push(OPTR, &#x27;=&#x27;); int a, b, e,x; char ch = getchar(); while (ch != &#x27;=&#x27; || GetTop(OPTR) != &#x27;=&#x27;) &#123; if (!In(ch)) &#123;//是操作数 Push(OPND,ch); printf(&quot;操作数&quot;); ch = getchar(); &#125; else &#123;//操作符 switch (Precede(GetTop(OPTR), ch))//比较ch的与OPTR栈顶元素的优先级 &#123; case&#x27;&lt;&#x27;: Push(OPTR, ch); ch = getchar(); break; case&#x27;&gt;&#x27;: Pop(OPTR, e); Pop(OPND, a); Pop(OPND, b); Push(OPND, Operate(b, e, a)); break; case&#x27;=&#x27;: Pop(OPTR, x); ch = getchar(); break; &#125; &#125; &#125; return GetTop(OPND);&#125;Status main() &#123; char content[100]; //定义一个字符数组用于存储表达式 int result; int i = 0; do &#123; i = 0; printf(&quot;请输入表达且以=结束:\\n&quot;); do &#123; content[i++] = getchar(); &#125; while (content[i - 1] != &#x27;=&#x27;); result = EvaluateExpressione(content); printf(&quot;%d\\n&quot;, result); getchar(); printf(&quot;请按回车以继续，若结束请输入！&quot;); &#125; while (getchar() != &#x27;!&#x27;); return 0;&#125; Pair数据类型1.1 pair类型概述 pair的功能就像它的名字一样，pair将一对值组合成一个值，这一对值可以具有不同的数据类型，两个值可以分别用pair的两个公有函数first和second访问。 pair类所在的头文件与命名函数是： 1#include &lt;utility&gt; 1.2 pair对象基本定义 pair是一种模板类型，其中包含两个数据值，两个数据的类型可以不同，基本的定义如下： 1pair&lt;int, string&gt; a; 表示a中有两个类型，第一个元素是int型的，第二个元素是string类型的，如果创建pair的时候没有对其进行初始化，则调用默认构造函数对其初始化。 1pair&lt;string, string&gt; a(&quot;James&quot;, &quot;Joy&quot;); 也可以像上面一样在定义的时候直接对其初始化。 由于pair类型的使用比较繁琐，因为如果要定义多个形同的pair类型的时候，可以时候typedef简化声明： 123typedef pair&lt;string, string&gt; author;author pro(&quot;May&quot;, &quot;Lily&quot;);author joye(&quot;James&quot;, &quot;Joyce&quot;); 1.3 pair对象访问 对于pair类，由于它只有两个元素，分别名为first和second，因此直接使用普通的点操作符即可访问其成员 123pair&lt;string, string&gt; a(&quot;Lily&quot;, &quot;Poly&quot;); string name;name = pair.second; 1.4 生成新的pair对象 可以使用make_pair对已存在的两个数据构造一个新的pair类型： 123456int a = 8;string m = &quot;James&quot;;pair&lt;int, string&gt; newone;newone = make_pair(a, m)； 队列操作合集1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class Myqueue &#123; //实现单调队列（从大到小）滑动窗口最大值public: deque&lt;int&gt; que; //弹出前检查是否为空且弹出元素是否为front元素 void pop(int value) &#123; if (!que.empty() &amp;&amp; value == que.front()) &#123; que.pop_front(); 7h77777777777777777777777777 &#125; void push(int value) &#123; while (!que.empty() &amp;&amp; value &gt; que.back()) &#123; que.pop_back(); &#125; que.push_back(value); &#125; int front() &#123; return que.front(); &#125; vector&lt;int&gt; maxSlidingwindow(vector&lt;int&gt;&amp; nums, int k) &#123; Myqueue que; vector&lt;int&gt; result; for (int i = 0; i &lt; k; i++) &#123; que.push(nums[i]); &#125; result.push_back(que.front()); for (int i = k; i &lt; nums.size(); i++) &#123; que.pop(nums[i - k]); que.push(nums[i]); result.push_back(que.front()); &#125; return result; &#125;&#125;; class priqueue &#123;//前k个高频元素（优先级队列）public: // 小顶堆 class mycomparison &#123; public: bool operator()(const pair&lt;int, int&gt;&amp; lhs, const pair&lt;int, int&gt;&amp; rhs) &#123; return lhs.second &gt; rhs.second; &#125; &#125;; vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123; // 要统计元素出现频率 unordered_map&lt;int, int&gt; map; // map&lt;nums[i],对应出现的次数&gt; for (int i = 0; i &lt; nums.size(); i++) &#123; map[nums[i]]++; &#125; // 对频率排序 // 定义一个小顶堆，大小为k priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, mycomparison&gt; pri_que; // 用固定大小为k的小顶堆，扫面所有频率的数值 for (unordered_map&lt;int, int&gt;::iterator it = map.begin(); it != map.end(); it++) &#123; pri_que.push(*it); if (pri_que.size() &gt; k) &#123; // 如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k pri_que.pop(); &#125; &#125; // 找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒序来输出到数组 vector&lt;int&gt; result(k); for (int i = k - 1; i &gt;= 0; i--) &#123; result[i] = pri_que.top().first; pri_que.pop(); &#125; return result; &#125;&#125;; 函数列举滑动窗口最大值12345678910111213141516171819202122232425262728293031323334class Myqueue &#123; //实现单调队列（从大到小）滑动窗口最大值public: deque&lt;int&gt; que; //弹出前检查是否为空且弹出元素是否为front元素 void pop(int value) &#123; if (!que.empty() &amp;&amp; value == que.front()) &#123; que.pop_front(); 7h77777777777777777777777777 &#125; void push(int value) &#123; while (!que.empty() &amp;&amp; value &gt; que.back()) &#123; que.pop_back(); &#125; que.push_back(value); &#125; int front() &#123; return que.front(); &#125; vector&lt;int&gt; maxSlidingwindow(vector&lt;int&gt;&amp; nums, int k) &#123; Myqueue que; vector&lt;int&gt; result; for (int i = 0; i &lt; k; i++) &#123; que.push(nums[i]); &#125; result.push_back(que.front()); for (int i = k; i &lt; nums.size(); i++) &#123; que.pop(nums[i - k]); que.push(nums[i]); result.push_back(que.front()); &#125; return result; &#125;&#125;; 前k个高频元素（优先级队列）123456789101112131415161718192021222324252627282930313233343536373839class priqueue &#123;public: // 小顶堆 class mycomparison &#123; public: bool operator()(const pair&lt;int, int&gt;&amp; lhs, const pair&lt;int, int&gt;&amp; rhs) &#123; return lhs.second &gt; rhs.second; &#125; &#125;; vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123; // 要统计元素出现频率 unordered_map&lt;int, int&gt; map; // map&lt;nums[i],对应出现的次数&gt; for (int i = 0; i &lt; nums.size(); i++) &#123; map[nums[i]]++; &#125; // 对频率排序 // 定义一个小顶堆，大小为k priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, mycomparison&gt; pri_que; // 用固定大小为k的小顶堆，扫面所有频率的数值 for (unordered_map&lt;int, int&gt;::iterator it = map.begin(); it != map.end(); it++) &#123; pri_que.push(*it); if (pri_que.size() &gt; k) &#123; // 如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k pri_que.pop(); &#125; &#125; // 找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒序来输出到数组 vector&lt;int&gt; result(k); for (int i = k - 1; i &gt;= 0; i--) &#123; result[i] = pri_que.top().first; pri_que.pop(); &#125; return result; &#125;&#125;; 树任务点 二叉树 二叉搜索树 avl树 红黑树 二叉搜索树、avl树、红黑树csdn树的定义和基本术语 树的定义：n（n≥0）个结点的有限集。在任一棵非空树中： 有且仅有一个特定称为根的结点 n>1时,其余结点可分为m(m>0)个互不相交的有限集T1,T2,…,Tm，Ti称为树的子树。 树的性质： 递归性 层次性 树的基本术语： 树的结点：数据元素及若干指向其子树的分支 结点的度：结点拥有的子树的个数 树的度：树中所以结点的度的最大值 叶子结点（终端结点）：树中所以结点的度的最大值 分支结点（非终端结点）：度大于0的结点 孩子：结点的子树的根 双亲：B是A的孩子，则A是B的双亲 兄弟：同一双亲的孩子互称兄弟 堂兄弟：双亲在同一层的结点 祖先：从根到该节点所经分支上的所有结点 子孙：以某结点为根的子树中的任一结点都是该结点的子孙 结点的层次：从根结点算起，根为第一层，它的孩子为第二层... 树的深度：树中结点的最大层次树数 路径的长：从结点n1到nk的路径的长为路径上的边的条数 深度：对任意结点ni,ni的深度为从根到ni的唯一路径的长 高：从ni到一片树叶的最长路径的长 有序树：树中结点的各子树从左到右有次序（不能互换） 无序树：树中结点的各子树从左到右无次序（能互换） 森林：m(m>=0)棵互不相交的树的集合 ​ 二叉树的性质 在二叉树的第i层上至多有2^(i-1)^个结点 深度为K的二叉树至多有2^K^-1个结点 任意一棵二叉树，终端结点数为n0,度为2的结点数为n2,则n0=n2+1 任意一课树，结点总数N，分支总数B，则N=B+1=n0+n1+n2.... 有n个结点的完全二叉树的深度为[log~2~^n^]+1(下取整) 按层序遍历二叉树有 若i=1，无双亲；若i>1，其双亲是[i/2](下取整) 若2i>n,为叶子结点；否则，其左孩子为2i 若2i+1>n,无右孩子；否则，其右孩子为2i+1 二叉树的种类满二叉树满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。 完全二叉树在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^(h-1)^ 个节点。优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。 二叉搜索树二叉搜索树是一个有序树。 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树 平衡二叉搜索树平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树 二叉树算法二叉树结点实现（存储结构）顺序存储123#define MAX_TREE_SIZE 100typedef TElemType SqBTree[MAX_TREE_SIZE];SqBTree bt; 缺点：浪费空间，始于满&#x2F;完全二叉树（要把空结点也表示出来） 链式存储二叉 含有n个结点的二叉链表有n+1个空链域 c 1234typedef struct BiTNode&#123; ElemType val; struct BiTNode *lchild,*rchild;&#125;BiTNode,*BiTree; c++ 123456struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#125;; java 123456789101112public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode() &#123;&#125; TreeNode(int val) &#123; this.val = val; &#125; TreeNode(int val, TreeNode left, TreeNode right) &#123; this.val = val; this.left = left; this.right = right; &#125;&#125; 三叉 c 1234typedef struct ThiTNode&#123; TElemType val; struct ThiTNode *lchild,*rchild,*parent;&#125;ThiTNode,*ThiTree; 遍历二叉树遍历方式 二叉树主要有两种遍历方式： 深度优先遍历：先往深走，遇到叶子节点再往回走。 广度优先遍历：一层一层的去遍历。 深度优先遍历 前序遍历（递归法，迭代法） 中序遍历（递归法，迭代法） 后序遍历（递归法，迭代法） 广度优先遍历 层次遍历（迭代法） 前中后指中间结点的遍历顺序 前序遍历：中左右 中序遍历：左中右 后序遍历：左右中 实例 算法实现递归遍历 确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。 确定终止条件： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。 确定单层递归的逻辑： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。 c++ 123456789101112131415161718192021void PreTravesal(TreeNode* cur,vector&lt;int&gt;&amp; result)&#123; if(cur==NULL) return;//终止条件 result.push(cur-&gt;val); PreTravesal(cur-&gt;lchild,result);//左孩子 PreTravesal(cur-&gt;rchild,result);//右孩子&#125;void InTravesal(TreeNode* cur,vector&lt;int&gt;&amp; result)&#123; if(cur==NULL) return;//终止条件 PreTravesal(cur-&gt;lchild,result);//左孩子 result.push(cur-&gt;val); PreTravesal(cur-&gt;rchild,result);//右孩子&#125;void PostTravesal(TreeNode* cur,vector&lt;int&gt;&amp; result)&#123; if(cur==NULL) return;//终止条件 PreTravesal(cur-&gt;lchild,result);//左孩子 PreTravesal(cur-&gt;rchild,result);//右孩子 result.push(cur-&gt;val);&#125; c 12345678910111213141516171819202122232425262728293031323334353637383940Status PreTraversal(BiTree T,Status(* Visit)(TElemType e)) &#123; if (T) &#123; if (Visit(T-&gt;data)) if (PreTraversal(T-&gt;lchild, Visit)) if (PreTraversal(T-&gt;rchild, Visit)) return OK; return ERROR;//防止Visit()返回0 &#125; else &#123; return OK; &#125; return OK;&#125;Status InTraversal(BiTree T, Status(*Visit)(TElemType e)) &#123; if (T) &#123; if (InTraversal(T-&gt;lchild, Visit)) if (Visit(T-&gt;data)) if (InTraversal(T-&gt;rchild, Visit)) return OK; return ERROR;//防止Visit()返回0 &#125; else &#123; return OK; &#125; return OK;&#125;Status PostTraversal(BiTree T, Status(*Visit)(TElemType e)) &#123; if (T) &#123; if (PostTraversal(T-&gt;lchild, Visit)) if (PostTraversal(T-&gt;rchild, Visit)) if (Visit(T-&gt;data)) return OK; return ERROR;//防止Visit()返回0 &#125; else &#123; return OK; &#125; return OK;&#125; 迭代遍历 迭代遍历（非统一） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; stack&lt;TreeNode*&gt; st; vector&lt;int&gt; result; if (root == NULL) return result; st.push(root); while (!st.empty()) &#123; TreeNode* node = st.top(); // 中 st.pop(); result.push_back(node-&gt;val); if (node-&gt;right) st.push(node-&gt;right); // 右（空节点不入栈） if (node-&gt;left) st.push(node-&gt;left); // 左（空节点不入栈） &#125; return result; &#125; vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; result; stack&lt;TreeNode*&gt; st; TreeNode* cur = root; while (cur != NULL || !st.empty()) &#123; if (cur != NULL) &#123; // 指针来访问节点，访问到最底层 st.push(cur); // 将访问的节点放进栈 cur = cur-&gt;left; // 左 &#125; else &#123; cur = st.top(); // 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据） st.pop(); result.push_back(cur-&gt;val); // 中 cur = cur-&gt;right; // 右 &#125; &#125; return result; &#125; vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; stack&lt;TreeNode*&gt; st; vector&lt;int&gt; result; if (root == NULL) return result; st.push(root); while (!st.empty()) &#123; TreeNode* node = st.top(); st.pop(); result.push_back(node-&gt;val); if (node-&gt;left) st.push(node-&gt;left); // 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈） if (node-&gt;right) st.push(node-&gt;right); // 空节点不入栈 &#125; reverse(result.begin(), result.end()); // 将结果反转之后就是左右中的顺序了 return result; &#125; 迭代遍历（统一） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970vector&lt;int&gt; preorderTraversalT(TreeNode* root) &#123; vector&lt;int&gt; result; stack&lt;TreeNode*&gt; st; if (root != NULL) st.push(root); while (!st.empty()) &#123; TreeNode* node = st.top(); if (node != NULL) &#123; st.pop(); if (node-&gt;right) st.push(node-&gt;right); // 右 if (node-&gt;left) st.push(node-&gt;left); // 左 st.push(node); // 中 st.push(NULL); &#125; else &#123; st.pop(); node = st.top(); st.pop(); result.push_back(node-&gt;val); &#125; &#125; return result; &#125; vector&lt;int&gt; inorderTraversalT(TreeNode* root) &#123; vector&lt;int&gt; result; stack&lt;TreeNode*&gt; st; if (root != NULL) st.push(root); while (!st.empty()) &#123; TreeNode* node = st.top(); if (node != NULL) &#123; st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中 if (node-&gt;right) st.push(node-&gt;right); // 添加右节点（空节点不入栈） st.push(node); // 添加中节点 st.push(NULL); // 中节点访问过，但是还没有处理，加入空节点做为标记。 if (node-&gt;left) st.push(node-&gt;left); // 添加左节点（空节点不入栈） &#125; else &#123; // 只有遇到空节点的时候，才将下一个节点放进结果集 st.pop(); // 将空节点弹出 node = st.top(); // 重新取出栈中元素 st.pop(); result.push_back(node-&gt;val); // 加入到结果集 &#125; &#125; return result; &#125; vector&lt;int&gt; postorderTraversalT(TreeNode* root) &#123; vector&lt;int&gt; result; stack&lt;TreeNode*&gt; st; if (root != NULL) st.push(root); while (!st.empty()) &#123; TreeNode* node = st.top(); if (node != NULL) &#123; st.pop(); st.push(node); // 中 st.push(NULL); if (node-&gt;right) st.push(node-&gt;right); // 右 if (node-&gt;left) st.push(node-&gt;left); // 左 &#125; else &#123; st.pop(); node = st.top(); st.pop(); result.push_back(node-&gt;val); &#125; &#125; return result; &#125; 层序遍历12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; queue&lt;TreeNode*&gt; que; if (root != NULL) que.push(root); vector&lt;vector&lt;int&gt;&gt; result; while (!que.empty()) &#123; int size = que.size(); vector&lt;int&gt; vec; // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的 for (int i = 0; i &lt; size; i++) &#123; TreeNode* node = que.front(); que.pop(); vec.push_back(node-&gt;val); if (node-&gt;left) que.push(node-&gt;left); if (node-&gt;right) que.push(node-&gt;right); &#125; result.push_back(vec); &#125; return result; &#125;&#125;;# 递归法class Solution &#123;public: void order(TreeNode* cur, vector&lt;vector&lt;int&gt;&gt;&amp; result, int depth) &#123; if (cur == nullptr) return; if (result.size() == depth) result.push_back(vector&lt;int&gt;()); result[depth].push_back(cur-&gt;val); order(cur-&gt;left, result, depth + 1); order(cur-&gt;right, result, depth + 1); &#125; vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; result; int depth = 0; order(root, result, depth); return result; &#125;&#125;; 创建二叉树12345678910111213//先序Status PreCreateBiTree(BiTree &amp;T)&#123; char ch; scanf(&quot;%c&quot;,&amp;ch); if(ch==&#x27;&#x27;)T=NULL; else&#123; if(!(T=(BiTnode*)malloc(sizeof(TNode)))) exit(OVERFLOW); T-&gt;data=ch;//中 PreCreateBiTree(T-&gt;lchild);//左 PreCreateBiTree(T-&gt;rchild);//右 &#125; return OK;&#125; 翻转二叉树123456789101112void invertTree(TreeNode* root)&#123; if(root==NULL) return; swap(root-&gt;lchild,root-&gt;rchild); invertTree(root-&gt;lchild); invertTree(root-&gt;rchild);&#125;void swap(TreeNode* lchild,TreeNode* rchild)&#123; TreeNode* temp; temp=lchild; lchild=rchild; rchild=temp;&#125; 对称二叉树1234567891011121314151617181920bool compare(TreeNode* L,TreeNode* R)&#123; //都空 if(L==NULL&amp;&amp;R==NULL) return true; //左空右不空 else if(L==NULL&amp;&amp;R!=NULL) return false; //右空左不空 else if(R==NULL&amp;&amp;L!=NULL) return false; //左右不空且不等 else if(L!=R) return false; //接下来就是左右都有值且相等 bool l=compare(L-&gt;lchild,R-&gt;rchild);//左子树：左 ；右子树：右 bool r=compare(L-&gt;rchild,R-&gt;lchild);//左子树：右 ；右子树：左 bool isSame=l&amp;&amp;r; //中 return isSame；&#125;bool isduic(TreeNode* root)&#123; if(root==NULL) return true; return compare(root-&gt;lchild,root-&gt;rchild);&#125; 统计叶子结点个数1234567Status CountLeaf(BiTree T,int&amp; count)&#123; if(T)&#123; if((T-&gt;lchild==NULL)&amp;&amp;(T-&gt;rchild==NULL))&#123;count++;return OK;&#125; CountLeaf(T-&gt;lchild,count); //访问左 CountLeaf(T-&gt;rchild,count); //访问右 &#125;else return ERROR;&#125; 求二叉树的深度1234567891011int Depth(BiTree T)&#123; int d=0,dl=0,dr=0; if(!T) d=0; else&#123; dl=Depth(T-&gt;lchild); dr=Depth(T-&gt;rchild); d=1+max(dl,dr); &#125; return d;&#125; 求二叉树的最小深度12345678910111213141516int getDepth(TreeNode* node) &#123; if (node == NULL) return 0; int leftDepth = getDepth(node-&gt;left); // 左 int rightDepth = getDepth(node-&gt;right); // 右 // 中 // 当一个左子树为空，右不为空，这时并不是最低点 if (node-&gt;left == NULL &amp;&amp; node-&gt;right != NULL) &#123; return 1 + rightDepth; &#125; // 当一个右子树为空，左不为空，这时并不是最低点 if (node-&gt;left != NULL &amp;&amp; node-&gt;right == NULL) &#123; return 1 + leftDepth; &#125; int result = 1 + min(leftDepth, rightDepth); return result;&#125; 求完全二叉树结点个数普通二叉树逻辑，按后序遍历 12345678910int getNodesNum(TreeNode* T)&#123; int n,ln,rn; if(!T) return 0; else&#123; ln=getNodesNum(T-&gt;lchild); rn=getNodesNum(T-&gt;rchild); n=ln+rn+1; return n; &#125;&#125; 12345678int getNodesNum(TreeNode* T,int &amp;count)&#123; if(T)&#123; count++; getNodesNum(T-&gt;lchild,count); getNodesNum(R-&gt;lchild,count); &#125;&#125; 完全二叉树逻辑，求每个子树的满二叉树 123456789101112131415161718int getNodesNum(TreeNode*T)&#123; if(!T)return 0; int ldeep=0,rdeep=0; TreeNode* lt=T-&gt;lchild; TreeNode* rt=T-&gt;rchild; while(lt)&#123; lt=lt-&gt;lchild; ldeep++; &#125; while(rt)&#123; rt=rt-&gt;rchild; rdeep++; &#125; if(ldeep==rdeep)&#123; return (2&lt;&lt;ldeep)-1; &#125; return getNodesNum(T-&gt;lchild)+getNodesNum(T-&gt;rchild)+1;&#125; 判断平衡二叉树123456789101112int getHeight(TreeNode* T)&#123; if(!T)return 0; int leftHeight=getHeight(T-&gt;lchild); if(leftHeight==-1)return -1; int rightHeight=getHeight(T-&gt;rchild); if(rightHeight==-1)return -1; return abs(leftHeight-rightHeight)&gt;1?-1: 1+max(leftHeight,rightHeight);&#125;Boolean ifph(TreeNode* T)&#123; return getHeight(T)==-1?false : true;&#125; 求根节点到叶子节点的所有路径1234567891011121314151617181920212223242526272829303132class Solution&#123; private: void traversal(TreeNode* T,vector&lt;int&gt;&amp; path,vector&lt;string&gt;&amp; result)&#123; path.push_back(T-&gt;val); if(T-&gt;lchild==NULL&amp;&amp;T-&gt;rchild==NULL)&#123; string spath; for(int i=0;i&lt;path.size()-1;i++)&#123; spath=path[i].toString(); spath+=&quot;-&gt;&quot;; &#125; spath+=path[path.szie()-1]; reslut.push_back(spath); return; &#125; if(T-&gt;lchild)&#123; Traversal(T-&gt;lchild,path,reslut); path.pop_back(); &#125; if(T-&gt;rchild)&#123; Traversal(T-&gt;rchild,path,reslut); path.pop_back(); &#125; &#125; public: vector&lt;string&gt; binaryTreePaths(TreeNode* T)&#123; vector&lt;string&gt; result; vector&lt;int&gt; path; if(T==NULL)return result; traversal(T,path,result); return result; &#125;&#125; 左叶子之和123456789101112131415161718192021222324252627282930313233class Solution&#123; int leftCount(TreeNod *T)&#123; if(!T)return 0; int left=0; if(T-&gt;left&amp;&amp;!T-&gt;left-&gt;left&amp;&amp;!T-&gt;right-&gt;right)&#123;//是左叶子 int left= T-&gt;left-&gt;val; &#125;else if(T-&gt;left)&#123; int left= leftCount(T-&gt;left); &#125; int right= leftCount(T-&gt;right); return left+right; &#125;&#125;class Solution &#123;public: int sumOfLeftLeaves(TreeNode* root) &#123; if (root == NULL) return 0; if (root-&gt;left == NULL &amp;&amp; root-&gt;right== NULL) return 0; int leftValue = sumOfLeftLeaves(root-&gt;left); // 左 if (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) &#123; // 左子树就是一个左叶子的情况 leftValue = root-&gt;left-&gt;val; &#125; int rightValue = sumOfLeftLeaves(root-&gt;right); // 右 int sum = leftValue + rightValue; // 中 return sum; &#125;&#125;; 求树最左边的值递归法 1234567891011121314151617181920212223242526class Solution&#123; public: int maxDepth=INT_MIN; int result; void travesal(TreeNode* T,int depth)&#123; if(T-&gt;left==NULL&amp;&amp;T-&gt;right==NULL)&#123; if(depth&gt;maxDepth)&#123; result=T-&gt;val; maxDepth=depth; &#125; return; &#125; if(T-&gt;left)&#123; travesal(T-&gt;left,depth+1);//隐藏回溯 &#125; if(T-&gt;left)&#123; travesal(T-&gt;left,depth+1);//隐藏回溯 &#125; return; &#125; int findBottomLeftValue(TreeNode* T)&#123; travesal(T,0); return result; &#125;&#125; 迭代层序遍历 12345678910111213141516171819class Solution&#123; public: int findBottomLeftValue(TreeNode* T)&#123; queue&lt;TreeNode*&gt;que; for(roo!=NULL)que.push(T); int reuslt=0; while(!qy=ue.empty())&#123; int size=que,size(); for(int i=0;i&gt;size;i++)&#123; TreeNode* node=que.front(); que.pop(); if(i==0)result=node-&gt;val; if(node-&gt;left)que.push(node-&gt;left); if(node-&gt;right)que.push(node-&gt;right); &#125; &#125; return result; &#125;&#125; AVL树AVL定义AVL树是带有平衡条件的二叉查找树，即每一个结点的左右子树的高度最多差1的二叉查找树（空树高定义为-1） AVL具体算法结点声明12345678struct AvlNode&#123; ElemType element; AvlNode *left; AvlNode *right; int height; AvlNode(const ElemType &amp;element,AvlNode *lt,AvlNode *rt,int h=0):element(element),left(lt),right(rt),height(h)&#125;; 返回结点高度1234int height(AvlNode *t)const&#123; return t==NULL ? -1:t-&gt;height;&#125; 单旋转123void rotateWithLeftChild(AvlNode *k2)&#123; &#125; 图图的定义和术语图G是由一个顶点集V和一个边集E构成的数据结构。 记为二元组形式： G= (V, E) 其中: V是由顶点构成的非空有限集合， 记为：V＝&#123;V0, V1, V2, …Vn-1&#125; E是由V中顶点的对偶构成的有限集合， 记为：E=&#123;(V0, V2), (V3, V4), … &#125;，若E为空，则图中只有顶 点而没有边。 有向图 弧、弧尾或初始点、弧头或终端点 无向图的定义和术语 子图: G =(V, E)，G’= (V’, E’)，若V’ V，E’ E，G’是G的子图 邻接点: 如果边(v, v’)∈E，v和v’互为邻接点 依附（相关联): 边(v，v’)依附于顶点v和v’。 顶点v的度: 和v相关联的边的数目。记为TD(v) 有向图的定义和术语 邻接到：弧&lt;v,v’&gt; ∈E，称v邻接到v’，v’邻接自v 顶点v的入度：以顶点v为头的弧的数目，记为ID（v） 顶点v的出度：以顶点v为尾的弧的数目，记为OD（v） 顶点v的度：TD(v)= ID(v)+ OD(v) 一个有n个顶点和e条边或弧的图，满足：e=sum(TD(v))/2 路径、回路和路径长度 在无向图G中，若存在一个顶点序列(Vp , Vi1 , Vi2 , … , Vin , Vq)， 使(Vp, Vi1)，(Vi1, Vi2)，…，(Vin, Vq)均为图G的边，则该称顶点 的序列为顶点Vp到顶点Vq的路径。若G是有向图，则路径是有向 的。 路径长度定义为路径上的边数或者弧的数目。 若一条路径中不出现重复顶点，则称此路径为简单路径。 若一条路径的起点和终点相同（Vp=Vq）称为回路或环。 除了起点和终点相同外，其余顶点不相同的回路，称为简单回 路或简单环。 无向图的连通性 连通：顶点v至v’ 之间有路径存在。 连通图：无向图 G 的任意两点之间都连通。 连通分量：无向图的极大连通子图。 有向图的连通性 连通：顶点v至v’ 之间有路径存在。 强连通图：有向图G的任意两点之间都连通。 强连通分量：有向图的极大连通子图。 无向图的生成树 无向图生成树：图的极小连通子图。包含图的n个结点和n-1条边 1、一棵有n个顶点的生成树有且仅有n-1条边 2、一个无向图有n个顶点和小于n-1条边，是非连通图 3、一个无向图有多于n-1条边，必有环 有向图的生成森林 有向树：如果一个有向图恰有一个顶点入度为0，其余顶点入度 均为1，则是有向树。 有向图的生成森林：由若干有向树组成，含有图中全部顶点，但 只有足以构成若干棵不相交的有向树的弧。 完全图 在图G中： 若G为无向图，任意两个顶点之间都有一条边，称G为无向完全图。顶点数为n，无向完全图的边数：e=n(n-1)/2 若G为有向图，任意两个顶点之间都有弧，称G为有向完全图。顶点数为n，有向完全图的弧数：e=n(n-1) 稀疏图(sparse graph)：有很少条边或弧(e&lt;nlog2n)的图。 稠密图(dense graph)：有很多条边或弧(e&gt;nlog2n)的图。 边或弧的权值(weight)：与弧或边相关的数。可以表示从一个顶点到另一个顶点的距离、花费的代价、所需的时间等。 网络(network)：带权的图称之为网络。 ​ 图的存储结构数组(邻接矩阵)表示法12345678910111213#define MAX_VERTEX_NUM 20typedef enum &#123;DG,DN,UDG,UDN&#125; GraphKindtypedef struct ArcCell&#123; int adj;&#125;ArcCell,AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];typedef struct &#123; int vex[MAX_VERTEX_NUM]; AdjMatrix arcs; int vexnum,arcnum; GraphKind kind;&#125; 邻接表12345678910111213141516#define MAX_VERTEX_NUM 20typedef int infoType;typedef struct ArcNode&#123; int adjvex; //邻接下标,当前表结点 struct ArcNode *nextrac;//下一邻接结点 infoType info;//边权值&#125;ArcNode;typedef struct VNode&#123;ArcNode *firstarc;int data;//有关信息&#125;VNode,AdjList[MAX_VERTEX_NUM];typedef struct &#123; AdjList vertices;//头结点数组 int vexnum,arcnum; int kind;&#125;ALGraph; 构造无向图UDG(邻接矩阵)12345678910111213141516void creatUDG(MGraph &amp;G)&#123; int a,b; int i,j; scanf(&quot;%d,%d&quot;,&amp;G.vexnum,&amp;G.arcnum);//读入顶点、边数 for(int i=0;i&lt;G.vexnum;i++&gt;)scanf(&quot;%d&quot;,&amp;G.vex[i]);//构造顶点数组 for(int i=0;i&lt;G.vexnum;i++) for(int j=0;j&lt;G.vexnum;i++&gt;) G.vertices[i][j]=&#123;0,NULL&#125;; for(int k=0;k&lt;G.arcnum;k++)&#123; scanf(&quot;%d,%d&quot;,&amp;a,&amp;b); i=LocateVex(G,a); j=LocateVex(G,b); G.arcs[i][j].adj=1; G.arcs[i][j].adj=G.arcs[j][i]; &#125;&#125; 构造无向图UDG(邻接表)12345678910111213141516void creatNG(ALGraph &amp;G)&#123;scanf(&quot;%d,%d&quot;,&amp;G.vexnum,&amp;G.arcnum);//读入顶点、边数for(int i=0;i&lt;G.vexnum;i++)&#123;//读入顶点值 scanf(&quot;%d&quot;,&amp;G.vertices[i].data); G.vertices[i].firstarc=NULL;&#125;for(i=0;i&lt;G.arcnum;i++)&#123; int a,b; scanf(&quot;%d,%d&quot;,&amp;a,&amp;b); p=(ArcNode*)malloc(sizeof(ArcNode)); q=(ArcNode*)malloc(sizeof(ArcNode)); p-&gt;adjvex=a;q-&gt;adjvex=b; p-&gt;nextarc=G.vertices[b].firstrac;G.vertices[b].firstrac=p;//&lt;b,a&gt; q-&gt;nextarc=G.vertices[a].firstrac;G.vertices[a].firstrac=q;//&lt;a,b&gt;&#125;&#125; 遍历深度优先遍历时间复杂度分析当用邻接表时，时间复杂度O(n+e),遍历所有顶点O(n),查找所有顶点的邻接点O(e)当用邻接矩阵时，时间复杂度O(nn),遍历所有顶点O(n),查找一个顶点的邻接点O(n),查找所有顶点的邻接点O(nn) 深度优先搜索(递归)123456789101112131415161718192021222324252627282930313233343536373839404142434445Boolean visited[MAX];//是否已被访问Status(*VisitFunc)(int v); void DFSTraverse(Graph G,Status(*Visit)(int v))&#123; VisitFunc=Visit; for(int v=0;v&lt;G.vexnum;++v) visited[v]=FLASE; for(int v=0;v&lt;G.vexnum;++v) if(!visited[v])DFS(G,v);&#125;void DFS()&#123; visited[v]=TRUE;VisitFunc(v); for(w=FirstAdjVex(G,v);w;w=NextAdjVex(G,v,w)) if(!visited[w])DFS(G,w);&#125;Boolean visited[MAX];Status (*VisitFunc)(int v);void DFSTraverse(Graph G,Status(*Vistit)(int v))&#123; VisitFunc=Visit; for(int i=0;i&lt;G.vexnum;i++)visited[i]=false; for(int i=0;i&lt;G.vexnum;i++)&#123; if(!visited[i])GFS(G,v); &#125;&#125;void GFS(Graph G,int v)&#123; visited[v]=true; VisitedFunc(v);//访问 for(int w=FirstAdjVex(G,v);w;w=NextAdjVex(G,v,w))&#123; if(!visited[w])GFS(G,v); &#125;&#125;int FirstAdjVex(Graph G,int v)&#123; return G.vertices[v].firstarc-&gt;adjvex;&#125;int NextAdjVex(Graph G,int v,int w)&#123; p=(ArcNode*)malloc(sizeof(ArcNode)); p=G.vertices[v].firstarc; while(p-&gt;adjvex!=w)&#123; p=p-&gt;nextarc; &#125; return p-&gt;nextarc-&gt;adjvex;&#125; 深度优先遍历（非递归）1234567891011121314151617181920212223242526272829303132333435363738394041424344Boolean visited[MAX];void GFS(Graph p,Status(*Visit)(int v))&#123; for(int i=0;i&lt;G.vexnum;i++)visited[i]=false; int p=0; cur=(ArcNode*)malloc(sizeof(ArcNode)); cur=G.vertices[0].firstarc; Stack&lt;int&gt; s; Visit(p); visited[p]=true; s.push(p); while(!s.empty())&#123; for(p=cur-&gt;adjvex;visited[p]&amp;&amp;cur!=null;cur=cur-&gt;nextarc,p=cur-&gt;adjvex)&#123;&#125; if(cur==NULL)&#123; s.pop(); cur=G.vertices[s.top()].firstarc; continue; &#125; Visit(p); visited[p]=true; s.push(p); cur=G.vertices[p].firsttarc; &#125; &#125;void DFStraverse(Graph G,Status(*Visit)(int v))&#123;for(int v=0;v&lt;G.vexnum;v++)visited[v]=false;stack&lt;int&gt; s;int u,w;for(v=0;v&lt;G.vexnum;v++)&#123; if(!visited[v])&#123; Visit(v);visited[v]=true;s.push(v); while(!s.empty())&#123; for(w=FirstAdjVex(G,u);w;w=NextAdjVex(G,u,w))&#123; if(!visited[u])&#123; Visit(v);visited[v]=true;s.push(v); break; &#125; &#125; if(!w)&#123;s.pop();&#125; &#125; &#125;&#125;&#125; 广度优先时间复杂度分析图的遍历本质上都是对每个顶点查找邻接点的过程，所以时间复杂度同深度遍历 广度优先遍历123456789101112131415161718void BFStraverse(Graph G,Status(*Visit)(int v))&#123;for(int v=0;v&lt;G.vexnum;v++)visited[v]=false;InitQueue(Q);int u,w;for(v=0;v&lt;G.vexnum;v++)&#123; if(!visited[v])&#123; Visit(v);visited[v]=true;EnQueue(Q,v); while(!QueueEmpty(Q))&#123; DeQueue(Q,u); for(w=FirstAdjVex(G,u);w;w=NextAdjVex(G,u,w))&#123; if(!visited[u])&#123; Visit(v);visited[v]=true;EnQueue(Q,v); &#125; &#125; &#125; &#125;&#125;&#125; 求无向图连通分支数量123456789int count(Graph G)&#123;for(int i=0;i&lt;G.vexnum;i++)&#123; if(visited[i]==0)&#123; k++; DFS(G,visit); &#125;&#125;return k;&#125; 最小生成树Prim算法12345678910111213141516171819202122struct&#123; vertexType adjvex;//顶点下标 int lowcost;//最小权值&#125;closedge[MAXA];void MiniSpanTree(MGrap G,VexType u)&#123; int k=LocateVex(u); for(int i=0;i&lt;vexnum;i++)&#123; if(i!=k) closedge[i]=&#123;k,G.arcs[k][i].adj&#125;; &#125; closege[k].lowcost=0;//以0判断是否纳入 for(int i=1;i&lt;vexnum;i++)&#123; k=Mini(closedge);//找到与以纳入顶点的最路径 printf(&quot;%c-&gt;%c&quot;,closedge[k].adjvex,G.vex[k])//输出一条边 closedge[k].lowcost=0;//纳入 for(int j=0;j&lt;vexnum;j++)&#123;//更新closedge if(G.arcs[k][j].adj&lt;closedge[j].lowcost) closedge[j]=&#123;G.vex[k],G.arcs[k][j].adj&#125;; &#125; &#125;&#125; kruscal算法12345678910111213141516171819202122232425262728293031void kruskal(Edge E[],int n,int e)&#123; int i,j,m1,m2,sn1,sn2,k,sum=0; int vset[n+1]; for(i=1;i&lt;=n;i++) //初始化辅助数组 vset[i]=i; k=1;//表示当前构造最小生成树的第k条边，初值为1 j=0;//E(边集)中边的下标，初值为0 while(k&lt;e)//生成的边数小于e时继续循环 &#123; m1=E[j].vex1; m2=E[j].vex2;//取一条边的两个邻接点 sn1=vset[m1]; sn2=vset[m2]; //分别得到两个顶点所属的集合编号 if(sn1!=sn2)//两顶点分属于不同的集合，该边是最小生成树的一条边 &#123;//防止出现闭合回路 printf(&quot;V%d-V%d=%d\\n&quot;,m1,m2,E[j].weight); sum+=E[j].weight; k++; //生成边数增加 if(k&gt;=n) break; for(i=1;i&lt;=n;i++) //两个集合统一编号 if (vset[i]==sn2) //集合编号为sn2的改为sn1 vset[i]=sn1; &#125; j++;//扫描下一条边 &#125; printf(&quot;最小权值之和=%d\\n&quot;,sum);&#125; AOV 网络和拓扑排序定义偏序：若集合 X 上的关系R是传递的、自反的、反对称的，则称R是集合X上的偏序关系。指集合中部分成员之间可比较。 全序：若关系R 是集合 X 上的偏序关系，如果对于每个x,y属于X，必有xRy 或yRx ，则称R是集合X上的全序关系。指集合中全部成员之间可比较。 拓扑排序：由一个集合上的一个偏序得到该集合上的一个全序的操作。这个全序被称为拓扑有序。 AOV(Activity On Vertices)网：有向图表示工程，顶点表示活动，有向边&lt;vi,vj&gt;表示活动vi必须先于活动vj进行,其中vi是vj的直接前驱，vj是vi的直接后继。若从顶点vi到vk有一条路径，则vi是vk的前驱、vk是vi的后继。 在AOV网中，不应该出现有向环。 AOV网中检测环的办法：对有向图构造其顶点的拓扑排序序列，若网中所有顶点都在它的拓扑有序序列中，则不存在环。（对一个无向图来说，可以用深度优先遍历，若遇到回边，则必定存在环） 算法实现1234567891011121314151617181920Status TopologicalSort(ALGraph G)&#123; int Indegree[MAX]; stack&lt;int&gt; S; FindeIndegree(G,Indegree);//计算各结点的入度 for(int i=0,i&lt;G.vexnum;i++)&#123; if(!Indegree[i])push(S,i); &#125; int count=0; p=(ArcNode*)malloc(sizeof(ArcNode)); while(!empty(S))&#123; pop(S,k);printf(&quot;%d&quot;,G.vertices[k].adjvex);count++; for(p=G.vertices[k].firstarc;p;p=p-&gt;nextarc)&#123; int q=p-&gt;adjvex; if(!(--Indegree[q]))push(S,q); &#125; &#125; if(count&lt;G,vexnum)return ERROR; return OK;&#125; AOV-网 关键路径AOE-网(Active On Edge)：在带权的有向无环图中，顶点表示事件，弧表示工程的一个活动，弧上权值表示活动持续的时间。用来估算工程完成时间。 源点：入度为0的顶点。汇点：出度为0的顶点。路径长度：AOE网中路径上各活动持续时间之和。关键路径：路径长度最长的路径。 设活动ai在有向无环图G的有向边&lt;j,k&gt;上： 事件vj的最早发生时间ve(j):从源点v0到vj的最长路径长度。ve(0)&#x3D;0;ve(j)&#x3D;从源点到顶点j的最长的路径长度。ve(k)&#x3D;Max{ve(j)+dut(&lt;j,k&gt;)} 事件vj的最迟开始时间vl(j)：保证汇点vn-1在ve(n-1)时刻完成的前提下，事件vj最迟允许开始的时间。vl(n-1) &#x3D; ve(n-1)＝从源点到汇点的最长路径长度;vl(k)&#x3D;从汇点到顶点k的最短的路径长度。vl(j)&#x3D;Min{vl(k)-dut(&lt;j,k&gt;)} 设活动ai在有向边&lt;j,k&gt;上,有： 活动ai的最早开始时间e(i)：从源点v0到vj的最长路径长度。e(i)&#x3D; ve(j); 活动ai的最迟开始时间l(i)：是不推迟工程完成的前提下，该活动允许的最迟开始时间。l(i)&#x3D;vl(k)-dut(&lt;j,k&gt;) 活动ai时间余量：l(i)-e(i) 关键活动：满足l(i)&#x3D;e(i)的活动。关键路径上的活动都是关键活动。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 int ve[MAX]; int vl[MAX];Status TopologicalSort(ALGraph G,stack T)&#123; int Indegree[MAX]; stack&lt;int&gt; S; FindeIndegree(G,Indegree);//计算各结点的入度 for(int i=0,i&lt;G.vexnum;i++)&#123; if(!Indegree[i])push(S,i); ve[i]=0; &#125; int count=0; p=(ArcNode*)malloc(sizeof(ArcNode)); while(!empty(S))&#123; pop(S,k);push(T,k);printf(&quot;%d&quot;,G.vertices[k].adjvex);count++; for(p=G.vertices[k].firstarc;p;p=p-&gt;nextarc)&#123; int q=p-&gt;adjvex; if(!(--Indegree[q]))push(S,q); if(ve[k]+*(p-&gt;info)&gt;ve[q])ve[q]=ve[k]+*(p-&gt;info); &#125; &#125; if(count&lt;G,vexnum)return ERROR; return OK;&#125;Status CriticalPath(ALGraph G)&#123; stack&lt;int&gt; T; int i=0; if(!TopologicalSort(Graph G,stack T)) return ERROR;//判断是否有环且求ve for(int i=0,i&lt;G.vexnum;i++)&#123; vl[i]=ve[G.vexnum-1]; &#125; while(!empty(T))&#123;//求vl pop(T,i); for(p=G.vertices[i].firstarc;p;p=p-&gt;nextarc)&#123; int j=p-&gt;adjvex; if(vl[i]&gt;vl[j]-*(p-&gt;info))vl[i]=ve[j]-*(p-&gt;info); &#125; &#125; for(int i=0,i&lt;G.vexnum;i++)&#123;//对每一个弧判断是否是关键路径/活动 for(p=G.vertices[i].firstarc;p;p=p-&gt;nextarc)&#123; int k=p-&gt;adjvex; int e=ve[i]; int l=vl[k]-*(p-&gt;info); if(e==l)printf(&quot;%d;%d;%d&quot;,i,k,*(p-&gt;info)); &#125; &#125;&#125; 最短路径Dijkstra算法用于求源点到其余顶点的最短路径 1234567891011121314151617181920212223242526272829void ShortPath(MGraph G,int v0,PathMatrix &amp;P,ShortPathTable &amp;D)&#123; bool final[MAX]; int v; for(int v=0;v&lt;G.vexnum;v++)&#123; final[v]=false; D[v]=G.arcs[v0][v];//所有顶点初始化 for(int w=0;w&lt;G.vexnum;w++)P[v][w]=false;//初始化P数组 if(D[v]&lt;INFINITY)P[v][v0]=P[v][v]=true;//将与v0有直接路径的顶点更改p &#125; D[v0]=0;fina[v0]=true;P[v0][v0]=true;//处理v0 for(int i=0;i&lt;G.vexnum;i++)&#123;//进行n-1次 min=INFINITY; for(int w=0;w&lt;G.vexnum;w++)&#123; if(!final[w]) if(D[w]&lt;min)&#123;v=w;min=D[w];&#125; &#125; if(min&lt;INFINITY)&#123; final[v]=true; for(int v=0;v&lt;G.vexnum;v++)&#123; if(!final[v]&amp;&amp;(min+G.arcs[w][v])&lt;D[v])&#123; D[v]=min+G.arcs[w][v]; P[v][w]=P[v][w]=true; &#125; &#125; &#125; &#125;&#125; Floyd算法用于求点到点的最短路径 123456789101112131415161718192021222324252627282930313233343536373839#define INFINITY 999void ShortPath(MGraph G,PathMatrix &amp;P[],DistanceMatrix &amp;D)&#123; for(int v=0;v&lt;G.vexnum;v++) for(int w=0;w&lt;G.vexnum;w++)&#123; D[v][w]=G.arcs[v][w]; for(int u=0;u&lt;G.vexnum;u++)P[v][w][u]=0; if(D[v][w]&lt;INFINITY)P[v][w][v]=P[v][w][w]=true; &#125; for(int u=0;u&lt;G.vexnum;u++) for(int v=0;v&lt;vexnum;v++) for(int w=0;w&lt;vexnum;w++)&#123; if(D[v][w]&gt;D[v][u]+D[u][w])&#123; D[v][w]=D[v][u]+D[u][w]; for(int i=0;i&lt;G.vexnum;G++)&#123; P[v][w][i]=p[v][u][i]||p[u][w][i]; &#125; &#125; &#125;&#125;#define INFINITY 999void ShortPath(MGraph G,PathMatrix &amp;P[],DistanceMatrix &amp;D)&#123; for(int v=0;v&lt;G.vexnum;v++) for(int w=0;w&lt;G.vexnum;w++)&#123; D[v][w]=G.arcs[v][w];//初始化D for(int u=0;u&lt;G.vexnum;u++)P[v][w][u]=false;//初始化P if(D[v][w]&lt;INFINITY)P=[v][w][v]=P[v][w][w]=true;//有直接路径v-&gt;w &#125; for(int u=0;u&lt;G.vexnum;u++) for(int v=0;v&lt;G.vexnum;v++) for(int w=0;w&lt;G.vexnum;w++)&#123; if(D[v][u]+D[u][w]&lt;D[v][w])&#123; D[v][w]=D[v][u]+D[u][w]; for(int i=0;i&lt;G.vexnum;i++)&#123; P[v][w][i]=P[v][u][i]||P[u][w][i];//把从v-&gt;w的最短路径上经过的点全置为true &#125; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include&lt;stdio.h&gt;#include&lt;cstdlib&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;#define MAX_VERTEX_NUM 20typedef int Status;typedef struct ArcNode &#123; int adjvex; //邻接下标,当前表结点 struct ArcNode* nextarc;//下一邻接结点 int info;//边权值&#125;ArcNode;typedef struct VNode &#123; ArcNode* firstarc; int data;//有关信息&#125;VNode, AdjList[MAX_VERTEX_NUM];typedef struct &#123; AdjList vertices;//头结点数组 int vexnum, arcnum; int kind;&#125;ALGraph;bool visited[MAX_VERTEX_NUM];//创建邻接表图void creatNG(ALGraph&amp; G) &#123; int a, b; ArcNode* p, *q; printf(&quot;input顶点，边数:&quot;); scanf_s(&quot;%d,%d&quot;, &amp;G.vexnum, &amp;G.arcnum);//读入顶点、边数 for (int i = 0; i &lt; G.vexnum; i++) &#123;//读入顶点值 printf(&quot;输入第%d个顶点值:&quot;,i); scanf_s(&quot;%d&quot;,&amp;G.vertices[i].data); ArcNode* p = (ArcNode*)malloc(sizeof(ArcNode)); G.vertices[i].firstarc = p; p-&gt;adjvex = -1; &#125; for (int i = 0; i &lt; G.arcnum; i++) &#123; printf(&quot;输入第i条边:&quot;); scanf_s(&quot;%d,%d&quot;, &amp;a, &amp;b); p = (ArcNode*)malloc(sizeof(ArcNode)); q = (ArcNode*)malloc(sizeof(ArcNode)); p-&gt;adjvex = a; q-&gt;adjvex = b; p-&gt;nextarc = G.vertices[b].firstarc; G.vertices[b].firstarc = p;//&lt;b,a&gt; q-&gt;nextarc = G.vertices[a].firstarc; G.vertices[a].firstarc = q;//&lt;a,b&gt; &#125;&#125;int visit(int v) &#123; printf(&quot;%d &quot;,v); return 0;&#125;int FirstAdjVex(ALGraph G, int v) &#123; return G.vertices[v].firstarc-&gt;adjvex;&#125;int NextAdjVex(ALGraph G, int v, int w) &#123; ArcNode* p; p = (ArcNode*)malloc(sizeof(ArcNode)); p = G.vertices[v].firstarc; while (p-&gt;adjvex != w) &#123; p = p-&gt;nextarc; &#125; return p-&gt;nextarc-&gt;adjvex;&#125;//深度优先void DFStraverse(ALGraph G, Status(*Visit)(int v)) &#123; for (int v = 0; v &lt; G.vexnum; v++)visited[v] = false; stack&lt;int&gt; s; int u, w; for (int v = 0; v &lt; G.vexnum; v++) &#123; if (!visited[v]) &#123; Visit(v); visited[v] = true; s.push(v); while (!s.empty()) &#123; v=s.top(); s.pop(); for (w = FirstAdjVex(G, v); w!=-1; w = NextAdjVex(G, v, w)) &#123; if (!visited[w]) &#123; Visit(w); visited[w] = true; s.push(w); break; &#125; &#125; //if (w!=-1) &#123; s.pop(); &#125; &#125; &#125; &#125;&#125;//广度void BFStraverse(ALGraph G, Status(*Visit)(int v)) &#123; for (int v = 0; v &lt; G.vexnum; v++)visited[v] = false; queue&lt;int&gt; Q; int u, w; for (int v = 0; v &lt; G.vexnum; v++) &#123; if (!visited[v]) &#123; Visit(v); visited[v] = true; Q.push(v); while (!Q.empty()) &#123; u = Q.front(); Q.pop(); for (w = FirstAdjVex(G, u); w != -1; w = NextAdjVex(G, u, w)) &#123; if (!visited[w]) &#123; Visit(w); visited[w] = true; Q.push(w); &#125; &#125; &#125; &#125; &#125;&#125;int main() &#123; ALGraph G; creatNG(G); DFStraverse(G, visit); printf(&quot;\\n&quot;); BFStraverse(G, visit);&#125; 算法查找定义查找表(Search Table) ：由同一类型的数据元素(或记录)构成的集合。 对查找表经常进行的操作: 1）查询某个“特定的”数据元素是否在查找表中； 2）检索某个“特定的”数据元素的各种属性； 3）在查找表中插入一个数据元素； 4）从查找表中删去某个数据元素。 静态查找表(Static Search Table) : 仅作上述1）和2）操作的查找表 动态查找表(Dynamic Search Table):作上述1）、2）、3）、4）操作的查找表 关键字(Key):数据元素中某个数据项的值，用以标识一个数据元素 主关键字(Primary Key):可以唯一标识一个记录的关键字 次关键字(Secondary Key):用以识别若干记录的关键字 平均查找长度 查找算法的性能分析：通常以关键字和给定值进行比较的记录个数的平均值为衡量算法好坏的依据. 平均查找长度(Average Search Length)：查找算法在查找成功时平均查找长度和查找不成功时平均查找长度之和。 查找成功的平均查找长度：为确定记录在查找表中的位 置，需和给定值进行比较的关键字个数的期望值， 令： Pi:查找表中第i个记录的概率 Ci:找到表中其关键字与给定值相等的第i个记录时，和给定值比较过的关键字的个数． ASL(SS)=NUM(PiCi); 查找不成功平均查找长度：查找不成功时和给定值进行比较 的关键字个数的期望值称为查找不成功时平均查找长度。 顺序表的查找代码实现 123456int Search_Seq( SSTable ST, KeyType key ) &#123; ST.elem[0]. key = key;//哨兵 for ( i = ST.length ; ! EQ(ST.elem[i]. key, key ) ; - - i ); return i; &#125; // Search_Seq 性能分析 等概率下查找成功的平均查找长度： $P_{i}&#x3D;\\frac{1}{n}$$C_{i}&#x3D;n-i+1$$$ASL_{SS}&#x3D;\\frac{1}{n}\\sum_{i&#x3D;1}^{n}(n-i+1)&#x3D;\\frac{n+1}{2}$$ 等概率下查找不成功的平均查找长度（假定查找成功和查找不 成功的可能性相同，对每个记录的查找概率也相同）： $P_{i}&#x3D;\\frac{1}{2}$$C_{i}&#x3D;n+1$$$ASL_{SF}&#x3D;\\frac{1}{2}*(n+1)&#x3D;\\frac{n+1}{2}$$ 平均查找长度：$$ASL&#x3D;\\frac{n+1}{4}+\\frac{n+1}{2}&#x3D;\\frac{3}{4}(n+1)$$ 有序表的二分查找代码实现 123456789101112int Search_Bin ( SSTable ST, KeyType key ) &#123; low = 1 ; high = ST.length ; while ( low &lt;= high ) &#123; mid = ( low + high ) / 2 ; if ( EQ(ST.elem[mid]. key, key ) ) return mid ; else if ( LT( key , ST.elem[mid]. key ) ) high = mid -1 ; else low = mid + 1; &#125; return 0 ； &#125; // Search_Bin 性能分析 一般情况下，表长为n的折半查找的判定树的深度和含有n个 结点的完全二叉树的深度相同，设$n&#x3D;2^{h}-1$且查找概率相等 （1&#x2F;n），则折半查找成功的平均查找长度$$ASL_{SS}&#x3D;\\frac{1}{n}\\sum_{j&#x3D;1}^{h}j*2^{j-1}&#x3D;\\frac{n+1}{n}\\log_{2}{(n+1)}-1$$ 分块有序的查找（索引顺序表的查找）定义 顺序表+索引表组成 索引表按关键字有序，可用二分或顺序查找性能分析 长度为n的表平均分成n块，每块含有s个记录 $ASL_{bs}&#x3D;L_{b}+L_{s}$ $L_{b}$:索引表确定所在块的平均查找长度 $L_{s}$:块中查找元素的平均查找长度 $ASL_{bs}&#x3D;L_{b}+L_{s}&#x3D;b\\sum_{j&#x3D;1}^{b}j+s\\sum_{j&#x3D;1}^{s}j&#x3D;\\frac{b+1}{2}+\\frac{s+1}{2}$ 二叉查找树（二叉排序树）定义二叉排序树(二叉查找树）(Binary Sort Tree, BST)：空树或具有下列性质的二叉树:根的左子树若非空，则左子树上的所有结点的关键字值均小于根结点的值。根的右子树若非空，则右子树上的所有结点的关键字值均大于根结点的值。它的左右子树同样是二叉排序树。 中序遍历二叉排序树可得到一个关键字的有序序列算法实现1.查找 12345Status Search(BiTree T,KeyType key)&#123; if(T==NULL||EQ(key,T-&gt;data.key))return T; else if(LT(key,T-&gt;data.key)) return Search(T-&gt;left,key); else return Search(T-&gt;right,key);&#125; 2.插入&#x3D;&#x3D;改进查找算法&#x3D;&#x3D; 123456Status Search(BiTree T,KeyType key,BiTree f,BiTree &amp;p)&#123; if(!T)&#123;p=f; return false;&#125; else if(EQ(kEY,T-&gt;data.key))&#123;p=T;return true;&#125; else if(LT(key,T-&gt;data.key))return Search(T-&gt;left,key,T,p); else return Search(T-&gt;right,key,T,p);&#125; 123456789101112Status Insert(BiTree &amp;T,Element e)&#123; Bitree p; if(!Search(Bitree T,e.key,NULL,p))&#123;//查询失败 Bitree s=(BiTree)malloc(sizeof(BiTNode)); s-&gt;data=e;s-&gt;left=s-&gt;right=NULL; if(!p)T=s;//插入结点是根结点 else if(LT(e.key,p-&gt;data.key)) p-&gt;left=s; else p-&gt;right=s; return true; &#125; reutrn false;&#125; 3.删除 123456789101112131415161718192021222324252627282930Status DeleteBST(BSTree &amp;T,int key)&#123; if(!T)return FALSE;//空树 else&#123; if(EQ(key,T-&gt;data)) return Delete(T); else if(LT(key,T-&gt;data))&#123; return DeleteBST(T-&gt;lchild,key); &#125; else return DeleteBST(T-&gt;rchild,key); &#125;&#125;Status Delete(BSTree &amp;p)&#123; BSTree q=(BSTree)malloc(szieof(BiTNode)) if(!p-&gt;rchild)&#123; q=p;p=p-&gt;lchild;free(q); &#125;else if(!p-&gt;lchild)&#123; q=p;p=p-&gt;rchild;free(q); &#125;else&#123; q=p; s=p-&gt;lchild; while(s-&gt;rchild)&#123;//找左子树最大值 q=s; s=s-&gt;rchild; &#125; p-&gt;data=s-&gt;data;//取左子树最大值 if(q!=p)q-&gt;rchild=s-&gt;lchild;//悬挂最大值的左子树 else q-&gt;lchild=s-&gt;lchild; free(s); &#125;&#125; 性能分析 最坏情况：单支树，深度为n,$ASL_(ss)&#x3D;\\frac{n+1}{2}$ 最好情况：折半查找判定树，深度为n,$ASL_(ss)$与$log_(2)^(n)$成正比 哈希表排序插入排序直接插入排序（基于顺序查找）介绍 稳定排序 从未排序中依次取出元素与已排序的元素依次比较并插入到合适位置 缺点：大量数据时，比较和移动操作过多 优点：容易实现，适用于基本有序时间复杂度 $$O(n^{2})$$ 最好情况：比较n-1，移动0 最坏情况：比较$\\sum_{i&#x3D;2}^{n}i&#x3D;\\frac{(n+2)(n-1)}{2}$,移动$\\sum_{i&#x3D;2}^{n}(i+1)&#x3D;\\frac{(n+4)(n-1)}{2}$代码 12345678910111213141516171819202122void InsertionSort(SqLiist &amp;L)&#123; for(i=2;i&lt;=L.length;i++)&#123; if(LT(L.r[i].key,L.r[i-1].key))&#123; L.r[0]=L.r[i];//监视哨 L.r[i]=L.r[i-1]; for(int j=i-2;LT(L.r[0].key,L.r[j].key);--j) L.r[j+1]=L.r[j];//比监事哨大的一律右移动 L.r[j+1]=L.r[0]; &#125; &#125;&#125;void InsertionSort(SqLit &amp; L)&#123; for(int i=2;i&lt;=L.length;++i)&#123; if(LT(L.r[i].key,L.r[i-1].key))&#123; L.r[0]=L.r[i]; //复制为监视哨 L.r[i]=L.r[i-1]; for(int j=i-2;LT(L.r[0].key,L.r[j].key);--j) L.r[j+1]=L.r[j]; L.r[j+1]=L.r[0]; &#125; &#125;&#125; 折半插入排序（基于折半查找）介绍 稳定 把直接插入排序比较代码替换为折半查找插入位置时间复杂度 $$O(n^{2}) 仅仅优化了比较次数代码 123456789101112131415void BiInsertionSort(SqList &amp;L)&#123; for(int i=2;i&lt;L.length;i++)&#123; L.r[0]=L.r[i]; low=1;high=i-1; while(low&lt;=high)&#123; m=(low+high)/2; if(LT(L.r[0].key,L.r[m],key))&#123; high=m-1; &#125;else low=m+1; &#125; for(int j=i-1;j&gt;=high+1;j--) L.r[j+1]=L.r[j];//后移数据 L.r[high+1]=L.r[0];//插入 &#125;&#125; 希尔排序（基于逐趟缩小增量）介绍 不稳定 使用增量进行直接插入排序时间复杂度 在$O(nlog_{2}^{n})$与$O(n^{2})$之间代码 1234567891011121314151617void ShellSort (SqList &amp;L, int dlta[], int t)&#123; // 增量为dlta[]的希尔排序 for (k=0; k&lt;t; ++t) ShellInsert(L, dlta[k]); //一趟增量为dlta[k]的插入排序&#125; // ShellSortvoid ShellInsert ( SqList &amp;L, int dk ) &#123; for ( i=dk+1; i&lt;=L.length; ++i ) if (LT( L.r[i].key,L.r[i-dk].key)) &#123; L.r[0] = L.r[i]; // 暂存在r[0] for (j=i-dk; j&gt;0&amp;&amp; LT(L.r[0].key,L.r[j].key); j-=dk) L.r[j+dk] = L.r[j]; // 记录后移，查找插入位置 L.r[j+dk] = L.r[0]; // 插入 &#125; // if&#125; // ShellInsert 冒泡排序介绍 稳定 对n个数进行n-1趟排序，每次冒泡最大值时间复杂度 $O(n^{2})$ 最坏比较$\\sum_{i&#x3D;n}^{2}(i-1)&#x3D;\\frac{n(n-1)}{2}$ 最坏移动$3\\sum_{i&#x3D;n}^{2}(i-1)&#x3D;\\frac{3n(n-1)}{2}$代码 1234567891011121314151617181920212223242526void bubble_sort(int arr[], int size)&#123; int i = 0; int change = 1;//交换标志 for (i = 0,change=1; i &lt; size - 1&amp;&amp;change; i++) &#123; change = 0; int j = 0; for (j = 0; j &lt; size - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; change = 1; &#125; &#125; printf(&quot;第%d趟交换结果：&quot;,i+1); for (int k = 0; k &lt; size; k++) &#123; printf(&quot;%d &quot;, arr[k]); &#125; printf(&quot;\\n&quot;); &#125;&#125; 快速排序介绍 稳定 首先选一个枢值（即比较的基准），通过一趟排序将待排序记录分割成独立的两部分前一部分记录的关键码均小于或等于枢值，后一部分记录的关键码均大于或等于枢值，然后分别对这两部分重复上述方法，直到整个序列有序。时间复杂度 平均时间复杂度&#x3D;最好时间复杂度&#x3D;$O(nlog_{2}^{n})$ 最坏时间复杂度$O(n^{2})$（当序列有序时，退化为冒泡排序）代码 12345678910111213141516171819202122232425262728int Partition (SqList&amp; L, int low, int high) &#123;L.r[0]=L.r[low]; pivotkey = L.r[low].key; while (low&lt;high) &#123; while (low&lt;high &amp;&amp; L.r[high].key&gt;=pivotkey) --high; L.r[low]=L.r[high]; while (low&lt;high &amp;&amp; L.r[low].key&lt;=pivotkey) ++low; L.r[high]=L.r[low]; &#125;L.r[low]=L.r[0]; return low; // 返回枢轴所在位置&#125; // Partitionvoid QSort (SqList &amp;L, int low, int high) &#123; // 对记录序列R[s..t]进行快速排序 if (low &lt; high) &#123; // 长度大于1 pivotloc = Partition(L, low, high); // 对 R[s..t] 进行一次划分 QSort(L, low, pivotloc-1); // 对低子序列递归排序，pivotloc是枢轴位置 QSort(L, pivotloc+1, high); // 对高子序列递归排序 &#125;&#125; // QSortvoid QuickSort( SqList &amp; L) &#123; // 对顺序表进行快速排序 QSort(L, 1, L.length);&#125; // QuickSort 选择排序简单选择排序介绍 从无序序列中选出最小记录插入到有序序列时间复杂度 $O(n^{2})$ 比较总次数$\\sum_{i&#x3D;1}^{n-1}(n-i)&#x3D;\\frac{n(n-1)}{2}$代码 1234567891011void SelectSort (SqList &amp;L) &#123; // 对记录序列R[1..n]作简单选择排序。 for (i=1; i&lt;L.length; ++i) &#123; // 选择第 i 小的记录，并交换到位 j = SelectMinKey(L, i); // 在 R[i..n] 中选择关键字最小的记录 if (i!=j) L.r[i]←→L.r[j]; // 与第 i 个记录交换 &#125;&#125; // SelectSort 堆排序介绍 不稳定 大根堆&#x2F;小根堆：完全二叉树中所有非终端结点的值均不小于(或不大于)其左、右孩子结点的值。 若在输出堆顶的最小(大)值之后，使得剩余n-1个元素的序列重又建成一个堆，则得到 n个元素中的次小(大)值。此反复执行，便能得到一个有序序列，这个过程称之为堆排序。复杂度 时间复杂度$O(nlog_{2}^{n})$ 空间复杂度$O(1)$ 归并排序基数排序复杂度总结&#x3D;&#x3D;选择排序不稳定&#x3D;&#x3D; 基础算法埃及分数旅行规划对以自身为中心的景点按距离排序出行时间 12345678910111213141516171819202122#include&lt;stdio.h&gt;int main()&#123; int a,b,c,d,e; printf(&quot;分子，分母&quot;); scanf(&quot;%d,%d&quot;,&amp;a,&amp;b); printf(&quot;%d/%d=&quot;,a,b); do &#123; c=b/a; e=c+1; printf(&quot;1/%d+&quot;,e); a=a*e-b; b=b*e; &#125;while(a!=1&amp;&amp;b%a!=0); if(a!=1&amp;&amp;b%a==0) printf(&quot;1/%d&quot;,b/a); else printf(&quot;1/%d&quot;,b/a); return 0;&#125; 五个莫尼森数1234567891011121314151617181920212223242526272829303132333435#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main()&#123; int m,p=2,a=1,t,i,b,x; while(a&lt;=5) &#123; m=pow(2.0,p)-1; for(t=2;t&lt;m;t++) if(m%t==0)break; if(m==t) &#123; a++; printf(&quot;%d\\n&quot;,m); &#125; do &#123; p++; for(x=2;x&lt;p;x++) if(p%x==0)continue; &#125;while(p!=x); &#125; return 0;&#125; /*t = 0; while ( t == 0 ) &#123; p++; for ( t = 1, j = 2; t &amp;&amp; j &lt;= sqrt( p ); j++ ) if ( p % j == 0 ) t = 0; &#125;*/ 输出星号123456789101112131415161718192021##include &lt;stdio.h&gt; int main() &#123;int i,j,k; for (i=0;i&lt;=3;i++) &#123;for (j=0;j&lt;=2-i;j++) printf(&quot; &quot;); for (k=0;k&lt;=2*i;k++) printf(&quot;*&quot;); printf(&quot;\\n&quot;); &#125; for (i=0;i&lt;=2;i++) &#123;for (j=0;j&lt;=i;j++) printf(&quot; &quot;); for (k=0;k&lt;=4-2*i;k++) printf(&quot;*&quot;); printf(&quot;\\n&quot;); &#125; return 0; &#125; 分解质因数1234567891011121314151617181920#include &lt;stdio.h&gt;int main()&#123; int n, i; scanf( &quot;%d&quot;, &amp;n ); printf( &quot;%d=&quot;, n ); for ( i = 2; i &lt;= n; i++ ) while ( n != i ) &#123; if ( n % i == 0 ) &#123; printf( &quot;%d*&quot;, i ); n = n / i; &#125; else break; &#125; printf( &quot;%d&quot;, n ); &#125; 完数1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;int main()&#123; int i,j,sum=0; for(i=2;i&lt;=1000;i++) &#123; for(j=1;j&lt;i;j++) &#123; if(i%j==0) sum+=j; &#125; if(sum==i) &#123; printf(&quot;%d=1&quot;,sum); for(j=2;j&lt;i;j++) &#123; if(i%j==0) printf(&quot;+%d&quot;,j); &#125; &#125; if(sum==i)&#123; printf(&quot;\\n&quot;); &#125; sum=0; &#125; return 0;&#125; 质数12345678910111213141516171819202122232425#include &lt;stdio.h&gt;int main()&#123; int i,j,n=0; for(i=100;i&lt;=200;i++) &#123; for(j=2;j&lt;i;j++) &#123; if(i%j==0) break; &#125; if(j==i) &#123; printf(&quot;%d &quot;,i); n++; if(n%10==0) printf(&quot;\\n&quot;); &#125; &#125; return 0;&#125; 公约数，公倍数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;stdio.h&gt;int main()&#123; int m,n,r,x,t; while(2) &#123; printf(&quot;输入两个正整数：&quot;); scanf(&quot;%d,%d&quot;,&amp;n,&amp;m); if(n&lt;m) &#123;x=n; n=m; m=x; &#125;t=n*m; while(m!=0) &#123; r=n%m; n=m; m=r; &#125; printf(&quot;最大公约数为:%d\\n&quot;,n); printf(&quot;最小公倍数为:%d\\n&quot;,t/n); &#125; return 0;&#125;#include&lt;stdio.h&gt;int main()&#123; int m,n,i,x; scanf(&quot;%d,%d&quot;,&amp;m,&amp;n);/* for(i=m;i&gt;0;i--) if(m%i==0&amp;&amp;n%i==0) &#123;printf(&quot;max公约数:%d\\nmin公倍数:%d&quot;,i,m*n/i); break; &#125;*/ x=m*n; while(i!=0) &#123;i=m%n; m=n; n=i; &#125; printf(&quot;max公约数:%d\\nmin公倍数:%d&quot;,m,x/m); return 0; &#125; 分解质因子式123456789101112131415161718192021222324252627282930313233343536373839#include&lt;stdio.h&gt; #include&lt;math.h&gt;int main(void)&#123;int i,j;long int m, n;int count;int isPrime,flag;isPrime = 1;flag = 0;scanf(&quot;%ld&quot;,&amp;n);printf(&quot;%ld=&quot;,n);m = sqrt(n);for(i = 2; i &lt;= m;i++)&#123;if(n%i == 0)&#123;//printf(&quot;%d&quot;,i);isPrime = 0;count = 1;n = n / i;while(n%i == 0)&#123;n = n / i;count++;&#125;if(flag)printf(&quot;*&quot;);elseflag = 1;if(count == 1)printf(&quot;%d&quot;,i);elseprintf(&quot;%d^%d&quot;,i,count);&#125;&#125;if(isPrime)printf(&quot;%d&quot;,n);return 0;&#125; 统计单词个数12345678910111213141516#include&lt;stdio.h&gt;int main()&#123; char string[81]; int i,sum=0,word=0; char c; gets(string); for(i=0;(c=string[i]!=&#x27;\\0&#x27;;i++) if(c==&#x27;&#x27;)word=0; else if(word==0)&#123; word=1; num++; &#125; printf(&quot;There are %d words in this line.\\n&quot;,sum); retun 0;&#125; 数字变字符123456#include&lt;stdio.h&gt;int main()&#123; return 0;&#125; 1234567891011121314151617181920212223242526272829public class VedioExtractSpeech &#123; public static void main(String[] args) &#123; System.out.println(&quot;toChinese：&quot;+toChinese(&quot;1230456&quot;)); System.out.println(&quot;toChinese2：&quot;+toChinese2(&quot;1230456&quot;)); &#125; private static String toChinese(String str) &#123; String[] s1 = &#123; &quot;零&quot;, &quot;一&quot;, &quot;二&quot;, &quot;三&quot;, &quot;四&quot;, &quot;五&quot;, &quot;六&quot;, &quot;七&quot;, &quot;八&quot;, &quot;九&quot; &#125;; String[] s2 = &#123; &quot;十&quot;, &quot;百&quot;, &quot;千&quot;, &quot;万&quot;, &quot;十&quot;, &quot;百&quot;, &quot;千&quot;, &quot;亿&quot;, &quot;十&quot;, &quot;百&quot;, &quot;千&quot; &#125;; String result = &quot;&quot;; int n = str.length(); for (int i = 0; i &lt; n; i++) &#123; int num = str.charAt(i) - &#x27;0&#x27;; if (i != n - 1 &amp;&amp; num != 0) &#123; result += s1[num] + s2[n - 2 - i]; &#125; else &#123; result += s1[num]; &#125; &#125; return result; &#125; private static String toChinese2(String str) &#123; String[] s2 = &#123;&quot;零&quot;, &quot;一&quot;, &quot;二&quot;, &quot;三&quot;, &quot;四&quot;, &quot;五&quot;, &quot;六&quot;, &quot;七&quot;, &quot;八&quot;, &quot;九&quot;&#125;; StringBuffer sb=new StringBuffer(); for (char c : str.toCharArray()) &#123; sb.append(s2[Integer.parseInt(String.valueOf(c))]); &#125; return sb.toString(); &#125;&#125; 取每一位数字12int a = 4567895：a//10000%10 二分法循环12345678910111213141516171819202122232425int search(int* nums, int numsSize, int target)&#123; int low=0 , high=numsSize-1; int half=(low+high)/2; while (low&lt;=high)&#123; half = (low + high) / 2; if (nums[half]==target) break; if (nums[half]&gt;target)&#123; high=half-1; continue; &#125; if (nums[half]&lt;target)&#123; low=half+1; continue; &#125; &#125; if(nums[half]==target)&#123; return half; &#125; else return -1; &#125; 123456789101112131415161718192021222324252627282930313233package javasuanfa;public class Main &#123; public static void main(String[] args) &#123; int[] nums = &#123;1, 2, 3, 4, 5, 6&#125;; int target = 3; System.out.println(search(nums, target)); &#125; public static int search(int[] nums, int target) &#123; if (target &lt; nums[0] || target &gt; nums[nums.length - 1]) &#123; return -1; &#125; int left = 0; int right = nums.length - 1; while (left &lt;= right) &#123; int mid = (left + right) / 2; if (nums[mid] == target) &#123; return mid; &#125; else if (target &lt; nums[mid]) &#123; right = mid - 1; &#125; else if (target &gt; nums[mid]) &#123; left = mid + 1; &#125; &#125; return -1; &#125; &#125; 123456789101112131415161718192021222324252627282930package javasuanfa;public class Main &#123; public static void main(String[] args) &#123; int[] nums = &#123;1, 2, 3, 4, 5, 6&#125;; int target = 3; System.out.println(search(nums, target,0,nums.length-1)); &#125; public static int search(int[] nums, int target, int left, int right) &#123; if (target &lt; nums[0] || target &gt; nums[nums.length - 1]) &#123; return -1; &#125; left = 0; right = nums.length - 1; int mid = (left + right) / 2; if (target &lt; nums[mid]) &#123; return search(nums, target, left, mid - 1); &#125; else if (target &gt; nums[mid]) &#123; return search(nums, target, mid + 1, right); &#125; else &#123; return mid; &#125; &#125; &#125; 排序算法打擂台12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;int main()&#123; int a[3][4]=&#123;&#123;0,1,2,3&#125;,&#123;4,5,6,7&#125;,&#123;8,9,10,11&#125;&#125;,t,x,y,max,row,colum; max=a[0][0]; for(x=0;x&lt;=2;x++) &#123;for(y=0;y&lt;=3;y++) if(a[x][y]&gt;max) &#123; max=a[x][y]; row=x; colum=y; &#125; else &#123; row=0; colum=0; &#125; &#125; printf(&quot;max=%d\\nrow=%d\\ncolum=%d\\n&quot;,max,row+1,colum+1); return 0;&#125; 冒泡排序c语言1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;void bubble_sort(int arr[], int size)&#123; int i = 0; int change = 1;//交换标志 for (i = 0,change=1; i &lt; size - 1&amp;&amp;change; i++) &#123; change = 0; int j = 0; for (j = 0; j &lt; size - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; change = 1; &#125; &#125; printf(&quot;第%d趟交换结果：&quot;,i+1); for (int k = 0; k &lt; size; k++) &#123; printf(&quot;%d &quot;, arr[k]); &#125; printf(&quot;\\n&quot;); &#125;&#125;int main()&#123; int size = 0; printf(&quot;输入数组大小size:&quot;); scanf(&quot;%d&quot;, &amp; size); int arr[100]; int i = 0; printf(&quot;输入要升序排序的数组:&quot;); for (i = 0; i &lt; size; i++) &#123; scanf(&quot;%d&quot;,&amp;arr[i]); &#125; printf(&quot;排序前：&quot;); for (i = 0; i &lt; size; i++) &#123; printf(&quot;%d &quot;, arr[i]); &#125; printf(&quot;\\n&quot;); bubble_sort(arr, size); // 冒泡排序函数 printf(&quot;排序后：&quot;); for (i = 0; i &lt; size; i++) &#123; printf(&quot;%d &quot;, arr[i]); &#125; return 0;&#125; 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;int main()&#123; int a[10],t,i,n; printf(&quot;input10nums:&quot;); for(i=0;i&lt;=9;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(n=0;n&lt;=8;n++)//8=N-2&#123; for(i=0;i&lt;=8-n;i++)//8-n=N-2-n &#123;if(a[i]&gt;a[i+1]) &#123;t=a[i]; a[i]=a[i+1]; a[i+1]=t; &#125; &#125;&#125;for(i=0;i&lt;=9;i++)printf(&quot;%d\\n&quot;,a[i]); return 0;&#125; java123456789101112131415161718192021222324252627public class Main&#123; public static void main(String []args)&#123; int arry[]=&#123;3,2,5,6,8,7&#125;; Main sorter=new Main(); sorter.sort(arry); &#125; public void sort(int[] array)&#123; for(int i = 0;i&lt;array.length-1;i++)&#123; for(int k = 0;k&lt;array.length-1-i;k++)&#123; if(array[k]&gt;array[k+1])&#123; int temp=array[k]; array[k]=array[k+1]; array[k+1]=temp; &#125; &#125; &#125; showArray(array); &#125; public void showArray(int[] aray)&#123; for(int x:aray)&#123; System.out.print(x ); &#125; &#125; &#125; 链表冒泡排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define LEN sizeof(struct student)struct student&#123;long num; int score; struct student *next;&#125;;struct student lista,listb;int n,sum=0;int main()&#123;struct student *creat(void); struct student *insert(struct student *,struct student *); void print(struct student *); struct student *px(struct student *abh,int sum); struct student *ahead,*bhead,*abh; printf(&quot;input list a:\\n&quot;); ahead=creat(); sum=sum+n; printf(&quot;input list b:\\n&quot;); bhead=creat(); sum=sum+n; abh=insert(ahead,bhead); abh=px(abh,sum); print(abh); return 0;&#125;struct student *creat(void) //建立链表函数 &#123;struct student *p1,*p2,*head; n=0; p1=p2=(struct student *)malloc(LEN); printf(&quot;input number &amp; scores of student:\\n&quot;); printf(&quot;if number is 0,stop inputing.\\n&quot;); scanf(&quot;%ld,%d&quot;,&amp;p1-&gt;num,&amp;p1-&gt;score); head=NULL; while(p1-&gt;num !=0) &#123;n=n+1; if (n==1) head=p1; else p2-&gt;next=p1; p2=p1; p1=(struct student *)malloc(LEN); scanf(&quot;%ld,%d&quot;,&amp;p1-&gt;num,&amp;p1-&gt;score); &#125; p2-&gt;next=NULL; return(head);&#125; /*struct student *insert(struct student *ah,struct student *bh) //插入函数 &#123;struct student * pa1,* pa2,* pb1,* pb2; pa2=pa1=ah; pb2=pb1=bh; do &#123;while((pb1-&gt;num&gt;pa1-&gt;num) &amp;&amp; (pa1-&gt;next !=NULL)) &#123;pa2=pa1; pa1=pa1-&gt;next; &#125; if (pb1-&gt;num &lt;= pa1-&gt;num) &#123;if (ah==pa1) ah=pb1; else pa2-&gt;next=pb1; pb1=pb1-&gt;next; pb2-&gt;next=pa1; pa2=pb2; pb2=pb1; &#125; &#125;while ((pa1-&gt;next!=NULL) || (pa1==NULL &amp;&amp; pb1!=NULL)); if ((pb1!=NULL) &amp;&amp; (pb1-&gt;num&gt;pa1-&gt;num) &amp;&amp; (pa1-&gt;next==NULL)) pa1-&gt;next=pb1; return(ah); &#125;*/struct student *insert(struct student *ah,struct student *bh)&#123; struct student *pnew; pnew=ah; while(pnew-&gt;next!=NULL) &#123; pnew=pnew-&gt;next; &#125; pnew-&gt;next=bh; return(ah);&#125;struct student *px(struct student *abh,int sum)&#123; struct student *p,*p1,*p2,*p2pre; p=NULL; p1=p2=p2pre=abh; int count=1; while(count&lt;sum) &#123; p1=p2=p2pre=abh; while(p1-&gt;next!=NULL) &#123; p2pre=p2; p2=p1; p1=p1-&gt;next; if((p1-&gt;num)&lt;(p2-&gt;num)) &#123; if(abh==p2)abh=p1; else p2pre-&gt;next=p1; p2-&gt;next=p1-&gt;next; p1-&gt;next=p2; &#125; &#125; count++; &#125; return abh; &#125;void print(struct student *head) //输出函数 &#123;struct student *p; printf(&quot;There are %d records: \\n&quot;,sum); p=head; if (p !=NULL) do &#123;printf(&quot;%ld %d\\n&quot;,p-&gt;num,p-&gt;score); p=p-&gt;next; &#125;while (p !=NULL); &#125; 快速排序c语言1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;stdio.h&gt;void quicksort(int arry[],int L,int R)&#123; if(L&gt;=R) return ; int left=L,right=R; int pivot=arry[L]; while(left&lt;right) &#123; while(left&lt;right&amp;&amp;arry[right]&gt;=pivot) &#123;right--; &#125; //if(left&lt;right) arry[left]=arry[right]; while(left&lt;right&amp;&amp;arry[left]&lt;=pivot) &#123;left++; &#125; //if(left&lt;right) arry[right]=arry[left]; //if(left&gt;=right) //arry[left]=pivot; &#125; arry[left]=pivot; quicksort(arry,L,right-1); quicksort(arry,right+1,R);&#125;int main()&#123; int arry[9]; int i,j; for(i=0;i&lt;9;i++) &#123;printf(&quot;%dth:&quot;,i+1); scanf(&quot;%d&quot;,&amp;arry[i]); &#125; quicksort(arry,0,8); for(j=0;j&lt;9;j++) &#123;printf(&quot;%d &quot;,arry[j]); &#125; return 0;&#125; 反转排序java123456789101112131415161718192021222324public class Main&#123; public static void main(String []args)&#123; int arry[]=&#123;3,2,5,6,8,7&#125;; Main sorter=new Main(); sorter.sort(arry); &#125; public void sort(int[] array)&#123; int temp; int len=array.length; for(int i = 0;i&lt;len/2;i++)&#123; temp=array[i]; array[i]=array[len-1-i]; array[len-1-i]=temp; &#125; showArray(array); &#125; public void showArray(int[] aray)&#123; for(int x:aray)&#123; System.out.print(x ); &#125; &#125; &#125; 链表快速排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define LEN sizeof(struct student)struct student&#123; int num; int score; struct student* next;&#125;;struct student lista, listb;int n, sum = 0;int main()&#123; struct student* creat(void); struct student* insert(struct student*, struct student*); void print(struct student*); struct student* bianli(struct student* abh); void px(struct student* abh, struct student* abe); void swapnode(struct student* i, struct student* j); struct student* ahead, * bhead, * abh,*abe; printf(&quot;input list a:\\n&quot;); ahead = creat(); sum = sum + n; printf(&quot;input list b:\\n&quot;); bhead = creat(); sum = sum + n; abh = insert(ahead, bhead); abe = bianli(abh); px(abh, abe); print(abh); return 0;&#125;struct student* creat(void) //建立链表函数&#123; struct student* p1, * p2, * head; n = 0; p1 = p2 = (struct student*)malloc(LEN); printf(&quot;input number &amp; scores of student:\\n&quot;); printf(&quot;if number is 0,stop inputing.\\n&quot;); scanf(&quot;%ld,%d&quot;, &amp;p1-&gt;num, &amp;p1-&gt;score); head = NULL; while (p1-&gt;num != 0) &#123; n = n + 1; if (n == 1) head = p1; else p2-&gt;next = p1; p2 = p1; p1 = (struct student*)malloc(LEN); scanf(&quot;%ld,%d&quot;, &amp;p1-&gt;num, &amp;p1-&gt;score); &#125; p2-&gt;next = NULL; return(head);&#125;/*struct student *insert(struct student *ah,struct student *bh) //插入函数 &#123;struct student * pa1,* pa2,* pb1,* pb2; pa2=pa1=ah; pb2=pb1=bh; do &#123;while((pb1-&gt;num&gt;pa1-&gt;num) &amp;&amp; (pa1-&gt;next !=NULL)) &#123;pa2=pa1; pa1=pa1-&gt;next; &#125; if (pb1-&gt;num &lt;= pa1-&gt;num) &#123;if (ah==pa1) ah=pb1; else pa2-&gt;next=pb1; pb1=pb1-&gt;next; pb2-&gt;next=pa1; pa2=pb2; pb2=pb1; &#125; &#125;while ((pa1-&gt;next!=NULL) || (pa1==NULL &amp;&amp; pb1!=NULL)); if ((pb1!=NULL) &amp;&amp; (pb1-&gt;num&gt;pa1-&gt;num) &amp;&amp; (pa1-&gt;next==NULL)) pa1-&gt;next=pb1; return(ah); &#125;*/struct student* insert(struct student* ah, struct student* bh)&#123; struct student* pnew; pnew = ah; while (pnew-&gt;next != NULL) &#123; pnew = pnew-&gt;next; &#125; pnew-&gt;next = bh; return(ah);&#125;/*struct student* px(struct student* abh, int sum)&#123; struct student* p, * p1, * p2, * p2pre; p = NULL; p1 = p2 = p2pre = abh; int count = 1; while (count &lt; sum) &#123; p1 = p2 = p2pre = abh; while (p1-&gt;next != NULL) &#123; p2pre = p2; p2 = p1; p1 = p1-&gt;next; if ((p1-&gt;num) &lt; (p2-&gt;num)) &#123; if (abh == p2)abh = p1; else p2pre-&gt;next = p1; p2-&gt;next = p1-&gt;next; p1-&gt;next = p2; &#125; &#125; count++; &#125; return abh;&#125;*/struct student* bianli(struct student* abh)&#123; struct student* abe; abe = abh; while (abe-&gt;next != NULL) &#123; abe = abe-&gt;next; &#125; return abe;&#125;void px(struct student* abh, struct student* abe)&#123; if ((abe == abh) || (abh-&gt;next == NULL) || (abh == NULL)) return ; void swapnode(struct student* i, struct student* j); struct student* ipre, * i, * j; int pivot; ipre = abh; j=i = abh-&gt;next; pivot = abh-&gt;num; while (j != NULL) &#123; if (j-&gt;num &lt; pivot) &#123; swapnode(i, j); ipre=i; i=i-&gt;next; &#125; j=j-&gt;next; &#125; swapnode(abh, ipre); px(abh, ipre); px(i, abe); return ;&#125;void swapnode(struct student* i, struct student* j)&#123; int a, b; a = i-&gt;num; i-&gt;num = j-&gt;num; j-&gt;num = a; b = i-&gt;score; i-&gt;score = j-&gt;score; j-&gt;score = b;&#125;void print(struct student* head) //输出函数&#123; struct student* p; printf(&quot;There are %d records: \\n&quot;, sum); p = head; if (p != NULL) do &#123; printf(&quot;%ld %d\\n&quot;, p-&gt;num, p-&gt;score); p = p-&gt;next; &#125; while (p != NULL);&#125; 简单插入排序1 希尔排序法1 选择法排序c语言123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;int main()&#123; int i,j,k,n,m,max,t; //scanf(&quot;%d&quot;,&amp;n); int a[]=&#123;1,2,5,9,5&#125;; int len = sizeof(a)/sizeof(a[0]); // for(k=0;k&lt;=len;k++) //scanf(&quot;%d&quot;,a[k]); for(j=0;j&lt;len-1;j++) &#123;max=a[j]; for(i=j+1;i&lt;=len;i++) if(a[i]&gt;max) &#123; max=a[i]; t=a[j]; a[j]=a[i]; a[i]=t; &#125; &#125; for(k=0;k&lt;=len-1;k++) printf(&quot;%d&quot;,a[k]) ; return 0;&#125; java123456789101112131415161718192021222324252627282930public class Main&#123; public static void main(String []args)&#123; int arry[]=&#123;3,2,5,6,8,7&#125;; Main sorter=new Main(); sorter.sort(arry); &#125; public void sort(int[] array)&#123; int index; for(int i = 1;i&lt;array.length;i++)&#123; index=0; for(int k = 1;k&lt;=array.length-i;k++)&#123; if(array[k]&gt;array[index])&#123; index=k; &#125; &#125; int temp=array[array.length-i]; array[array.length-i]=array[index]; array[index]=temp; &#125; showArray(array); &#125; public void showArray(int[] aray)&#123; for(int x:aray)&#123; System.out.print(x ); &#125; &#125; &#125; 堆排序法1 双指针删除数组元素1234567891011121314Int return()&#123;Int slowp=0;Int fastp=0;For(fastp=0;fastp&lt;=numszie;fastp++)&#123;If(nums[fastp]!=val)Nums[slowp++]=nums[fastp];&#125;Return slowp;&#125; 123456789101112public int removeElement(int[] nums, int val) &#123; int slowp=0; for(int fastp=0;fastp&lt;nums.length;fastp++)&#123; if(nums[fastp]!=val)&#123; nums[slowp++]=nums[fastp]; &#125; &#125; return slowp; &#125; 数组平方排序123456789101112131415161718192021222324/** * Note: The returned array must be malloced, assume caller calls free(). */int* sortedSquares(int* nums, int numsSize, int* returnSize)&#123; *returnSize=numsSize; int k; int left=0; int right=numsSize-1; int* result=(int*)malloc(sizeof(int) * numsSize); for(k=numsSize-1;k&gt;=0;k--)&#123; int lsquare=nums[left]*nums[left]; int rsquare=nums[right]*nums[right]; if(rsquare&gt;lsquare)&#123; result[k]=rsquare; right--; &#125; else&#123; result[k]=lsquare; left++; &#125; &#125; return result;&#125; 123456789101112131415161718public int[] sortedSquares(int[] nums) &#123; int[] result =new int[nums.length]; int left=0; int right=nums.length-1; for(int k=nums.length-1;k&gt;=0;k--)&#123; int lsquare=nums[left]*nums[left]; int rqsuare=nums[right]*nums[right]; if(rqsuare&gt;lsquare) &#123; result[k] = rqsuare; right--; &#125; else &#123; result[k]=lsquare; left++; &#125; &#125; return result; &#125; 滑动窗口12345678910111213public int minSubArrayLen(int target, int[] nums) &#123; int left = 0; int sum = 0; int result = Integer.MAX_VALUE; for (int right = 0; right &lt; nums.length; right++) &#123; sum += nums[right]; while (sum &gt;= target) &#123; result = Math.min(result, right - left + 1); sum -= nums[left++]; &#125; &#125; return result == Integer.MAX_VALUE ? 0 : result; &#125; 迷宫12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/* * To change this template, choose Tools | Templates * and open the template in the editor. */package migong;/** * * @author Administrator */public class Main &#123; /** * @param args the command line arguments */ public static void main(String[] args) &#123; //绘制迷宫 int[][] map = new int[8][7]; //最上与最下s for (int i = 0; i &lt; 7; i++) &#123; map[0][i] = 1; map[7][i] = 1; &#125; //最左与最右 for (int i = 0; i &lt; 8; i++) &#123; map[i][0] = 1; map[i][6] = 1; &#125; //额外 map[3][1] = map[3][2] = 1; map[4][2] = map[5][2] = map[6][2] = 1; map[4][4] = map[5][4] = map[6][4] = 1; System.out.println(&quot;当前地图======&quot;); for (int i = 0; i &lt; map.length; i++) &#123; for (int j = 0; j &lt; map[i].length; j++) &#123; System.out.print(map[i][j] + &quot;&quot;); &#125; System.out.println(); &#125; //找路 T t1 = new T(); t1.findway(map, 1, 1); System.out.println(&quot;\\n======找路的情况如下======&quot;); for (int i = 0; i &lt; map.length; i++) &#123; for (int j = 0; j &lt; map[i].length; j++) &#123; System.out.print(map[i][j] + &quot;&quot;); &#125; System.out.println(); &#125; &#125;&#125;class T &#123; //初始位置(1,1) // 0表示可以走 1 表示障碍物 2表示可以走(通路)3走过但是死路 public boolean findway(int[][] map, int i, int j) &#123; if (map[6][5] == 2) &#123;//找到 return true; &#125; else &#123; if (map[i][j] == 0) &#123;//可以走没走过 map[i][j] = 2; if (findway(map, i + 1, j)) &#123; return true; &#125; else if (findway(map, i, j + 1)) &#123; return true; &#125; else if (findway(map, i - 1, j)) &#123; return true; &#125; else if (findway(map, i, j - 1)) &#123; return true; &#125; else &#123; map[i][j] = 3; return false; &#125; &#125; else &#123; return false; &#125; &#125; &#125;&#125;s","categories":[{"name":"culitivate","slug":"culitivate","permalink":"http://example.com/categories/culitivate/"},{"name":"408","slug":"culitivate/408","permalink":"http://example.com/categories/culitivate/408/"},{"name":"算法","slug":"culitivate/408/算法","permalink":"http://example.com/categories/culitivate/408/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"","slug":"plan/记录","date":"2022-09-24T12:41:46.398Z","updated":"2023-09-20T08:42:18.828Z","comments":true,"path":"2022/09/25a6efba0f40.html","link":"","permalink":"http://example.com/2022/09/25a6efba0f40.html","excerpt":"","text":"常用记录把输出记录到文件 1234567# Save all the Print Statements in a Log file.old_stdout = sys.stdoutlog_file = open(&quot;summary.log&quot;,&quot;w&quot;)sys.stdout = log_file C++scanf不安全#define _CRT_SECURE_NO_WARNINGS 【C++】| 将程序打包成可执行文件（.exe）| Visual Studiohttps://blog.csdn.net/HaohaoCppDebuger/article/details/123451160 ffmpeg使用教程https://www.jianshu.com/p/2c00a1a59af1 在线思维导图https://www.processon.com/diagrams 腾讯图床登录 - 腾讯云 (tencent.com) 在线转换pdfhttps://convertio.co/zh/pptx-pdf/ 在线解密pdfhttps://smallpdf.com/cn/result#r=02670d7e41d25b3d4b4e002b9ad38d42&amp;t=unlock 翻译腾讯文件翻译免费腾讯交互翻译TranSmart (qq.com) Deepl翻译文件DeepL Pro|安全翻译文本，Word文档&amp;其他文档 Arduino代码教程https://blog.csdn.net/SumubeiFZ/article/details/118638228 硬件教程https://blog.csdn.net/SFME008/article/details/110479408 模拟器https://www.tinkercad.com/ 密码mysqlmysql -u root -pz94y9397 宝塔面板外网面板地址: https://47.120.14.52:29842/9789895a内网面板地址: https://172.27.217.192:29842/9789895ausername: owk5vwkapassword: z94y9397 阿里云服务器云服务器zxxyddz94y9397云数据库mzxxyddz94y9397云数据库账号zxxyddZ94y9397云数据库外网地址rm-bp1nmvt3r7t7v1e7zwo.mysql.rds.aliyuncs.com博客zxyZ94y9397博客园安xyz94y9397谷歌y’xiang&#97;&#110;&#x73;&#104;&#x65;&#110;&#103;&#x39;&#52;&#57;&#51;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;Z94y9397 sm.msansheng9493z94y9397 VNCZ94y93 root@Z94y9397 火狐&#x33;&#x32;&#x34;&#48;&#x39;&#x35;&#x36;&#55;&#x32;&#52;&#64;&#113;&#113;&#46;&#x63;&#111;&#x6d;z94y9397","categories":[{"name":"plan","slug":"plan","permalink":"http://example.com/categories/plan/"}],"tags":[]}],"categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"数理逻辑","slug":"课程笔记/数理逻辑","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91/"},{"name":"R","slug":"课程笔记/R","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/R/"},{"name":"实验一","slug":"课程笔记/R/实验一","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/R/%E5%AE%9E%E9%AA%8C%E4%B8%80/"},{"name":"工具记录","slug":"工具记录","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7%E8%AE%B0%E5%BD%95/"},{"name":"普通话","slug":"工具记录/普通话","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7%E8%AE%B0%E5%BD%95/%E6%99%AE%E9%80%9A%E8%AF%9D/"},{"name":"culitivate","slug":"culitivate","permalink":"http://example.com/categories/culitivate/"},{"name":"java技术栈","slug":"culitivate/java技术栈","permalink":"http://example.com/categories/culitivate/java%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"vue","slug":"culitivate/java技术栈/vue","permalink":"http://example.com/categories/culitivate/java%E6%8A%80%E6%9C%AF%E6%A0%88/vue/"},{"name":"plan","slug":"plan","permalink":"http://example.com/categories/plan/"},{"name":"软件工程基础","slug":"课程笔记/软件工程基础","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"name":"复杂网络","slug":"课程笔记/复杂网络","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E5%A4%8D%E6%9D%82%E7%BD%91%E7%BB%9C/"},{"name":"小实验1","slug":"课程笔记/复杂网络/小实验1","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E5%A4%8D%E6%9D%82%E7%BD%91%E7%BB%9C/%E5%B0%8F%E5%AE%9E%E9%AA%8C1/"},{"name":"java","slug":"culitivate/java技术栈/java","permalink":"http://example.com/categories/culitivate/java%E6%8A%80%E6%9C%AF%E6%A0%88/java/"},{"name":"mysql","slug":"culitivate/java技术栈/mysql","permalink":"http://example.com/categories/culitivate/java%E6%8A%80%E6%9C%AF%E6%A0%88/mysql/"},{"name":"408","slug":"culitivate/408","permalink":"http://example.com/categories/culitivate/408/"},{"name":"other","slug":"culitivate/other","permalink":"http://example.com/categories/culitivate/other/"},{"name":"CTF","slug":"culitivate/other/CTF","permalink":"http://example.com/categories/culitivate/other/CTF/"},{"name":"Linux","slug":"culitivate/java技术栈/Linux","permalink":"http://example.com/categories/culitivate/java%E6%8A%80%E6%9C%AF%E6%A0%88/Linux/"},{"name":"PHP","slug":"culitivate/PHP","permalink":"http://example.com/categories/culitivate/PHP/"},{"name":"vim","slug":"工具记录/vim","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7%E8%AE%B0%E5%BD%95/vim/"},{"name":"git","slug":"culitivate/java技术栈/git","permalink":"http://example.com/categories/culitivate/java%E6%8A%80%E6%9C%AF%E6%A0%88/git/"},{"name":"project","slug":"project","permalink":"http://example.com/categories/project/"},{"name":"2023暑期项目health","slug":"project/2023暑期项目health","permalink":"http://example.com/categories/project/2023%E6%9A%91%E6%9C%9F%E9%A1%B9%E7%9B%AEhealth/"},{"name":"Python","slug":"culitivate/Python","permalink":"http://example.com/categories/culitivate/Python/"},{"name":"大学语文","slug":"课程笔记/大学语文","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E5%A4%A7%E5%AD%A6%E8%AF%AD%E6%96%87/"},{"name":"安卓论文","slug":"课程笔记/安卓论文","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E5%AE%89%E5%8D%93%E8%AE%BA%E6%96%87/"},{"name":"数据挖掘","slug":"课程笔记/数据挖掘","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"},{"name":"实验报告","slug":"课程笔记/数据挖掘/实验报告","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"机器学习","slug":"culitivate/other/机器学习","permalink":"http://example.com/categories/culitivate/other/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"python","slug":"课程笔记/python","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/python/"},{"name":"作业","slug":"课程笔记/数据挖掘/作业","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/%E4%BD%9C%E4%B8%9A/"},{"name":"数学建模笔记","slug":"culitivate/other/数学建模笔记","permalink":"http://example.com/categories/culitivate/other/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AC%94%E8%AE%B0/"},{"name":"爬虫","slug":"culitivate/Python/爬虫","permalink":"http://example.com/categories/culitivate/Python/%E7%88%AC%E8%99%AB/"},{"name":"建站","slug":"工具记录/建站","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7%E8%AE%B0%E5%BD%95/%E5%BB%BA%E7%AB%99/"},{"name":"算法","slug":"culitivate/408/算法","permalink":"http://example.com/categories/culitivate/408/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"culitivate/C","permalink":"http://example.com/categories/culitivate/C/"}],"tags":[{"name":"-算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]}